
MASTER.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002d80  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000124  00800060  00002d80  00002e14  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002d2  00800184  00800184  00002f38  2**0
                  ALLOC
  3 .stab         00006f24  00000000  00000000  00002f38  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000052be  00000000  00000000  00009e5c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1f 05 	jmp	0xa3e	; 0xa3e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e8       	ldi	r30, 0x80	; 128
      68:	fd e2       	ldi	r31, 0x2D	; 45
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 38       	cpi	r26, 0x84	; 132
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a4 e8       	ldi	r26, 0x84	; 132
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 35       	cpi	r26, 0x56	; 86
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 48 16 	call	0x2c90	; 0x2c90 <main>
      8a:	0c 94 be 16 	jmp	0x2d7c	; 0x2d7c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <SPI_voidInit>:
      92:	88 23       	and	r24, r24
      94:	19 f0       	breq	.+6      	; 0x9c <SPI_voidInit+0xa>
      96:	81 30       	cpi	r24, 0x01	; 1
      98:	59 f4       	brne	.+22     	; 0xb0 <SPI_voidInit+0x1e>
      9a:	08 c0       	rjmp	.+16     	; 0xac <SPI_voidInit+0x1a>
      9c:	6c 9a       	sbi	0x0d, 4	; 13
      9e:	69 98       	cbi	0x0d, 1	; 13
      a0:	70 9a       	sbi	0x0e, 0	; 14
      a2:	bd 9a       	sbi	0x17, 5	; 23
      a4:	be 98       	cbi	0x17, 6	; 23
      a6:	bf 9a       	sbi	0x17, 7	; 23
      a8:	bc 9a       	sbi	0x17, 4	; 23
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <SPI_voidInit+0x1e>
      ac:	6c 98       	cbi	0x0d, 4	; 13
      ae:	be 9a       	sbi	0x17, 6	; 23
      b0:	6d 98       	cbi	0x0d, 5	; 13
      b2:	6b 98       	cbi	0x0d, 3	; 13
      b4:	6a 9a       	sbi	0x0d, 2	; 13
      b6:	6e 9a       	sbi	0x0d, 6	; 13
      b8:	08 95       	ret

000000ba <SPI_u8transcieve>:
	SET_BIT(SPCR,SPE);
}

u8   SPI_u8transcieve	(u8 Copy_u8TransmitByte){
	//put Data to begin transmition
	SPDR = Copy_u8TransmitByte ;
      ba:	8f b9       	out	0x0f, r24	; 15
	//wait until transmition ends
	while(GET_BIT(SPSR,SPIF) == 0);
      bc:	77 9b       	sbis	0x0e, 7	; 14
      be:	fe cf       	rjmp	.-4      	; 0xbc <SPI_u8transcieve+0x2>
	//return the data
	return SPDR ;
      c0:	8f b1       	in	r24, 0x0f	; 15
}
      c2:	08 95       	ret

000000c4 <ADC_init>:
#include "../../LIB/STD_TYPES.h"
#include "../../LIB/BIT_MATH.h"
#include "ADC.h"

void ADC_init(){
	ADMUX = 0;
      c4:	17 b8       	out	0x07, r1	; 7
	SET_BIT(ADCSRA, ADEN);
      c6:	37 9a       	sbi	0x06, 7	; 6
}
      c8:	08 95       	ret

000000ca <ADC_read>:

u16 ADC_read(u8 bit_num){
	ADMUX = (ADMUX & 0xF8) | (bit_num & 0x07);
      ca:	97 b1       	in	r25, 0x07	; 7
      cc:	87 70       	andi	r24, 0x07	; 7
      ce:	98 7f       	andi	r25, 0xF8	; 248
      d0:	89 2b       	or	r24, r25
      d2:	87 b9       	out	0x07, r24	; 7
	SET_BIT(ADCSRA,ADSC);
      d4:	36 9a       	sbi	0x06, 6	; 6
	while(GET_BIT(ADCSRA,ADIF)==0);
      d6:	34 9b       	sbis	0x06, 4	; 6
      d8:	fe cf       	rjmp	.-4      	; 0xd6 <ADC_read+0xc>
	return ADCL | (ADCH << 8);
      da:	24 b1       	in	r18, 0x04	; 4
      dc:	45 b1       	in	r20, 0x05	; 5
      de:	94 2f       	mov	r25, r20
      e0:	80 e0       	ldi	r24, 0x00	; 0
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	28 2b       	or	r18, r24
      e6:	39 2b       	or	r19, r25
}
      e8:	c9 01       	movw	r24, r18
      ea:	08 95       	ret

000000ec <LCD_WRITE_DATA>:
	 _delay_ms(2);
	 LCD_WRITE_CMD(ENTRY_MODE_SET);
}
void LCD_WRITE_DATA(u8 data){
	/* Set RS to HIGH */
	SET_BIT(LCD_CONTROL_PORT, RS_PIN);
      ec:	90 9a       	sbi	0x12, 0	; 18
	/* Set R/W to LOW */
	CLR_BIT(LCD_CONTROL_PORT, RW_PIN);
      ee:	91 98       	cbi	0x12, 1	; 18
	/* Set E to HIGH */
	SET_BIT(LCD_CONTROL_PORT, E_PIN);
      f0:	92 9a       	sbi	0x12, 2	; 18

	/*set data*/
	LCD_DATA_PORT = data;
      f2:	8b bb       	out	0x1b, r24	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
      f4:	82 ee       	ldi	r24, 0xE2	; 226
      f6:	94 e0       	ldi	r25, 0x04	; 4
      f8:	01 97       	sbiw	r24, 0x01	; 1
      fa:	f1 f7       	brne	.-4      	; 0xf8 <LCD_WRITE_DATA+0xc>
	_delay_ms(5);

	/* Set E to LOW */
	CLR_BIT(LCD_CONTROL_PORT, E_PIN);
      fc:	92 98       	cbi	0x12, 2	; 18
      fe:	84 ec       	ldi	r24, 0xC4	; 196
     100:	99 e0       	ldi	r25, 0x09	; 9
     102:	01 97       	sbiw	r24, 0x01	; 1
     104:	f1 f7       	brne	.-4      	; 0x102 <LCD_WRITE_DATA+0x16>
	_delay_ms(10);
}
     106:	08 95       	ret

00000108 <LCD_WRITE_CMD>:
void LCD_WRITE_CMD(u8 command){
	/* Set RS to HIGH */
	CLR_BIT(LCD_CONTROL_PORT, RS_PIN);
     108:	90 98       	cbi	0x12, 0	; 18
	/* Set R/W to LOW */
	CLR_BIT(LCD_CONTROL_PORT, RW_PIN);
     10a:	91 98       	cbi	0x12, 1	; 18
	/* Set E to HIGH */
	SET_BIT(LCD_CONTROL_PORT, E_PIN);
     10c:	92 9a       	sbi	0x12, 2	; 18
	/*set data*/
	LCD_DATA_PORT= command;
     10e:	8b bb       	out	0x1b, r24	; 27
     110:	82 ee       	ldi	r24, 0xE2	; 226
     112:	94 e0       	ldi	r25, 0x04	; 4
     114:	01 97       	sbiw	r24, 0x01	; 1
     116:	f1 f7       	brne	.-4      	; 0x114 <LCD_WRITE_CMD+0xc>
	_delay_ms(5);
	/* Set E to LOW */
	CLR_BIT(LCD_CONTROL_PORT, E_PIN);
     118:	92 98       	cbi	0x12, 2	; 18
     11a:	84 ec       	ldi	r24, 0xC4	; 196
     11c:	99 e0       	ldi	r25, 0x09	; 9
     11e:	01 97       	sbiw	r24, 0x01	; 1
     120:	f1 f7       	brne	.-4      	; 0x11e <LCD_WRITE_CMD+0x16>
	/* Delay for 10ms to do command*/
	_delay_ms(10);
}
     122:	08 95       	ret

00000124 <LCD_INIT>:
#include<avr/delay.h>
#include "../../LIB/STD_TYPES.h"
#include "../../LIB/BIT_MATH.h"


void LCD_INIT(void){
     124:	0f 93       	push	r16
     126:	1f 93       	push	r17
	 LCD_DATA_PORT_DDR = 0xFF;
     128:	8f ef       	ldi	r24, 0xFF	; 255
     12a:	8a bb       	out	0x1a, r24	; 26
//	 SET_PORT_TYPE(LCD_DATA_PORT_DDR, OUTPUT);
	 SET_BIT(LCD_CONTROL_PORT_DDR, RS_PIN);
     12c:	88 9a       	sbi	0x11, 0	; 17
	 SET_BIT(LCD_CONTROL_PORT_DDR, RW_PIN);
     12e:	89 9a       	sbi	0x11, 1	; 17
	 SET_BIT(LCD_CONTROL_PORT_DDR, E_PIN);
     130:	8a 9a       	sbi	0x11, 2	; 17
     132:	8c e4       	ldi	r24, 0x4C	; 76
     134:	9d e1       	ldi	r25, 0x1D	; 29
     136:	01 97       	sbiw	r24, 0x01	; 1
     138:	f1 f7       	brne	.-4      	; 0x136 <LCD_INIT+0x12>

	 _delay_ms(30);
	 LCD_WRITE_CMD(LCD_SET);
     13a:	88 e3       	ldi	r24, 0x38	; 56
     13c:	90 e0       	ldi	r25, 0x00	; 0
     13e:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
     142:	0a ef       	ldi	r16, 0xFA	; 250
     144:	10 e0       	ldi	r17, 0x00	; 0
     146:	c8 01       	movw	r24, r16
     148:	01 97       	sbiw	r24, 0x01	; 1
     14a:	f1 f7       	brne	.-4      	; 0x148 <LCD_INIT+0x24>
	 _delay_ms(1);
	 LCD_WRITE_CMD(DISPLAY_ON_CONTROL);
     14c:	8c e0       	ldi	r24, 0x0C	; 12
     14e:	90 e0       	ldi	r25, 0x00	; 0
     150:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
     154:	c8 01       	movw	r24, r16
     156:	01 97       	sbiw	r24, 0x01	; 1
     158:	f1 f7       	brne	.-4      	; 0x156 <LCD_INIT+0x32>
	 _delay_ms(1);
	 LCD_WRITE_CMD(CLEAR_DISPLAY);
     15a:	81 e0       	ldi	r24, 0x01	; 1
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
     162:	84 ef       	ldi	r24, 0xF4	; 244
     164:	91 e0       	ldi	r25, 0x01	; 1
     166:	01 97       	sbiw	r24, 0x01	; 1
     168:	f1 f7       	brne	.-4      	; 0x166 <LCD_INIT+0x42>
	 _delay_ms(2);
	 LCD_WRITE_CMD(ENTRY_MODE_SET);
     16a:	86 e0       	ldi	r24, 0x06	; 6
     16c:	90 e0       	ldi	r25, 0x00	; 0
     16e:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
}
     172:	1f 91       	pop	r17
     174:	0f 91       	pop	r16
     176:	08 95       	ret

00000178 <LCD_SET_CURSOR_POSITION>:
	/* Set E to LOW */
	CLR_BIT(LCD_CONTROL_PORT, E_PIN);
	/* Delay for 10ms to do command*/
	_delay_ms(10);
}
void LCD_SET_CURSOR_POSITION(u8 row, u8 col){
     178:	98 2f       	mov	r25, r24

	u8 command=127;
	if(col>=1&&col<=16){
     17a:	86 2f       	mov	r24, r22
     17c:	81 50       	subi	r24, 0x01	; 1
     17e:	80 31       	cpi	r24, 0x10	; 16
     180:	68 f4       	brcc	.+26     	; 0x19c <LCD_SET_CURSOR_POSITION+0x24>
		switch(row){
     182:	91 30       	cpi	r25, 0x01	; 1
     184:	21 f0       	breq	.+8      	; 0x18e <LCD_SET_CURSOR_POSITION+0x16>
     186:	92 30       	cpi	r25, 0x02	; 2
     188:	29 f0       	breq	.+10     	; 0x194 <LCD_SET_CURSOR_POSITION+0x1c>
     18a:	8f e7       	ldi	r24, 0x7F	; 127
     18c:	05 c0       	rjmp	.+10     	; 0x198 <LCD_SET_CURSOR_POSITION+0x20>
		case 1:
			command+=col;
     18e:	86 2f       	mov	r24, r22
     190:	81 58       	subi	r24, 0x81	; 129
     192:	02 c0       	rjmp	.+4      	; 0x198 <LCD_SET_CURSOR_POSITION+0x20>
			break;
		case 2:
			command+=col+64;
     194:	86 2f       	mov	r24, r22
     196:	81 54       	subi	r24, 0x41	; 65
			break;
		default:break;
		}
		LCD_WRITE_CMD(command);
     198:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
     19c:	08 95       	ret

0000019e <LCD_WRITE_STRING>:
	} else{

	}
}
void LCD_WRITE_STRING(u8* string){
     19e:	ef 92       	push	r14
     1a0:	ff 92       	push	r15
     1a2:	1f 93       	push	r17
     1a4:	cf 93       	push	r28
     1a6:	df 93       	push	r29
     1a8:	ec 01       	movw	r28, r24
     1aa:	10 e0       	ldi	r17, 0x00	; 0
     1ac:	84 ef       	ldi	r24, 0xF4	; 244
     1ae:	e8 2e       	mov	r14, r24
     1b0:	81 e0       	ldi	r24, 0x01	; 1
     1b2:	f8 2e       	mov	r15, r24
     1b4:	06 c0       	rjmp	.+12     	; 0x1c2 <LCD_WRITE_STRING+0x24>
	 u8 counter=0;
	 for(counter=0;string[counter]!='\0';counter++){
		 LCD_WRITE_DATA(string[counter]);
     1b6:	0e 94 76 00 	call	0xec	; 0xec <LCD_WRITE_DATA>
     1ba:	c7 01       	movw	r24, r14
     1bc:	01 97       	sbiw	r24, 0x01	; 1
     1be:	f1 f7       	brne	.-4      	; 0x1bc <LCD_WRITE_STRING+0x1e>

	}
}
void LCD_WRITE_STRING(u8* string){
	 u8 counter=0;
	 for(counter=0;string[counter]!='\0';counter++){
     1c0:	1f 5f       	subi	r17, 0xFF	; 255
     1c2:	fe 01       	movw	r30, r28
     1c4:	e1 0f       	add	r30, r17
     1c6:	f1 1d       	adc	r31, r1
     1c8:	80 81       	ld	r24, Z
     1ca:	88 23       	and	r24, r24
     1cc:	a1 f7       	brne	.-24     	; 0x1b6 <LCD_WRITE_STRING+0x18>
		 LCD_WRITE_DATA(string[counter]);
		 _delay_ms(2);
	 }
}
     1ce:	df 91       	pop	r29
     1d0:	cf 91       	pop	r28
     1d2:	1f 91       	pop	r17
     1d4:	ff 90       	pop	r15
     1d6:	ef 90       	pop	r14
     1d8:	08 95       	ret

000001da <LCD_SAVE_CUSTOM_CHAR>:
void LCD_SAVE_CUSTOM_CHAR(u8 data[], u8 location){
     1da:	ef 92       	push	r14
     1dc:	ff 92       	push	r15
     1de:	0f 93       	push	r16
     1e0:	1f 93       	push	r17
     1e2:	cf 93       	push	r28
     1e4:	df 93       	push	r29
     1e6:	7c 01       	movw	r14, r24
	 u8 address=0;
	 u8 counter;
	 if(location >= 1 && location <= 8){
     1e8:	86 2f       	mov	r24, r22
     1ea:	81 50       	subi	r24, 0x01	; 1
     1ec:	88 30       	cpi	r24, 0x08	; 8
     1ee:	e8 f4       	brcc	.+58     	; 0x22a <LCD_SAVE_CUSTOM_CHAR+0x50>
		 address=(location - 1) * 8;
     1f0:	66 0f       	add	r22, r22
     1f2:	66 0f       	add	r22, r22
     1f4:	66 0f       	add	r22, r22
     1f6:	68 50       	subi	r22, 0x08	; 8
		 SET_BIT(address, 6);
		 LCD_WRITE_CMD(address);
     1f8:	86 2f       	mov	r24, r22
     1fa:	80 64       	ori	r24, 0x40	; 64
     1fc:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
     200:	c0 e0       	ldi	r28, 0x00	; 0
     202:	d0 e0       	ldi	r29, 0x00	; 0
     204:	04 ef       	ldi	r16, 0xF4	; 244
     206:	11 e0       	ldi	r17, 0x01	; 1
		 for(counter=0;counter<8;counter++){
			 LCD_WRITE_DATA(data[counter]);
     208:	f7 01       	movw	r30, r14
     20a:	ec 0f       	add	r30, r28
     20c:	fd 1f       	adc	r31, r29
     20e:	80 81       	ld	r24, Z
     210:	0e 94 76 00 	call	0xec	; 0xec <LCD_WRITE_DATA>
     214:	c8 01       	movw	r24, r16
     216:	01 97       	sbiw	r24, 0x01	; 1
     218:	f1 f7       	brne	.-4      	; 0x216 <LCD_SAVE_CUSTOM_CHAR+0x3c>
     21a:	21 96       	adiw	r28, 0x01	; 1
	 u8 counter;
	 if(location >= 1 && location <= 8){
		 address=(location - 1) * 8;
		 SET_BIT(address, 6);
		 LCD_WRITE_CMD(address);
		 for(counter=0;counter<8;counter++){
     21c:	c8 30       	cpi	r28, 0x08	; 8
     21e:	d1 05       	cpc	r29, r1
     220:	99 f7       	brne	.-26     	; 0x208 <LCD_SAVE_CUSTOM_CHAR+0x2e>
			 LCD_WRITE_DATA(data[counter]);
			 _delay_ms(2);
		 }
		 LCD_SET_CURSOR_POSITION(1, 1);
     222:	81 e0       	ldi	r24, 0x01	; 1
     224:	61 e0       	ldi	r22, 0x01	; 1
     226:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SET_CURSOR_POSITION>
	 }

 }
     22a:	df 91       	pop	r29
     22c:	cf 91       	pop	r28
     22e:	1f 91       	pop	r17
     230:	0f 91       	pop	r16
     232:	ff 90       	pop	r15
     234:	ef 90       	pop	r14
     236:	08 95       	ret

00000238 <LCD_SET_CURSOR_POSITION_WITH_OFFSET>:
 void LCD_SET_CURSOR_POSITION_WITH_OFFSET(u8 row, u8 col, u8 offset) {
     u8 command = 127;

     // Calculate the cursor position based on the starting position and offset
     u8 position = (row == 1) ? col : (col + 64);
     238:	81 30       	cpi	r24, 0x01	; 1
     23a:	09 f0       	breq	.+2      	; 0x23e <LCD_SET_CURSOR_POSITION_WITH_OFFSET+0x6>
     23c:	60 5c       	subi	r22, 0xC0	; 192

     // Adjust the position based on the offset
     if (offset > 0) {
     23e:	41 11       	cpse	r20, r1
         position += offset;
     240:	64 0f       	add	r22, r20
     }

     if (position >= 1 && position <= 16) {
     242:	86 2f       	mov	r24, r22
     244:	81 50       	subi	r24, 0x01	; 1
     246:	80 31       	cpi	r24, 0x10	; 16
     248:	18 f4       	brcc	.+6      	; 0x250 <LCD_SET_CURSOR_POSITION_WITH_OFFSET+0x18>
         command += position;
         LCD_WRITE_CMD(command);
     24a:	80 58       	subi	r24, 0x80	; 128
     24c:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
     250:	08 95       	ret

00000252 <LCD_CLR_RANGE>:
     } else {

     }
}

void LCD_CLR_RANGE(u8 row, u8 from, u8 to) {
     252:	cf 92       	push	r12
     254:	df 92       	push	r13
     256:	ef 92       	push	r14
     258:	ff 92       	push	r15
     25a:	0f 93       	push	r16
     25c:	1f 93       	push	r17
     25e:	cf 93       	push	r28
     260:	df 93       	push	r29
     262:	c8 2e       	mov	r12, r24
     264:	d6 2e       	mov	r13, r22
     266:	c0 e0       	ldi	r28, 0x00	; 0
     268:	d0 e0       	ldi	r29, 0x00	; 0
	for(int i = from; i < to; i++)
     26a:	e6 2e       	mov	r14, r22
     26c:	ff 24       	eor	r15, r15
     26e:	04 2f       	mov	r16, r20
     270:	10 e0       	ldi	r17, 0x00	; 0
     272:	06 c0       	rjmp	.+12     	; 0x280 <LCD_CLR_RANGE+0x2e>
		LCD_SET_CURSOR_POSITION(row, i);
     274:	6d 2d       	mov	r22, r13
     276:	6c 0f       	add	r22, r28
     278:	8c 2d       	mov	r24, r12
     27a:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SET_CURSOR_POSITION>
     27e:	21 96       	adiw	r28, 0x01	; 1

     }
}

void LCD_CLR_RANGE(u8 row, u8 from, u8 to) {
	for(int i = from; i < to; i++)
     280:	ce 01       	movw	r24, r28
     282:	8e 0d       	add	r24, r14
     284:	9f 1d       	adc	r25, r15
     286:	80 17       	cp	r24, r16
     288:	91 07       	cpc	r25, r17
     28a:	a4 f3       	brlt	.-24     	; 0x274 <LCD_CLR_RANGE+0x22>
		LCD_SET_CURSOR_POSITION(row, i);
}
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	1f 91       	pop	r17
     292:	0f 91       	pop	r16
     294:	ff 90       	pop	r15
     296:	ef 90       	pop	r14
     298:	df 90       	pop	r13
     29a:	cf 90       	pop	r12
     29c:	08 95       	ret

0000029e <LCD_WRITE_CENTER_STRING>:


void LCD_WRITE_CENTER_STRING(u8 * string, u8 row) {
     29e:	ff 92       	push	r15
     2a0:	0f 93       	push	r16
     2a2:	1f 93       	push	r17
     2a4:	08 2f       	mov	r16, r24
     2a6:	f9 2e       	mov	r15, r25
     2a8:	16 2f       	mov	r17, r22
	// clear the row
	LCD_CLR_RANGE(row, 0, 16);
     2aa:	86 2f       	mov	r24, r22
     2ac:	60 e0       	ldi	r22, 0x00	; 0
     2ae:	40 e1       	ldi	r20, 0x10	; 16
     2b0:	0e 94 29 01 	call	0x252	; 0x252 <LCD_CLR_RANGE>
     2b4:	82 ee       	ldi	r24, 0xE2	; 226
     2b6:	94 e0       	ldi	r25, 0x04	; 4
     2b8:	01 97       	sbiw	r24, 0x01	; 1
     2ba:	f1 f7       	brne	.-4      	; 0x2b8 <LCD_WRITE_CENTER_STRING+0x1a>
	_delay_ms(5);

	u8 start = (16 - strlen(string)) / 2 + 1;   // Calculate starting position for "string"
     2bc:	e0 2f       	mov	r30, r16
     2be:	ff 2d       	mov	r31, r15
     2c0:	df 01       	movw	r26, r30
     2c2:	0d 90       	ld	r0, X+
     2c4:	00 20       	and	r0, r0
     2c6:	e9 f7       	brne	.-6      	; 0x2c2 <LCD_WRITE_CENTER_STRING+0x24>

	// Display "string" at the center of the specified row
	LCD_SET_CURSOR_POSITION(row, start);
     2c8:	ea 1b       	sub	r30, r26
     2ca:	fb 0b       	sbc	r31, r27
     2cc:	71 96       	adiw	r30, 0x11	; 17
     2ce:	f6 95       	lsr	r31
     2d0:	e7 95       	ror	r30
     2d2:	ef 5f       	subi	r30, 0xFF	; 255
     2d4:	81 2f       	mov	r24, r17
     2d6:	6e 2f       	mov	r22, r30
     2d8:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SET_CURSOR_POSITION>
	LCD_WRITE_STRING(string);
     2dc:	80 2f       	mov	r24, r16
     2de:	9f 2d       	mov	r25, r15
     2e0:	0e 94 cf 00 	call	0x19e	; 0x19e <LCD_WRITE_STRING>
}
     2e4:	1f 91       	pop	r17
     2e6:	0f 91       	pop	r16
     2e8:	ff 90       	pop	r15
     2ea:	08 95       	ret

000002ec <KEYPAD_INIT>:

static u8 ROWS[4] = {ROW_PIN0, ROW_PIN1, ROW_PIN2, ROW_PIN3};
static u8 COLS[4] = {COL_PIN0, COL_PIN1, COL_PIN2, COL_PIN3};


void KEYPAD_INIT(void) {
     2ec:	40 e0       	ldi	r20, 0x00	; 0
     2ee:	50 e0       	ldi	r21, 0x00	; 0
	u8 counter = 0;
	for(counter = 0; counter < 4; counter++){
	//Set ROWS as O/P
		SET_BIT(KEY_PORT_DDR, ROWS[counter]);
     2f0:	61 e0       	ldi	r22, 0x01	; 1
     2f2:	70 e0       	ldi	r23, 0x00	; 0
     2f4:	24 b3       	in	r18, 0x14	; 20
     2f6:	fa 01       	movw	r30, r20
     2f8:	e4 58       	subi	r30, 0x84	; 132
     2fa:	fe 4f       	sbci	r31, 0xFE	; 254
     2fc:	cb 01       	movw	r24, r22
     2fe:	00 80       	ld	r0, Z
     300:	02 c0       	rjmp	.+4      	; 0x306 <KEYPAD_INIT+0x1a>
     302:	88 0f       	add	r24, r24
     304:	99 1f       	adc	r25, r25
     306:	0a 94       	dec	r0
     308:	e2 f7       	brpl	.-8      	; 0x302 <KEYPAD_INIT+0x16>
     30a:	28 2b       	or	r18, r24
     30c:	24 bb       	out	0x14, r18	; 20
	//Set CLOMS as I/P
		CLR_BIT(KEY_PORT_DDR, COLS[counter]);
     30e:	24 b3       	in	r18, 0x14	; 20
     310:	fa 01       	movw	r30, r20
     312:	e0 58       	subi	r30, 0x80	; 128
     314:	fe 4f       	sbci	r31, 0xFE	; 254
     316:	cb 01       	movw	r24, r22
     318:	00 80       	ld	r0, Z
     31a:	02 c0       	rjmp	.+4      	; 0x320 <KEYPAD_INIT+0x34>
     31c:	88 0f       	add	r24, r24
     31e:	99 1f       	adc	r25, r25
     320:	0a 94       	dec	r0
     322:	e2 f7       	brpl	.-8      	; 0x31c <KEYPAD_INIT+0x30>
     324:	80 95       	com	r24
     326:	82 23       	and	r24, r18
     328:	84 bb       	out	0x14, r24	; 20
     32a:	4f 5f       	subi	r20, 0xFF	; 255
     32c:	5f 4f       	sbci	r21, 0xFF	; 255
static u8 COLS[4] = {COL_PIN0, COL_PIN1, COL_PIN2, COL_PIN3};


void KEYPAD_INIT(void) {
	u8 counter = 0;
	for(counter = 0; counter < 4; counter++){
     32e:	44 30       	cpi	r20, 0x04	; 4
     330:	51 05       	cpc	r21, r1
     332:	01 f7       	brne	.-64     	; 0x2f4 <KEYPAD_INIT+0x8>
		SET_BIT(KEY_PORT_DDR, ROWS[counter]);
	//Set CLOMS as I/P
		CLR_BIT(KEY_PORT_DDR, COLS[counter]);
	}

	KEY_PORT=0xFF;
     334:	8f ef       	ldi	r24, 0xFF	; 255
     336:	85 bb       	out	0x15, r24	; 21
}
     338:	08 95       	ret

0000033a <KEYPAD_INPUT>:
u8 KEYPAD_INPUT(void) {
     33a:	cf 93       	push	r28
     33c:	df 93       	push	r29
     33e:	a0 e0       	ldi	r26, 0x00	; 0
     340:	b0 e0       	ldi	r27, 0x00	; 0
	u8 inner_counter=0;
	u8 outer_counter=0;
		for(outer_counter=0;outer_counter<4;outer_counter++){
			CLR_BIT(KEY_PORT,ROWS[outer_counter]);
     342:	c1 e0       	ldi	r28, 0x01	; 1
     344:	d0 e0       	ldi	r29, 0x00	; 0
     346:	25 b3       	in	r18, 0x15	; 21
     348:	fd 01       	movw	r30, r26
     34a:	e4 58       	subi	r30, 0x84	; 132
     34c:	fe 4f       	sbci	r31, 0xFE	; 254
     34e:	ce 01       	movw	r24, r28
     350:	00 80       	ld	r0, Z
     352:	02 c0       	rjmp	.+4      	; 0x358 <KEYPAD_INPUT+0x1e>
     354:	88 0f       	add	r24, r24
     356:	99 1f       	adc	r25, r25
     358:	0a 94       	dec	r0
     35a:	e2 f7       	brpl	.-8      	; 0x354 <KEYPAD_INPUT+0x1a>
     35c:	68 2f       	mov	r22, r24
     35e:	80 95       	com	r24
     360:	82 23       	and	r24, r18
     362:	85 bb       	out	0x15, r24	; 21
     364:	40 e0       	ldi	r20, 0x00	; 0
     366:	50 e0       	ldi	r21, 0x00	; 0
			for(inner_counter=0;inner_counter<4;inner_counter++){
				if(GET_BIT(KEY_PORT_PIN, COLS[inner_counter])==0){
     368:	83 b3       	in	r24, 0x13	; 19
     36a:	fa 01       	movw	r30, r20
     36c:	e0 58       	subi	r30, 0x80	; 128
     36e:	fe 4f       	sbci	r31, 0xFE	; 254
     370:	e0 81       	ld	r30, Z
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	0e 2e       	mov	r0, r30
     376:	02 c0       	rjmp	.+4      	; 0x37c <KEYPAD_INPUT+0x42>
     378:	95 95       	asr	r25
     37a:	87 95       	ror	r24
     37c:	0a 94       	dec	r0
     37e:	e2 f7       	brpl	.-8      	; 0x378 <KEYPAD_INPUT+0x3e>
     380:	80 fd       	sbrc	r24, 0
     382:	1a c0       	rjmp	.+52     	; 0x3b8 <KEYPAD_INPUT+0x7e>
     384:	21 e0       	ldi	r18, 0x01	; 1
     386:	30 e0       	ldi	r19, 0x00	; 0
     388:	02 c0       	rjmp	.+4      	; 0x38e <KEYPAD_INPUT+0x54>
     38a:	22 0f       	add	r18, r18
     38c:	33 1f       	adc	r19, r19
     38e:	ea 95       	dec	r30
     390:	e2 f7       	brpl	.-8      	; 0x38a <KEYPAD_INPUT+0x50>
					while(GET_BIT(KEY_PORT_PIN, COLS[inner_counter])==0);
     392:	83 b3       	in	r24, 0x13	; 19
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	82 23       	and	r24, r18
     398:	93 23       	and	r25, r19
     39a:	89 2b       	or	r24, r25
     39c:	d1 f3       	breq	.-12     	; 0x392 <KEYPAD_INPUT+0x58>
					SET_BIT(KEY_PORT, ROWS[outer_counter]);
     39e:	85 b3       	in	r24, 0x15	; 21
     3a0:	68 2b       	or	r22, r24
     3a2:	65 bb       	out	0x15, r22	; 21
					return BUTTONS[outer_counter][inner_counter] ;
     3a4:	aa 0f       	add	r26, r26
     3a6:	bb 1f       	adc	r27, r27
     3a8:	aa 0f       	add	r26, r26
     3aa:	bb 1f       	adc	r27, r27
     3ac:	a4 0f       	add	r26, r20
     3ae:	b5 1f       	adc	r27, r21
     3b0:	a4 59       	subi	r26, 0x94	; 148
     3b2:	be 4f       	sbci	r27, 0xFE	; 254
     3b4:	8c 91       	ld	r24, X
     3b6:	0e c0       	rjmp	.+28     	; 0x3d4 <KEYPAD_INPUT+0x9a>
     3b8:	4f 5f       	subi	r20, 0xFF	; 255
     3ba:	5f 4f       	sbci	r21, 0xFF	; 255
u8 KEYPAD_INPUT(void) {
	u8 inner_counter=0;
	u8 outer_counter=0;
		for(outer_counter=0;outer_counter<4;outer_counter++){
			CLR_BIT(KEY_PORT,ROWS[outer_counter]);
			for(inner_counter=0;inner_counter<4;inner_counter++){
     3bc:	44 30       	cpi	r20, 0x04	; 4
     3be:	51 05       	cpc	r21, r1
     3c0:	99 f6       	brne	.-90     	; 0x368 <KEYPAD_INPUT+0x2e>
					while(GET_BIT(KEY_PORT_PIN, COLS[inner_counter])==0);
					SET_BIT(KEY_PORT, ROWS[outer_counter]);
					return BUTTONS[outer_counter][inner_counter] ;
				}
			}
			SET_BIT(KEY_PORT, ROWS[outer_counter]);
     3c2:	85 b3       	in	r24, 0x15	; 21
     3c4:	68 2b       	or	r22, r24
     3c6:	65 bb       	out	0x15, r22	; 21
     3c8:	11 96       	adiw	r26, 0x01	; 1
	KEY_PORT=0xFF;
}
u8 KEYPAD_INPUT(void) {
	u8 inner_counter=0;
	u8 outer_counter=0;
		for(outer_counter=0;outer_counter<4;outer_counter++){
     3ca:	a4 30       	cpi	r26, 0x04	; 4
     3cc:	b1 05       	cpc	r27, r1
     3ce:	09 f0       	breq	.+2      	; 0x3d2 <KEYPAD_INPUT+0x98>
     3d0:	ba cf       	rjmp	.-140    	; 0x346 <KEYPAD_INPUT+0xc>
     3d2:	80 e0       	ldi	r24, 0x00	; 0
			}
			SET_BIT(KEY_PORT, ROWS[outer_counter]);

		}
		return '\0';
}
     3d4:	df 91       	pop	r29
     3d6:	cf 91       	pop	r28
     3d8:	08 95       	ret

000003da <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    return xFreeBytesRemaining;
}
     3da:	80 91 86 01 	lds	r24, 0x0186
     3de:	90 91 87 01 	lds	r25, 0x0187
     3e2:	08 95       	ret

000003e4 <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
    return xMinimumEverFreeBytesRemaining;
}
     3e4:	80 91 8c 01 	lds	r24, 0x018C
     3e8:	90 91 8d 01 	lds	r25, 0x018D
     3ec:	08 95       	ret

000003ee <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    /* This just exists to keep the linker quiet. */
}
     3ee:	08 95       	ret

000003f0 <prvInsertBlockIntoFreeList>:
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
     3f0:	cf 93       	push	r28
     3f2:	df 93       	push	r29
     3f4:	fc 01       	movw	r30, r24
     3f6:	c6 ee       	ldi	r28, 0xE6	; 230
     3f8:	d3 e0       	ldi	r29, 0x03	; 3
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     3fa:	88 81       	ld	r24, Y
     3fc:	99 81       	ldd	r25, Y+1	; 0x01
     3fe:	8e 17       	cp	r24, r30
     400:	9f 07       	cpc	r25, r31
     402:	10 f4       	brcc	.+4      	; 0x408 <prvInsertBlockIntoFreeList+0x18>
     404:	ec 01       	movw	r28, r24
     406:	f9 cf       	rjmp	.-14     	; 0x3fa <prvInsertBlockIntoFreeList+0xa>

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     408:	2a 81       	ldd	r18, Y+2	; 0x02
     40a:	3b 81       	ldd	r19, Y+3	; 0x03
     40c:	ce 01       	movw	r24, r28
     40e:	82 0f       	add	r24, r18
     410:	93 1f       	adc	r25, r19
     412:	e8 17       	cp	r30, r24
     414:	f9 07       	cpc	r31, r25
     416:	39 f4       	brne	.+14     	; 0x426 <prvInsertBlockIntoFreeList+0x36>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     418:	82 81       	ldd	r24, Z+2	; 0x02
     41a:	93 81       	ldd	r25, Z+3	; 0x03
     41c:	82 0f       	add	r24, r18
     41e:	93 1f       	adc	r25, r19
     420:	9b 83       	std	Y+3, r25	; 0x03
     422:	8a 83       	std	Y+2, r24	; 0x02
     424:	fe 01       	movw	r30, r28

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     426:	22 81       	ldd	r18, Z+2	; 0x02
     428:	33 81       	ldd	r19, Z+3	; 0x03
     42a:	a8 81       	ld	r26, Y
     42c:	b9 81       	ldd	r27, Y+1	; 0x01
     42e:	cf 01       	movw	r24, r30
     430:	82 0f       	add	r24, r18
     432:	93 1f       	adc	r25, r19
     434:	a8 17       	cp	r26, r24
     436:	b9 07       	cpc	r27, r25
     438:	a1 f4       	brne	.+40     	; 0x462 <prvInsertBlockIntoFreeList+0x72>
    {
        if( pxIterator->pxNextFreeBlock != pxEnd )
     43a:	80 91 84 01 	lds	r24, 0x0184
     43e:	90 91 85 01 	lds	r25, 0x0185
     442:	a8 17       	cp	r26, r24
     444:	b9 07       	cpc	r27, r25
     446:	69 f0       	breq	.+26     	; 0x462 <prvInsertBlockIntoFreeList+0x72>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     448:	12 96       	adiw	r26, 0x02	; 2
     44a:	8d 91       	ld	r24, X+
     44c:	9c 91       	ld	r25, X
     44e:	13 97       	sbiw	r26, 0x03	; 3
     450:	82 0f       	add	r24, r18
     452:	93 1f       	adc	r25, r19
     454:	93 83       	std	Z+3, r25	; 0x03
     456:	82 83       	std	Z+2, r24	; 0x02
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     458:	8d 91       	ld	r24, X+
     45a:	9c 91       	ld	r25, X
     45c:	91 83       	std	Z+1, r25	; 0x01
     45e:	80 83       	st	Z, r24
     460:	02 c0       	rjmp	.+4      	; 0x466 <prvInsertBlockIntoFreeList+0x76>
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     462:	b1 83       	std	Z+1, r27	; 0x01
     464:	a0 83       	st	Z, r26

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
     466:	ce 17       	cp	r28, r30
     468:	df 07       	cpc	r29, r31
     46a:	11 f0       	breq	.+4      	; 0x470 <prvInsertBlockIntoFreeList+0x80>
    {
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
     46c:	f9 83       	std	Y+1, r31	; 0x01
     46e:	e8 83       	st	Y, r30
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
     470:	df 91       	pop	r29
     472:	cf 91       	pop	r28
     474:	08 95       	ret

00000476 <vPortGetHeapStats>:
/*-----------------------------------------------------------*/

void vPortGetHeapStats( HeapStats_t * pxHeapStats )
{
     476:	cf 92       	push	r12
     478:	df 92       	push	r13
     47a:	ef 92       	push	r14
     47c:	ff 92       	push	r15
     47e:	0f 93       	push	r16
     480:	1f 93       	push	r17
     482:	cf 93       	push	r28
     484:	df 93       	push	r29
     486:	ec 01       	movw	r28, r24
    BlockLink_t * pxBlock;
    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */

    vTaskSuspendAll();
     488:	0e 94 28 0a 	call	0x1450	; 0x1450 <vTaskSuspendAll>
    {
        pxBlock = xStart.pxNextFreeBlock;
     48c:	e0 91 e6 03 	lds	r30, 0x03E6
     490:	f0 91 e7 03 	lds	r31, 0x03E7

        /* pxBlock will be NULL if the heap has not been initialised.  The heap
         * is initialised automatically when the first allocation is made. */
        if( pxBlock != NULL )
     494:	30 97       	sbiw	r30, 0x00	; 0
     496:	39 f4       	brne	.+14     	; 0x4a6 <vPortGetHeapStats+0x30>
     498:	cc 24       	eor	r12, r12
     49a:	dd 24       	eor	r13, r13
     49c:	ee 24       	eor	r14, r14
     49e:	ff 24       	eor	r15, r15
     4a0:	0f ef       	ldi	r16, 0xFF	; 255
     4a2:	1f ef       	ldi	r17, 0xFF	; 255
     4a4:	1e c0       	rjmp	.+60     	; 0x4e2 <vPortGetHeapStats+0x6c>
        {
            while( pxBlock != pxEnd )
     4a6:	20 91 84 01 	lds	r18, 0x0184
     4aa:	30 91 85 01 	lds	r19, 0x0185
     4ae:	cc 24       	eor	r12, r12
     4b0:	dd 24       	eor	r13, r13
     4b2:	ee 24       	eor	r14, r14
     4b4:	ff 24       	eor	r15, r15
     4b6:	0f ef       	ldi	r16, 0xFF	; 255
     4b8:	1f ef       	ldi	r17, 0xFF	; 255
     4ba:	10 c0       	rjmp	.+32     	; 0x4dc <vPortGetHeapStats+0x66>
            {
                /* Increment the number of blocks and record the largest block seen
                 * so far. */
                xBlocks++;
     4bc:	08 94       	sec
     4be:	c1 1c       	adc	r12, r1
     4c0:	d1 1c       	adc	r13, r1

                if( pxBlock->xBlockSize > xMaxSize )
     4c2:	82 81       	ldd	r24, Z+2	; 0x02
     4c4:	93 81       	ldd	r25, Z+3	; 0x03
     4c6:	e8 16       	cp	r14, r24
     4c8:	f9 06       	cpc	r15, r25
     4ca:	08 f4       	brcc	.+2      	; 0x4ce <vPortGetHeapStats+0x58>
     4cc:	7c 01       	movw	r14, r24
     4ce:	80 17       	cp	r24, r16
     4d0:	91 07       	cpc	r25, r17
     4d2:	08 f4       	brcc	.+2      	; 0x4d6 <vPortGetHeapStats+0x60>
     4d4:	8c 01       	movw	r16, r24
                    xMinSize = pxBlock->xBlockSize;
                }

                /* Move to the next block in the chain until the last block is
                 * reached. */
                pxBlock = pxBlock->pxNextFreeBlock;
     4d6:	01 90       	ld	r0, Z+
     4d8:	f0 81       	ld	r31, Z
     4da:	e0 2d       	mov	r30, r0

        /* pxBlock will be NULL if the heap has not been initialised.  The heap
         * is initialised automatically when the first allocation is made. */
        if( pxBlock != NULL )
        {
            while( pxBlock != pxEnd )
     4dc:	e2 17       	cp	r30, r18
     4de:	f3 07       	cpc	r31, r19
     4e0:	69 f7       	brne	.-38     	; 0x4bc <vPortGetHeapStats+0x46>
                 * reached. */
                pxBlock = pxBlock->pxNextFreeBlock;
            }
        }
    }
    ( void ) xTaskResumeAll();
     4e2:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>

    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
     4e6:	fb 82       	std	Y+3, r15	; 0x03
     4e8:	ea 82       	std	Y+2, r14	; 0x02
    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
     4ea:	1d 83       	std	Y+5, r17	; 0x05
     4ec:	0c 83       	std	Y+4, r16	; 0x04
    pxHeapStats->xNumberOfFreeBlocks = xBlocks;
     4ee:	df 82       	std	Y+7, r13	; 0x07
     4f0:	ce 82       	std	Y+6, r12	; 0x06

    taskENTER_CRITICAL();
     4f2:	0f b6       	in	r0, 0x3f	; 63
     4f4:	f8 94       	cli
     4f6:	0f 92       	push	r0
    {
        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
     4f8:	80 91 86 01 	lds	r24, 0x0186
     4fc:	90 91 87 01 	lds	r25, 0x0187
     500:	99 83       	std	Y+1, r25	; 0x01
     502:	88 83       	st	Y, r24
        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
     504:	80 91 88 01 	lds	r24, 0x0188
     508:	90 91 89 01 	lds	r25, 0x0189
     50c:	9b 87       	std	Y+11, r25	; 0x0b
     50e:	8a 87       	std	Y+10, r24	; 0x0a
        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
     510:	80 91 8a 01 	lds	r24, 0x018A
     514:	90 91 8b 01 	lds	r25, 0x018B
     518:	9d 87       	std	Y+13, r25	; 0x0d
     51a:	8c 87       	std	Y+12, r24	; 0x0c
        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
     51c:	80 91 8c 01 	lds	r24, 0x018C
     520:	90 91 8d 01 	lds	r25, 0x018D
     524:	99 87       	std	Y+9, r25	; 0x09
     526:	88 87       	std	Y+8, r24	; 0x08
    }
    taskEXIT_CRITICAL();
     528:	0f 90       	pop	r0
     52a:	0f be       	out	0x3f, r0	; 63
}
     52c:	df 91       	pop	r29
     52e:	cf 91       	pop	r28
     530:	1f 91       	pop	r17
     532:	0f 91       	pop	r16
     534:	ff 90       	pop	r15
     536:	ef 90       	pop	r14
     538:	df 90       	pop	r13
     53a:	cf 90       	pop	r12
     53c:	08 95       	ret

0000053e <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     53e:	cf 93       	push	r28
     540:	df 93       	push	r29
    uint8_t * puc = ( uint8_t * ) pv;
    BlockLink_t * pxLink;

    if( pv != NULL )
     542:	00 97       	sbiw	r24, 0x00	; 0
     544:	49 f1       	breq	.+82     	; 0x598 <vPortFree+0x5a>
        /* The memory being freed will have an BlockLink_t structure immediately
         * before it. */
        puc -= xHeapStructSize;

        /* This casting is to keep the compiler from issuing warnings. */
        pxLink = ( void * ) puc;
     546:	ec 01       	movw	r28, r24
     548:	24 97       	sbiw	r28, 0x04	; 4

        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
        configASSERT( pxLink->pxNextFreeBlock == NULL );

        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
     54a:	2a 81       	ldd	r18, Y+2	; 0x02
     54c:	3b 81       	ldd	r19, Y+3	; 0x03
     54e:	37 ff       	sbrs	r19, 7
     550:	23 c0       	rjmp	.+70     	; 0x598 <vPortFree+0x5a>
        {
            if( pxLink->pxNextFreeBlock == NULL )
     552:	88 81       	ld	r24, Y
     554:	99 81       	ldd	r25, Y+1	; 0x01
     556:	89 2b       	or	r24, r25
     558:	f9 f4       	brne	.+62     	; 0x598 <vPortFree+0x5a>
            {
                /* The block is being returned to the heap - it is no longer
                 * allocated. */
                heapFREE_BLOCK( pxLink );
     55a:	3f 77       	andi	r19, 0x7F	; 127
     55c:	3b 83       	std	Y+3, r19	; 0x03
     55e:	2a 83       	std	Y+2, r18	; 0x02
                {
                    ( void ) memset( puc + xHeapStructSize, 0, pxLink->xBlockSize - xHeapStructSize );
                }
                #endif

                vTaskSuspendAll();
     560:	0e 94 28 0a 	call	0x1450	; 0x1450 <vTaskSuspendAll>
                {
                    /* Add this block to the list of free blocks. */
                    xFreeBytesRemaining += pxLink->xBlockSize;
     564:	80 91 86 01 	lds	r24, 0x0186
     568:	90 91 87 01 	lds	r25, 0x0187
     56c:	2a 81       	ldd	r18, Y+2	; 0x02
     56e:	3b 81       	ldd	r19, Y+3	; 0x03
     570:	82 0f       	add	r24, r18
     572:	93 1f       	adc	r25, r19
     574:	90 93 87 01 	sts	0x0187, r25
     578:	80 93 86 01 	sts	0x0186, r24
                    traceFREE( pv, pxLink->xBlockSize );
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     57c:	ce 01       	movw	r24, r28
     57e:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
     582:	80 91 8a 01 	lds	r24, 0x018A
     586:	90 91 8b 01 	lds	r25, 0x018B
     58a:	01 96       	adiw	r24, 0x01	; 1
     58c:	90 93 8b 01 	sts	0x018B, r25
     590:	80 93 8a 01 	sts	0x018A, r24
                }
                ( void ) xTaskResumeAll();
     594:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
}
     598:	df 91       	pop	r29
     59a:	cf 91       	pop	r28
     59c:	08 95       	ret

0000059e <pvPortMalloc>:
PRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	0f 93       	push	r16
     5a8:	1f 93       	push	r17
     5aa:	cf 93       	push	r28
     5ac:	df 93       	push	r29
     5ae:	8c 01       	movw	r16, r24
    BlockLink_t * pxPreviousBlock;
    BlockLink_t * pxNewBlockLink;
    void * pvReturn = NULL;
    size_t xAdditionalRequiredSize;

    vTaskSuspendAll();
     5b0:	0e 94 28 0a 	call	0x1450	; 0x1450 <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
     5b4:	80 91 84 01 	lds	r24, 0x0184
     5b8:	90 91 85 01 	lds	r25, 0x0185
     5bc:	89 2b       	or	r24, r25
     5be:	51 f5       	brne	.+84     	; 0x614 <pvPortMalloc+0x76>

    pucAlignedHeap = ( uint8_t * ) uxAddress;

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     5c0:	8e e8       	ldi	r24, 0x8E	; 142
     5c2:	91 e0       	ldi	r25, 0x01	; 1
     5c4:	90 93 e7 03 	sts	0x03E7, r25
     5c8:	80 93 e6 03 	sts	0x03E6, r24
    xStart.xBlockSize = ( size_t ) 0;
     5cc:	10 92 e9 03 	sts	0x03E9, r1
     5d0:	10 92 e8 03 	sts	0x03E8, r1
    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxAddress = ( ( portPOINTER_SIZE_TYPE ) pucAlignedHeap ) + xTotalHeapSize;
    uxAddress -= xHeapStructSize;
    uxAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    pxEnd = ( BlockLink_t * ) uxAddress;
     5d4:	22 ee       	ldi	r18, 0xE2	; 226
     5d6:	33 e0       	ldi	r19, 0x03	; 3
     5d8:	30 93 85 01 	sts	0x0185, r19
     5dc:	20 93 84 01 	sts	0x0184, r18
    pxEnd->xBlockSize = 0;
     5e0:	10 92 e5 03 	sts	0x03E5, r1
     5e4:	10 92 e4 03 	sts	0x03E4, r1
    pxEnd->pxNextFreeBlock = NULL;
     5e8:	10 92 e3 03 	sts	0x03E3, r1
     5ec:	10 92 e2 03 	sts	0x03E2, r1

    /* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. */
    pxFirstFreeBlock = ( BlockLink_t * ) pucAlignedHeap;
    pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
     5f0:	84 e5       	ldi	r24, 0x54	; 84
     5f2:	92 e0       	ldi	r25, 0x02	; 2
     5f4:	90 93 91 01 	sts	0x0191, r25
     5f8:	80 93 90 01 	sts	0x0190, r24
    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     5fc:	30 93 8f 01 	sts	0x018F, r19
     600:	20 93 8e 01 	sts	0x018E, r18

    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     604:	90 93 8d 01 	sts	0x018D, r25
     608:	80 93 8c 01 	sts	0x018C, r24
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     60c:	90 93 87 01 	sts	0x0187, r25
     610:	80 93 86 01 	sts	0x0186, r24
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xWantedSize > 0 )
     614:	01 15       	cp	r16, r1
     616:	11 05       	cpc	r17, r1
     618:	39 f0       	breq	.+14     	; 0x628 <pvPortMalloc+0x8a>
            /* The wanted size must be increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. Some
             * additional increment may also be needed for alignment. */
            xAdditionalRequiredSize = xHeapStructSize + portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );

            if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
     61a:	8f ef       	ldi	r24, 0xFF	; 255
     61c:	0b 3f       	cpi	r16, 0xFB	; 251
     61e:	18 07       	cpc	r17, r24
     620:	08 f0       	brcs	.+2      	; 0x624 <pvPortMalloc+0x86>
     622:	67 c0       	rjmp	.+206    	; 0x6f2 <pvPortMalloc+0x154>
            {
                xWantedSize += xAdditionalRequiredSize;
     624:	0b 5f       	subi	r16, 0xFB	; 251
     626:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Check the block size we are trying to allocate is not so large that the
         * top bit is set.  The top bit of the block size member of the BlockLink_t
         * structure is used to determine who owns the block - the application or
         * the kernel, so it must be free. */
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
     628:	17 fd       	sbrc	r17, 7
     62a:	63 c0       	rjmp	.+198    	; 0x6f2 <pvPortMalloc+0x154>
        {
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     62c:	01 15       	cp	r16, r1
     62e:	11 05       	cpc	r17, r1
     630:	09 f4       	brne	.+2      	; 0x634 <pvPortMalloc+0x96>
     632:	5f c0       	rjmp	.+190    	; 0x6f2 <pvPortMalloc+0x154>
     634:	c0 90 86 01 	lds	r12, 0x0186
     638:	d0 90 87 01 	lds	r13, 0x0187
     63c:	c0 16       	cp	r12, r16
     63e:	d1 06       	cpc	r13, r17
     640:	08 f4       	brcc	.+2      	; 0x644 <pvPortMalloc+0xa6>
     642:	57 c0       	rjmp	.+174    	; 0x6f2 <pvPortMalloc+0x154>
            {
                /* Traverse the list from the start (lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;
     644:	c0 91 e6 03 	lds	r28, 0x03E6
     648:	d0 91 e7 03 	lds	r29, 0x03E7
     64c:	e6 ee       	ldi	r30, 0xE6	; 230
     64e:	f3 e0       	ldi	r31, 0x03	; 3

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     650:	8a 81       	ldd	r24, Y+2	; 0x02
     652:	9b 81       	ldd	r25, Y+3	; 0x03
     654:	80 17       	cp	r24, r16
     656:	91 07       	cpc	r25, r17
     658:	40 f4       	brcc	.+16     	; 0x66a <pvPortMalloc+0xcc>
     65a:	88 81       	ld	r24, Y
     65c:	99 81       	ldd	r25, Y+1	; 0x01
     65e:	9e 01       	movw	r18, r28
     660:	00 97       	sbiw	r24, 0x00	; 0
     662:	19 f0       	breq	.+6      	; 0x66a <pvPortMalloc+0xcc>
     664:	ec 01       	movw	r28, r24
     666:	f9 01       	movw	r30, r18
     668:	f3 cf       	rjmp	.-26     	; 0x650 <pvPortMalloc+0xb2>
                    pxBlock = pxBlock->pxNextFreeBlock;
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
     66a:	80 91 84 01 	lds	r24, 0x0184
     66e:	90 91 85 01 	lds	r25, 0x0185
     672:	c8 17       	cp	r28, r24
     674:	d9 07       	cpc	r29, r25
     676:	e9 f1       	breq	.+122    	; 0x6f2 <pvPortMalloc+0x154>
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     678:	e0 80       	ld	r14, Z
     67a:	f1 80       	ldd	r15, Z+1	; 0x01

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     67c:	88 81       	ld	r24, Y
     67e:	99 81       	ldd	r25, Y+1	; 0x01
     680:	91 83       	std	Z+1, r25	; 0x01
     682:	80 83       	st	Z, r24

                    /* If the block is larger than required it can be split into
                     * two. */
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     684:	8a 81       	ldd	r24, Y+2	; 0x02
     686:	9b 81       	ldd	r25, Y+3	; 0x03
     688:	80 1b       	sub	r24, r16
     68a:	91 0b       	sbc	r25, r17
     68c:	89 30       	cpi	r24, 0x09	; 9
     68e:	91 05       	cpc	r25, r1
     690:	50 f0       	brcs	.+20     	; 0x6a6 <pvPortMalloc+0x108>
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     692:	fe 01       	movw	r30, r28
     694:	e0 0f       	add	r30, r16
     696:	f1 1f       	adc	r31, r17
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     698:	93 83       	std	Z+3, r25	; 0x03
     69a:	82 83       	std	Z+2, r24	; 0x02
                        pxBlock->xBlockSize = xWantedSize;
     69c:	1b 83       	std	Y+3, r17	; 0x03
     69e:	0a 83       	std	Y+2, r16	; 0x02

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
     6a0:	cf 01       	movw	r24, r30
     6a2:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <prvInsertBlockIntoFreeList>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
     6a6:	4a 81       	ldd	r20, Y+2	; 0x02
     6a8:	5b 81       	ldd	r21, Y+3	; 0x03
     6aa:	96 01       	movw	r18, r12
     6ac:	24 1b       	sub	r18, r20
     6ae:	35 0b       	sbc	r19, r21
     6b0:	30 93 87 01 	sts	0x0187, r19
     6b4:	20 93 86 01 	sts	0x0186, r18

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     6b8:	80 91 8c 01 	lds	r24, 0x018C
     6bc:	90 91 8d 01 	lds	r25, 0x018D
     6c0:	28 17       	cp	r18, r24
     6c2:	39 07       	cpc	r19, r25
     6c4:	20 f4       	brcc	.+8      	; 0x6ce <pvPortMalloc+0x130>
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     6c6:	30 93 8d 01 	sts	0x018D, r19
     6ca:	20 93 8c 01 	sts	0x018C, r18
                 * was not found. */
                if( pxBlock != pxEnd )
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     6ce:	87 01       	movw	r16, r14
     6d0:	0c 5f       	subi	r16, 0xFC	; 252
     6d2:	1f 4f       	sbci	r17, 0xFF	; 255
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    heapALLOCATE_BLOCK( pxBlock );
     6d4:	50 68       	ori	r21, 0x80	; 128
     6d6:	5b 83       	std	Y+3, r21	; 0x03
     6d8:	4a 83       	std	Y+2, r20	; 0x02
                    pxBlock->pxNextFreeBlock = NULL;
     6da:	19 82       	std	Y+1, r1	; 0x01
     6dc:	18 82       	st	Y, r1
                    xNumberOfSuccessfulAllocations++;
     6de:	80 91 88 01 	lds	r24, 0x0188
     6e2:	90 91 89 01 	lds	r25, 0x0189
     6e6:	01 96       	adiw	r24, 0x01	; 1
     6e8:	90 93 89 01 	sts	0x0189, r25
     6ec:	80 93 88 01 	sts	0x0188, r24
     6f0:	02 c0       	rjmp	.+4      	; 0x6f6 <pvPortMalloc+0x158>
     6f2:	00 e0       	ldi	r16, 0x00	; 0
     6f4:	10 e0       	ldi	r17, 0x00	; 0
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     6f6:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
    }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    return pvReturn;
}
     6fa:	c8 01       	movw	r24, r16
     6fc:	df 91       	pop	r29
     6fe:	cf 91       	pop	r28
     700:	1f 91       	pop	r17
     702:	0f 91       	pop	r16
     704:	ff 90       	pop	r15
     706:	ef 90       	pop	r14
     708:	df 90       	pop	r13
     70a:	cf 90       	pop	r12
     70c:	08 95       	ret

0000070e <pvPortCalloc>:
}
/*-----------------------------------------------------------*/

void * pvPortCalloc( size_t xNum,
                     size_t xSize )
{
     70e:	0f 93       	push	r16
     710:	1f 93       	push	r17
     712:	cf 93       	push	r28
     714:	df 93       	push	r29
     716:	9c 01       	movw	r18, r24
     718:	fb 01       	movw	r30, r22
    void * pv = NULL;

    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
     71a:	00 97       	sbiw	r24, 0x00	; 0
     71c:	b9 f0       	breq	.+46     	; 0x74c <pvPortCalloc+0x3e>
     71e:	8f ef       	ldi	r24, 0xFF	; 255
     720:	9f ef       	ldi	r25, 0xFF	; 255
     722:	b9 01       	movw	r22, r18
     724:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <__udivmodhi4>
     728:	6e 17       	cp	r22, r30
     72a:	7f 07       	cpc	r23, r31
     72c:	78 f4       	brcc	.+30     	; 0x74c <pvPortCalloc+0x3e>
     72e:	c0 e0       	ldi	r28, 0x00	; 0
     730:	d0 e0       	ldi	r29, 0x00	; 0
     732:	06 c0       	rjmp	.+12     	; 0x740 <pvPortCalloc+0x32>
    {
        pv = pvPortMalloc( xNum * xSize );

        if( pv != NULL )
        {
            ( void ) memset( pv, 0, xNum * xSize );
     734:	ce 01       	movw	r24, r28
     736:	60 e0       	ldi	r22, 0x00	; 0
     738:	70 e0       	ldi	r23, 0x00	; 0
     73a:	a8 01       	movw	r20, r16
     73c:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <memset>
        }
    }

    return pv;
}
     740:	ce 01       	movw	r24, r28
     742:	df 91       	pop	r29
     744:	cf 91       	pop	r28
     746:	1f 91       	pop	r17
     748:	0f 91       	pop	r16
     74a:	08 95       	ret
{
    void * pv = NULL;

    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
    {
        pv = pvPortMalloc( xNum * xSize );
     74c:	e2 9f       	mul	r30, r18
     74e:	80 01       	movw	r16, r0
     750:	e3 9f       	mul	r30, r19
     752:	10 0d       	add	r17, r0
     754:	f2 9f       	mul	r31, r18
     756:	10 0d       	add	r17, r0
     758:	11 24       	eor	r1, r1
     75a:	c8 01       	movw	r24, r16
     75c:	0e 94 cf 02 	call	0x59e	; 0x59e <pvPortMalloc>
     760:	ec 01       	movw	r28, r24

        if( pv != NULL )
     762:	00 97       	sbiw	r24, 0x00	; 0
     764:	39 f7       	brne	.-50     	; 0x734 <pvPortCalloc+0x26>
     766:	ec cf       	rjmp	.-40     	; 0x740 <pvPortCalloc+0x32>

00000768 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     768:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     76a:	9c 01       	movw	r18, r24
     76c:	2d 5f       	subi	r18, 0xFD	; 253
     76e:	3f 4f       	sbci	r19, 0xFF	; 255
     770:	32 83       	std	Z+2, r19	; 0x02
     772:	21 83       	std	Z+1, r18	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     774:	8f ef       	ldi	r24, 0xFF	; 255
     776:	9f ef       	ldi	r25, 0xFF	; 255
     778:	94 83       	std	Z+4, r25	; 0x04
     77a:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     77c:	36 83       	std	Z+6, r19	; 0x06
     77e:	25 83       	std	Z+5, r18	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     780:	30 87       	std	Z+8, r19	; 0x08
     782:	27 83       	std	Z+7, r18	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     784:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     786:	08 95       	ret

00000788 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     788:	fc 01       	movw	r30, r24
     78a:	11 86       	std	Z+9, r1	; 0x09
     78c:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     78e:	08 95       	ret

00000790 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
     790:	ac 01       	movw	r20, r24
    ListItem_t * const pxIndex = pxList->pxIndex;
     792:	fc 01       	movw	r30, r24
     794:	a1 81       	ldd	r26, Z+1	; 0x01
     796:	b2 81       	ldd	r27, Z+2	; 0x02
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     798:	fb 01       	movw	r30, r22
     79a:	b3 83       	std	Z+3, r27	; 0x03
     79c:	a2 83       	std	Z+2, r26	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     79e:	14 96       	adiw	r26, 0x04	; 4
     7a0:	8d 91       	ld	r24, X+
     7a2:	9c 91       	ld	r25, X
     7a4:	15 97       	sbiw	r26, 0x05	; 5
     7a6:	95 83       	std	Z+5, r25	; 0x05
     7a8:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     7aa:	14 96       	adiw	r26, 0x04	; 4
     7ac:	ed 91       	ld	r30, X+
     7ae:	fc 91       	ld	r31, X
     7b0:	15 97       	sbiw	r26, 0x05	; 5
     7b2:	73 83       	std	Z+3, r23	; 0x03
     7b4:	62 83       	std	Z+2, r22	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
     7b6:	15 96       	adiw	r26, 0x05	; 5
     7b8:	7c 93       	st	X, r23
     7ba:	6e 93       	st	-X, r22
     7bc:	14 97       	sbiw	r26, 0x04	; 4

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     7be:	fb 01       	movw	r30, r22
     7c0:	51 87       	std	Z+9, r21	; 0x09
     7c2:	40 87       	std	Z+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
     7c4:	fa 01       	movw	r30, r20
     7c6:	80 81       	ld	r24, Z
     7c8:	8f 5f       	subi	r24, 0xFF	; 255
     7ca:	80 83       	st	Z, r24
}
     7cc:	08 95       	ret

000007ce <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
     7ce:	cf 93       	push	r28
     7d0:	df 93       	push	r29
     7d2:	9c 01       	movw	r18, r24
     7d4:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     7d6:	48 81       	ld	r20, Y
     7d8:	59 81       	ldd	r21, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     7da:	8f ef       	ldi	r24, 0xFF	; 255
     7dc:	4f 3f       	cpi	r20, 0xFF	; 255
     7de:	58 07       	cpc	r21, r24
     7e0:	21 f4       	brne	.+8      	; 0x7ea <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     7e2:	f9 01       	movw	r30, r18
     7e4:	a7 81       	ldd	r26, Z+7	; 0x07
     7e6:	b0 85       	ldd	r27, Z+8	; 0x08
     7e8:	0d c0       	rjmp	.+26     	; 0x804 <vListInsert+0x36>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     7ea:	d9 01       	movw	r26, r18
     7ec:	13 96       	adiw	r26, 0x03	; 3
     7ee:	12 96       	adiw	r26, 0x02	; 2
     7f0:	ed 91       	ld	r30, X+
     7f2:	fc 91       	ld	r31, X
     7f4:	13 97       	sbiw	r26, 0x03	; 3
     7f6:	80 81       	ld	r24, Z
     7f8:	91 81       	ldd	r25, Z+1	; 0x01
     7fa:	48 17       	cp	r20, r24
     7fc:	59 07       	cpc	r21, r25
     7fe:	10 f0       	brcs	.+4      	; 0x804 <vListInsert+0x36>
     800:	df 01       	movw	r26, r30
     802:	f5 cf       	rjmp	.-22     	; 0x7ee <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     804:	12 96       	adiw	r26, 0x02	; 2
     806:	ed 91       	ld	r30, X+
     808:	fc 91       	ld	r31, X
     80a:	13 97       	sbiw	r26, 0x03	; 3
     80c:	fb 83       	std	Y+3, r31	; 0x03
     80e:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     810:	d5 83       	std	Z+5, r29	; 0x05
     812:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     814:	bd 83       	std	Y+5, r27	; 0x05
     816:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
     818:	13 96       	adiw	r26, 0x03	; 3
     81a:	dc 93       	st	X, r29
     81c:	ce 93       	st	-X, r28
     81e:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
     820:	39 87       	std	Y+9, r19	; 0x09
     822:	28 87       	std	Y+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
     824:	f9 01       	movw	r30, r18
     826:	80 81       	ld	r24, Z
     828:	8f 5f       	subi	r24, 0xFF	; 255
     82a:	80 83       	st	Z, r24
}
     82c:	df 91       	pop	r29
     82e:	cf 91       	pop	r28
     830:	08 95       	ret

00000832 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     832:	cf 93       	push	r28
     834:	df 93       	push	r29
     836:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
     838:	18 96       	adiw	r26, 0x08	; 8
     83a:	cd 91       	ld	r28, X+
     83c:	dc 91       	ld	r29, X
     83e:	19 97       	sbiw	r26, 0x09	; 9

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     840:	12 96       	adiw	r26, 0x02	; 2
     842:	4d 91       	ld	r20, X+
     844:	5c 91       	ld	r21, X
     846:	13 97       	sbiw	r26, 0x03	; 3
     848:	14 96       	adiw	r26, 0x04	; 4
     84a:	8d 91       	ld	r24, X+
     84c:	9c 91       	ld	r25, X
     84e:	15 97       	sbiw	r26, 0x05	; 5
     850:	fa 01       	movw	r30, r20
     852:	95 83       	std	Z+5, r25	; 0x05
     854:	84 83       	std	Z+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     856:	14 96       	adiw	r26, 0x04	; 4
     858:	2d 91       	ld	r18, X+
     85a:	3c 91       	ld	r19, X
     85c:	15 97       	sbiw	r26, 0x05	; 5
     85e:	f9 01       	movw	r30, r18
     860:	53 83       	std	Z+3, r21	; 0x03
     862:	42 83       	std	Z+2, r20	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     864:	89 81       	ldd	r24, Y+1	; 0x01
     866:	9a 81       	ldd	r25, Y+2	; 0x02
     868:	8a 17       	cp	r24, r26
     86a:	9b 07       	cpc	r25, r27
     86c:	11 f4       	brne	.+4      	; 0x872 <__stack+0x13>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     86e:	3a 83       	std	Y+2, r19	; 0x02
     870:	29 83       	std	Y+1, r18	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     872:	19 96       	adiw	r26, 0x09	; 9
     874:	1c 92       	st	X, r1
     876:	1e 92       	st	-X, r1
     878:	18 97       	sbiw	r26, 0x08	; 8
    ( pxList->uxNumberOfItems )--;
     87a:	88 81       	ld	r24, Y
     87c:	81 50       	subi	r24, 0x01	; 1
     87e:	88 83       	st	Y, r24

    return pxList->uxNumberOfItems;
     880:	88 81       	ld	r24, Y
}
     882:	df 91       	pop	r29
     884:	cf 91       	pop	r28
     886:	08 95       	ret

00000888 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     888:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     88a:	91 e1       	ldi	r25, 0x11	; 17
     88c:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     88e:	22 e2       	ldi	r18, 0x22	; 34
     890:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     892:	83 e3       	ldi	r24, 0x33	; 51
     894:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     896:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     898:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     89a:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     89c:	80 e8       	ldi	r24, 0x80	; 128
     89e:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     8a0:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     8a2:	82 e0       	ldi	r24, 0x02	; 2
     8a4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     8a6:	83 e0       	ldi	r24, 0x03	; 3
     8a8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     8aa:	84 e0       	ldi	r24, 0x04	; 4
     8ac:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     8ae:	85 e0       	ldi	r24, 0x05	; 5
     8b0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     8b2:	86 e0       	ldi	r24, 0x06	; 6
     8b4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     8b6:	87 e0       	ldi	r24, 0x07	; 7
     8b8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     8ba:	88 e0       	ldi	r24, 0x08	; 8
     8bc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     8be:	89 e0       	ldi	r24, 0x09	; 9
     8c0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     8c2:	80 e1       	ldi	r24, 0x10	; 16
     8c4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     8c6:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     8c8:	82 e1       	ldi	r24, 0x12	; 18
     8ca:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     8cc:	83 e1       	ldi	r24, 0x13	; 19
     8ce:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     8d0:	84 e1       	ldi	r24, 0x14	; 20
     8d2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     8d4:	85 e1       	ldi	r24, 0x15	; 21
     8d6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     8d8:	86 e1       	ldi	r24, 0x16	; 22
     8da:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     8dc:	87 e1       	ldi	r24, 0x17	; 23
     8de:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     8e0:	88 e1       	ldi	r24, 0x18	; 24
     8e2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     8e4:	89 e1       	ldi	r24, 0x19	; 25
     8e6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     8e8:	80 e2       	ldi	r24, 0x20	; 32
     8ea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     8ec:	81 e2       	ldi	r24, 0x21	; 33
     8ee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     8f0:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     8f2:	83 e2       	ldi	r24, 0x23	; 35
     8f4:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     8f6:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     8f8:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     8fa:	86 e2       	ldi	r24, 0x26	; 38
     8fc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     8fe:	87 e2       	ldi	r24, 0x27	; 39
     900:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     902:	88 e2       	ldi	r24, 0x28	; 40
     904:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     906:	89 e2       	ldi	r24, 0x29	; 41
     908:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     90a:	80 e3       	ldi	r24, 0x30	; 48
     90c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     90e:	81 e3       	ldi	r24, 0x31	; 49
     910:	82 93       	st	-Z, r24
     912:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     914:	cf 01       	movw	r24, r30
     916:	08 95       	ret

00000918 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     918:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     91a:	8e e0       	ldi	r24, 0x0E	; 14
     91c:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     91e:	8b e0       	ldi	r24, 0x0B	; 11
     920:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     922:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     924:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     926:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     928:	a0 91 ea 03 	lds	r26, 0x03EA
     92c:	b0 91 eb 03 	lds	r27, 0x03EB
     930:	cd 91       	ld	r28, X+
     932:	cd bf       	out	0x3d, r28	; 61
     934:	dd 91       	ld	r29, X+
     936:	de bf       	out	0x3e, r29	; 62
     938:	ff 91       	pop	r31
     93a:	ef 91       	pop	r30
     93c:	df 91       	pop	r29
     93e:	cf 91       	pop	r28
     940:	bf 91       	pop	r27
     942:	af 91       	pop	r26
     944:	9f 91       	pop	r25
     946:	8f 91       	pop	r24
     948:	7f 91       	pop	r23
     94a:	6f 91       	pop	r22
     94c:	5f 91       	pop	r21
     94e:	4f 91       	pop	r20
     950:	3f 91       	pop	r19
     952:	2f 91       	pop	r18
     954:	1f 91       	pop	r17
     956:	0f 91       	pop	r16
     958:	ff 90       	pop	r15
     95a:	ef 90       	pop	r14
     95c:	df 90       	pop	r13
     95e:	cf 90       	pop	r12
     960:	bf 90       	pop	r11
     962:	af 90       	pop	r10
     964:	9f 90       	pop	r9
     966:	8f 90       	pop	r8
     968:	7f 90       	pop	r7
     96a:	6f 90       	pop	r6
     96c:	5f 90       	pop	r5
     96e:	4f 90       	pop	r4
     970:	3f 90       	pop	r3
     972:	2f 90       	pop	r2
     974:	1f 90       	pop	r1
     976:	0f 90       	pop	r0
     978:	0f be       	out	0x3f, r0	; 63
     97a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     97c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	08 95       	ret

00000982 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     982:	08 95       	ret

00000984 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     984:	0f 92       	push	r0
     986:	0f b6       	in	r0, 0x3f	; 63
     988:	f8 94       	cli
     98a:	0f 92       	push	r0
     98c:	1f 92       	push	r1
     98e:	11 24       	eor	r1, r1
     990:	2f 92       	push	r2
     992:	3f 92       	push	r3
     994:	4f 92       	push	r4
     996:	5f 92       	push	r5
     998:	6f 92       	push	r6
     99a:	7f 92       	push	r7
     99c:	8f 92       	push	r8
     99e:	9f 92       	push	r9
     9a0:	af 92       	push	r10
     9a2:	bf 92       	push	r11
     9a4:	cf 92       	push	r12
     9a6:	df 92       	push	r13
     9a8:	ef 92       	push	r14
     9aa:	ff 92       	push	r15
     9ac:	0f 93       	push	r16
     9ae:	1f 93       	push	r17
     9b0:	2f 93       	push	r18
     9b2:	3f 93       	push	r19
     9b4:	4f 93       	push	r20
     9b6:	5f 93       	push	r21
     9b8:	6f 93       	push	r22
     9ba:	7f 93       	push	r23
     9bc:	8f 93       	push	r24
     9be:	9f 93       	push	r25
     9c0:	af 93       	push	r26
     9c2:	bf 93       	push	r27
     9c4:	cf 93       	push	r28
     9c6:	df 93       	push	r29
     9c8:	ef 93       	push	r30
     9ca:	ff 93       	push	r31
     9cc:	a0 91 ea 03 	lds	r26, 0x03EA
     9d0:	b0 91 eb 03 	lds	r27, 0x03EB
     9d4:	0d b6       	in	r0, 0x3d	; 61
     9d6:	0d 92       	st	X+, r0
     9d8:	0e b6       	in	r0, 0x3e	; 62
     9da:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     9dc:	0e 94 4d 0a 	call	0x149a	; 0x149a <xTaskIncrementTick>
     9e0:	88 23       	and	r24, r24
     9e2:	11 f0       	breq	.+4      	; 0x9e8 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     9e4:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     9e8:	a0 91 ea 03 	lds	r26, 0x03EA
     9ec:	b0 91 eb 03 	lds	r27, 0x03EB
     9f0:	cd 91       	ld	r28, X+
     9f2:	cd bf       	out	0x3d, r28	; 61
     9f4:	dd 91       	ld	r29, X+
     9f6:	de bf       	out	0x3e, r29	; 62
     9f8:	ff 91       	pop	r31
     9fa:	ef 91       	pop	r30
     9fc:	df 91       	pop	r29
     9fe:	cf 91       	pop	r28
     a00:	bf 91       	pop	r27
     a02:	af 91       	pop	r26
     a04:	9f 91       	pop	r25
     a06:	8f 91       	pop	r24
     a08:	7f 91       	pop	r23
     a0a:	6f 91       	pop	r22
     a0c:	5f 91       	pop	r21
     a0e:	4f 91       	pop	r20
     a10:	3f 91       	pop	r19
     a12:	2f 91       	pop	r18
     a14:	1f 91       	pop	r17
     a16:	0f 91       	pop	r16
     a18:	ff 90       	pop	r15
     a1a:	ef 90       	pop	r14
     a1c:	df 90       	pop	r13
     a1e:	cf 90       	pop	r12
     a20:	bf 90       	pop	r11
     a22:	af 90       	pop	r10
     a24:	9f 90       	pop	r9
     a26:	8f 90       	pop	r8
     a28:	7f 90       	pop	r7
     a2a:	6f 90       	pop	r6
     a2c:	5f 90       	pop	r5
     a2e:	4f 90       	pop	r4
     a30:	3f 90       	pop	r3
     a32:	2f 90       	pop	r2
     a34:	1f 90       	pop	r1
     a36:	0f 90       	pop	r0
     a38:	0f be       	out	0x3f, r0	; 63
     a3a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a3c:	08 95       	ret

00000a3e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     a3e:	0e 94 c2 04 	call	0x984	; 0x984 <vPortYieldFromTick>
		asm volatile ( "reti" );
     a42:	18 95       	reti

00000a44 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a44:	0f 92       	push	r0
     a46:	0f b6       	in	r0, 0x3f	; 63
     a48:	f8 94       	cli
     a4a:	0f 92       	push	r0
     a4c:	1f 92       	push	r1
     a4e:	11 24       	eor	r1, r1
     a50:	2f 92       	push	r2
     a52:	3f 92       	push	r3
     a54:	4f 92       	push	r4
     a56:	5f 92       	push	r5
     a58:	6f 92       	push	r6
     a5a:	7f 92       	push	r7
     a5c:	8f 92       	push	r8
     a5e:	9f 92       	push	r9
     a60:	af 92       	push	r10
     a62:	bf 92       	push	r11
     a64:	cf 92       	push	r12
     a66:	df 92       	push	r13
     a68:	ef 92       	push	r14
     a6a:	ff 92       	push	r15
     a6c:	0f 93       	push	r16
     a6e:	1f 93       	push	r17
     a70:	2f 93       	push	r18
     a72:	3f 93       	push	r19
     a74:	4f 93       	push	r20
     a76:	5f 93       	push	r21
     a78:	6f 93       	push	r22
     a7a:	7f 93       	push	r23
     a7c:	8f 93       	push	r24
     a7e:	9f 93       	push	r25
     a80:	af 93       	push	r26
     a82:	bf 93       	push	r27
     a84:	cf 93       	push	r28
     a86:	df 93       	push	r29
     a88:	ef 93       	push	r30
     a8a:	ff 93       	push	r31
     a8c:	a0 91 ea 03 	lds	r26, 0x03EA
     a90:	b0 91 eb 03 	lds	r27, 0x03EB
     a94:	0d b6       	in	r0, 0x3d	; 61
     a96:	0d 92       	st	X+, r0
     a98:	0e b6       	in	r0, 0x3e	; 62
     a9a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     a9c:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     aa0:	a0 91 ea 03 	lds	r26, 0x03EA
     aa4:	b0 91 eb 03 	lds	r27, 0x03EB
     aa8:	cd 91       	ld	r28, X+
     aaa:	cd bf       	out	0x3d, r28	; 61
     aac:	dd 91       	ld	r29, X+
     aae:	de bf       	out	0x3e, r29	; 62
     ab0:	ff 91       	pop	r31
     ab2:	ef 91       	pop	r30
     ab4:	df 91       	pop	r29
     ab6:	cf 91       	pop	r28
     ab8:	bf 91       	pop	r27
     aba:	af 91       	pop	r26
     abc:	9f 91       	pop	r25
     abe:	8f 91       	pop	r24
     ac0:	7f 91       	pop	r23
     ac2:	6f 91       	pop	r22
     ac4:	5f 91       	pop	r21
     ac6:	4f 91       	pop	r20
     ac8:	3f 91       	pop	r19
     aca:	2f 91       	pop	r18
     acc:	1f 91       	pop	r17
     ace:	0f 91       	pop	r16
     ad0:	ff 90       	pop	r15
     ad2:	ef 90       	pop	r14
     ad4:	df 90       	pop	r13
     ad6:	cf 90       	pop	r12
     ad8:	bf 90       	pop	r11
     ada:	af 90       	pop	r10
     adc:	9f 90       	pop	r9
     ade:	8f 90       	pop	r8
     ae0:	7f 90       	pop	r7
     ae2:	6f 90       	pop	r6
     ae4:	5f 90       	pop	r5
     ae6:	4f 90       	pop	r4
     ae8:	3f 90       	pop	r3
     aea:	2f 90       	pop	r2
     aec:	1f 90       	pop	r1
     aee:	0f 90       	pop	r0
     af0:	0f be       	out	0x3f, r0	; 63
     af2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     af4:	08 95       	ret

00000af6 <uxQueueMessagesWaiting>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
     af6:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
     afe:	82 8d       	ldd	r24, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
     b00:	0f 90       	pop	r0
     b02:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     b04:	08 95       	ret

00000b06 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
     b06:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
     b08:	0f b6       	in	r0, 0x3f	; 63
     b0a:	f8 94       	cli
     b0c:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
     b0e:	92 8d       	ldd	r25, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
     b10:	0f 90       	pop	r0
     b12:	0f be       	out	0x3f, r0	; 63
     b14:	83 8d       	ldd	r24, Z+27	; 0x1b

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     b16:	89 1b       	sub	r24, r25
     b18:	08 95       	ret

00000b1a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
     b1a:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
     b1c:	82 8d       	ldd	r24, Z+26	; 0x1a

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     b1e:	08 95       	ret

00000b20 <xQueueIsQueueEmptyFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
     b20:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     b22:	82 8d       	ldd	r24, Z+26	; 0x1a
     b24:	90 e0       	ldi	r25, 0x00	; 0
     b26:	88 23       	and	r24, r24
     b28:	09 f4       	brne	.+2      	; 0xb2c <xQueueIsQueueEmptyFromISR+0xc>
     b2a:	91 e0       	ldi	r25, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     b2c:	89 2f       	mov	r24, r25
     b2e:	08 95       	ret

00000b30 <xQueueIsQueueFullFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
     b30:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     b32:	92 8d       	ldd	r25, Z+26	; 0x1a
     b34:	20 e0       	ldi	r18, 0x00	; 0
     b36:	83 8d       	ldd	r24, Z+27	; 0x1b
     b38:	98 17       	cp	r25, r24
     b3a:	09 f4       	brne	.+2      	; 0xb3e <xQueueIsQueueFullFromISR+0xe>
     b3c:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     b3e:	82 2f       	mov	r24, r18
     b40:	08 95       	ret

00000b42 <vQueueDelete>:

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
     b42:	0e 94 9f 02 	call	0x53e	; 0x53e <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
     b46:	08 95       	ret

00000b48 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
     b48:	fc 01       	movw	r30, r24
     b4a:	56 2f       	mov	r21, r22
     b4c:	a7 2f       	mov	r26, r23
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     b4e:	24 8d       	ldd	r18, Z+28	; 0x1c
     b50:	22 23       	and	r18, r18
     b52:	b9 f0       	breq	.+46     	; 0xb82 <prvCopyDataFromQueue+0x3a>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
     b54:	86 81       	ldd	r24, Z+6	; 0x06
     b56:	97 81       	ldd	r25, Z+7	; 0x07
     b58:	82 0f       	add	r24, r18
     b5a:	91 1d       	adc	r25, r1
     b5c:	97 83       	std	Z+7, r25	; 0x07
     b5e:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     b60:	24 81       	ldd	r18, Z+4	; 0x04
     b62:	35 81       	ldd	r19, Z+5	; 0x05
     b64:	82 17       	cp	r24, r18
     b66:	93 07       	cpc	r25, r19
     b68:	20 f0       	brcs	.+8      	; 0xb72 <prvCopyDataFromQueue+0x2a>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
     b6a:	80 81       	ld	r24, Z
     b6c:	91 81       	ldd	r25, Z+1	; 0x01
     b6e:	97 83       	std	Z+7, r25	; 0x07
     b70:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
     b72:	44 8d       	ldd	r20, Z+28	; 0x1c
     b74:	66 81       	ldd	r22, Z+6	; 0x06
     b76:	77 81       	ldd	r23, Z+7	; 0x07
     b78:	85 2f       	mov	r24, r21
     b7a:	9a 2f       	mov	r25, r26
     b7c:	50 e0       	ldi	r21, 0x00	; 0
     b7e:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <memcpy>
     b82:	08 95       	ret

00000b84 <xQueuePeekFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
     b84:	0f 93       	push	r16
     b86:	1f 93       	push	r17
     b88:	cf 93       	push	r28
     b8a:	df 93       	push	r29
     b8c:	ec 01       	movw	r28, r24
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     b8e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b90:	88 23       	and	r24, r24
     b92:	41 f0       	breq	.+16     	; 0xba4 <xQueuePeekFromISR+0x20>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
     b94:	0e 81       	ldd	r16, Y+6	; 0x06
     b96:	1f 81       	ldd	r17, Y+7	; 0x07
            prvCopyDataFromQueue( pxQueue, pvBuffer );
     b98:	ce 01       	movw	r24, r28
     b9a:	0e 94 a4 05 	call	0xb48	; 0xb48 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
     b9e:	1f 83       	std	Y+7, r17	; 0x07
     ba0:	0e 83       	std	Y+6, r16	; 0x06
     ba2:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
     ba4:	df 91       	pop	r29
     ba6:	cf 91       	pop	r28
     ba8:	1f 91       	pop	r17
     baa:	0f 91       	pop	r16
     bac:	08 95       	ret

00000bae <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
     bae:	0f 93       	push	r16
     bb0:	1f 93       	push	r17
     bb2:	cf 93       	push	r28
     bb4:	df 93       	push	r29
     bb6:	ec 01       	movw	r28, r24
     bb8:	04 2f       	mov	r16, r20
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     bba:	1a 8d       	ldd	r17, Y+26	; 0x1a

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     bbc:	4c 8d       	ldd	r20, Y+28	; 0x1c
     bbe:	44 23       	and	r20, r20
     bc0:	c1 f1       	breq	.+112    	; 0xc32 <prvCopyDataToQueue+0x84>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
     bc2:	00 23       	and	r16, r16
     bc4:	b1 f4       	brne	.+44     	; 0xbf2 <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
     bc6:	8a 81       	ldd	r24, Y+2	; 0x02
     bc8:	9b 81       	ldd	r25, Y+3	; 0x03
     bca:	50 e0       	ldi	r21, 0x00	; 0
     bcc:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
     bd0:	8c 8d       	ldd	r24, Y+28	; 0x1c
     bd2:	2a 81       	ldd	r18, Y+2	; 0x02
     bd4:	3b 81       	ldd	r19, Y+3	; 0x03
     bd6:	28 0f       	add	r18, r24
     bd8:	31 1d       	adc	r19, r1
     bda:	3b 83       	std	Y+3, r19	; 0x03
     bdc:	2a 83       	std	Y+2, r18	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     bde:	8c 81       	ldd	r24, Y+4	; 0x04
     be0:	9d 81       	ldd	r25, Y+5	; 0x05
     be2:	28 17       	cp	r18, r24
     be4:	39 07       	cpc	r19, r25
     be6:	28 f1       	brcs	.+74     	; 0xc32 <prvCopyDataToQueue+0x84>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
     be8:	88 81       	ld	r24, Y
     bea:	99 81       	ldd	r25, Y+1	; 0x01
     bec:	9b 83       	std	Y+3, r25	; 0x03
     bee:	8a 83       	std	Y+2, r24	; 0x02
     bf0:	20 c0       	rjmp	.+64     	; 0xc32 <prvCopyDataToQueue+0x84>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
     bf2:	8e 81       	ldd	r24, Y+6	; 0x06
     bf4:	9f 81       	ldd	r25, Y+7	; 0x07
     bf6:	50 e0       	ldi	r21, 0x00	; 0
     bf8:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
     bfc:	8c 8d       	ldd	r24, Y+28	; 0x1c
     bfe:	90 e0       	ldi	r25, 0x00	; 0
     c00:	44 27       	eor	r20, r20
     c02:	55 27       	eor	r21, r21
     c04:	48 1b       	sub	r20, r24
     c06:	59 0b       	sbc	r21, r25
     c08:	8e 81       	ldd	r24, Y+6	; 0x06
     c0a:	9f 81       	ldd	r25, Y+7	; 0x07
     c0c:	84 0f       	add	r24, r20
     c0e:	95 1f       	adc	r25, r21
     c10:	9f 83       	std	Y+7, r25	; 0x07
     c12:	8e 83       	std	Y+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     c14:	28 81       	ld	r18, Y
     c16:	39 81       	ldd	r19, Y+1	; 0x01
     c18:	82 17       	cp	r24, r18
     c1a:	93 07       	cpc	r25, r19
     c1c:	30 f4       	brcc	.+12     	; 0xc2a <prvCopyDataToQueue+0x7c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
     c1e:	8c 81       	ldd	r24, Y+4	; 0x04
     c20:	9d 81       	ldd	r25, Y+5	; 0x05
     c22:	84 0f       	add	r24, r20
     c24:	95 1f       	adc	r25, r21
     c26:	9f 83       	std	Y+7, r25	; 0x07
     c28:	8e 83       	std	Y+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
     c2a:	02 30       	cpi	r16, 0x02	; 2
     c2c:	11 f4       	brne	.+4      	; 0xc32 <prvCopyDataToQueue+0x84>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     c2e:	11 11       	cpse	r17, r1
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
     c30:	11 50       	subi	r17, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     c32:	1f 5f       	subi	r17, 0xFF	; 255
     c34:	1a 8f       	std	Y+26, r17	; 0x1a

    return xReturn;
}
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	08 95       	ret

00000c42 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
     c42:	ef 92       	push	r14
     c44:	ff 92       	push	r15
     c46:	0f 93       	push	r16
     c48:	1f 93       	push	r17
     c4a:	cf 93       	push	r28
     c4c:	df 93       	push	r29
     c4e:	ec 01       	movw	r28, r24
     c50:	7a 01       	movw	r14, r20
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     c52:	1a 8d       	ldd	r17, Y+26	; 0x1a

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     c54:	11 23       	and	r17, r17
     c56:	11 f4       	brne	.+4      	; 0xc5c <xQueueReceiveFromISR+0x1a>
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	1e c0       	rjmp	.+60     	; 0xc98 <xQueueReceiveFromISR+0x56>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
     c5c:	0d 8d       	ldd	r16, Y+29	; 0x1d

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
     c5e:	0e 94 a4 05 	call	0xb48	; 0xb48 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     c62:	11 50       	subi	r17, 0x01	; 1
     c64:	1a 8f       	std	Y+26, r17	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
     c66:	0f 3f       	cpi	r16, 0xFF	; 255
     c68:	81 f4       	brne	.+32     	; 0xc8a <xQueueReceiveFromISR+0x48>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c6a:	88 85       	ldd	r24, Y+8	; 0x08
     c6c:	88 23       	and	r24, r24
     c6e:	99 f0       	breq	.+38     	; 0xc96 <xQueueReceiveFromISR+0x54>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c70:	ce 01       	movw	r24, r28
     c72:	08 96       	adiw	r24, 0x08	; 8
     c74:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
     c78:	88 23       	and	r24, r24
     c7a:	69 f0       	breq	.+26     	; 0xc96 <xQueueReceiveFromISR+0x54>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
     c7c:	e1 14       	cp	r14, r1
     c7e:	f1 04       	cpc	r15, r1
     c80:	51 f0       	breq	.+20     	; 0xc96 <xQueueReceiveFromISR+0x54>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
     c82:	81 e0       	ldi	r24, 0x01	; 1
     c84:	f7 01       	movw	r30, r14
     c86:	80 83       	st	Z, r24
     c88:	07 c0       	rjmp	.+14     	; 0xc98 <xQueueReceiveFromISR+0x56>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
     c8a:	0e 94 3f 0a 	call	0x147e	; 0x147e <uxTaskGetNumberOfTasks>
     c8e:	08 17       	cp	r16, r24
     c90:	10 f4       	brcc	.+4      	; 0xc96 <xQueueReceiveFromISR+0x54>
     c92:	0f 5f       	subi	r16, 0xFF	; 255
     c94:	0d 8f       	std	Y+29, r16	; 0x1d
     c96:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	ff 90       	pop	r15
     ca2:	ef 90       	pop	r14
     ca4:	08 95       	ret

00000ca6 <xQueueGiveFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
     ca6:	ef 92       	push	r14
     ca8:	ff 92       	push	r15
     caa:	1f 93       	push	r17
     cac:	cf 93       	push	r28
     cae:	df 93       	push	r29
     cb0:	ec 01       	movw	r28, r24
     cb2:	7b 01       	movw	r14, r22
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     cb4:	9a 8d       	ldd	r25, Y+26	; 0x1a

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
     cb6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     cb8:	98 17       	cp	r25, r24
     cba:	10 f0       	brcs	.+4      	; 0xcc0 <xQueueGiveFromISR+0x1a>
     cbc:	80 e0       	ldi	r24, 0x00	; 0
     cbe:	1c c0       	rjmp	.+56     	; 0xcf8 <xQueueGiveFromISR+0x52>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
     cc0:	1e 8d       	ldd	r17, Y+30	; 0x1e
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     cc2:	9f 5f       	subi	r25, 0xFF	; 255
     cc4:	9a 8f       	std	Y+26, r25	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
     cc6:	1f 3f       	cpi	r17, 0xFF	; 255
     cc8:	81 f4       	brne	.+32     	; 0xcea <xQueueGiveFromISR+0x44>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     cca:	89 89       	ldd	r24, Y+17	; 0x11
     ccc:	88 23       	and	r24, r24
     cce:	99 f0       	breq	.+38     	; 0xcf6 <xQueueGiveFromISR+0x50>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     cd0:	ce 01       	movw	r24, r28
     cd2:	41 96       	adiw	r24, 0x11	; 17
     cd4:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
     cd8:	88 23       	and	r24, r24
     cda:	69 f0       	breq	.+26     	; 0xcf6 <xQueueGiveFromISR+0x50>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
     cdc:	e1 14       	cp	r14, r1
     cde:	f1 04       	cpc	r15, r1
     ce0:	51 f0       	breq	.+20     	; 0xcf6 <xQueueGiveFromISR+0x50>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
     ce2:	81 e0       	ldi	r24, 0x01	; 1
     ce4:	f7 01       	movw	r30, r14
     ce6:	80 83       	st	Z, r24
     ce8:	07 c0       	rjmp	.+14     	; 0xcf8 <xQueueGiveFromISR+0x52>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
     cea:	0e 94 3f 0a 	call	0x147e	; 0x147e <uxTaskGetNumberOfTasks>
     cee:	18 17       	cp	r17, r24
     cf0:	10 f4       	brcc	.+4      	; 0xcf6 <xQueueGiveFromISR+0x50>
     cf2:	1f 5f       	subi	r17, 0xFF	; 255
     cf4:	1e 8f       	std	Y+30, r17	; 0x1e
     cf6:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
     cf8:	df 91       	pop	r29
     cfa:	cf 91       	pop	r28
     cfc:	1f 91       	pop	r17
     cfe:	ff 90       	pop	r15
     d00:	ef 90       	pop	r14
     d02:	08 95       	ret

00000d04 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
     d04:	ef 92       	push	r14
     d06:	ff 92       	push	r15
     d08:	1f 93       	push	r17
     d0a:	cf 93       	push	r28
     d0c:	df 93       	push	r29
     d0e:	ec 01       	movw	r28, r24
     d10:	7a 01       	movw	r14, r20
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     d12:	9a 8d       	ldd	r25, Y+26	; 0x1a
     d14:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d16:	98 17       	cp	r25, r24
     d18:	20 f0       	brcs	.+8      	; 0xd22 <xQueueGenericSendFromISR+0x1e>
     d1a:	22 30       	cpi	r18, 0x02	; 2
     d1c:	11 f0       	breq	.+4      	; 0xd22 <xQueueGenericSendFromISR+0x1e>
     d1e:	80 e0       	ldi	r24, 0x00	; 0
     d20:	1f c0       	rjmp	.+62     	; 0xd60 <xQueueGenericSendFromISR+0x5c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
     d22:	1e 8d       	ldd	r17, Y+30	; 0x1e
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
     d24:	8a 8d       	ldd	r24, Y+26	; 0x1a
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d26:	ce 01       	movw	r24, r28
     d28:	42 2f       	mov	r20, r18
     d2a:	0e 94 d7 05 	call	0xbae	; 0xbae <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
     d2e:	1f 3f       	cpi	r17, 0xFF	; 255
     d30:	81 f4       	brne	.+32     	; 0xd52 <xQueueGenericSendFromISR+0x4e>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d32:	89 89       	ldd	r24, Y+17	; 0x11
     d34:	88 23       	and	r24, r24
     d36:	99 f0       	breq	.+38     	; 0xd5e <xQueueGenericSendFromISR+0x5a>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d38:	ce 01       	movw	r24, r28
     d3a:	41 96       	adiw	r24, 0x11	; 17
     d3c:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
     d40:	88 23       	and	r24, r24
     d42:	69 f0       	breq	.+26     	; 0xd5e <xQueueGenericSendFromISR+0x5a>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
     d44:	e1 14       	cp	r14, r1
     d46:	f1 04       	cpc	r15, r1
     d48:	51 f0       	breq	.+20     	; 0xd5e <xQueueGenericSendFromISR+0x5a>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
     d4a:	81 e0       	ldi	r24, 0x01	; 1
     d4c:	f7 01       	movw	r30, r14
     d4e:	80 83       	st	Z, r24
     d50:	07 c0       	rjmp	.+14     	; 0xd60 <xQueueGenericSendFromISR+0x5c>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
     d52:	0e 94 3f 0a 	call	0x147e	; 0x147e <uxTaskGetNumberOfTasks>
     d56:	18 17       	cp	r17, r24
     d58:	10 f4       	brcc	.+4      	; 0xd5e <xQueueGenericSendFromISR+0x5a>
     d5a:	1f 5f       	subi	r17, 0xFF	; 255
     d5c:	1e 8f       	std	Y+30, r17	; 0x1e
     d5e:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
     d60:	df 91       	pop	r29
     d62:	cf 91       	pop	r28
     d64:	1f 91       	pop	r17
     d66:	ff 90       	pop	r15
     d68:	ef 90       	pop	r14
     d6a:	08 95       	ret

00000d6c <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     d6c:	ef 92       	push	r14
     d6e:	ff 92       	push	r15
     d70:	1f 93       	push	r17
     d72:	cf 93       	push	r28
     d74:	df 93       	push	r29
     d76:	ec 01       	movw	r28, r24

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
     d78:	0f b6       	in	r0, 0x3f	; 63
     d7a:	f8 94       	cli
     d7c:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
     d7e:	1e 8d       	ldd	r17, Y+30	; 0x1e
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d80:	91 e1       	ldi	r25, 0x11	; 17
     d82:	e9 2e       	mov	r14, r25
     d84:	f1 2c       	mov	r15, r1
     d86:	ec 0e       	add	r14, r28
     d88:	fd 1e       	adc	r15, r29
     d8a:	0b c0       	rjmp	.+22     	; 0xda2 <prvUnlockQueue+0x36>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d8c:	89 89       	ldd	r24, Y+17	; 0x11
     d8e:	88 23       	and	r24, r24
     d90:	51 f0       	breq	.+20     	; 0xda6 <prvUnlockQueue+0x3a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d92:	c7 01       	movw	r24, r14
     d94:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
     d98:	88 23       	and	r24, r24
     d9a:	11 f0       	breq	.+4      	; 0xda0 <prvUnlockQueue+0x34>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
     d9c:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
     da0:	11 50       	subi	r17, 0x01	; 1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
     da2:	11 16       	cp	r1, r17
     da4:	9c f3       	brlt	.-26     	; 0xd8c <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
     da6:	8f ef       	ldi	r24, 0xFF	; 255
     da8:	8e 8f       	std	Y+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
     daa:	0f 90       	pop	r0
     dac:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
     dae:	0f b6       	in	r0, 0x3f	; 63
     db0:	f8 94       	cli
     db2:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
     db4:	1d 8d       	ldd	r17, Y+29	; 0x1d

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     db6:	88 e0       	ldi	r24, 0x08	; 8
     db8:	e8 2e       	mov	r14, r24
     dba:	f1 2c       	mov	r15, r1
     dbc:	ec 0e       	add	r14, r28
     dbe:	fd 1e       	adc	r15, r29
     dc0:	0b c0       	rjmp	.+22     	; 0xdd8 <prvUnlockQueue+0x6c>
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     dc2:	88 85       	ldd	r24, Y+8	; 0x08
     dc4:	88 23       	and	r24, r24
     dc6:	51 f0       	breq	.+20     	; 0xddc <prvUnlockQueue+0x70>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     dc8:	c7 01       	movw	r24, r14
     dca:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
     dce:	88 23       	and	r24, r24
     dd0:	11 f0       	breq	.+4      	; 0xdd6 <prvUnlockQueue+0x6a>
                {
                    vTaskMissedYield();
     dd2:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
     dd6:	11 50       	subi	r17, 0x01	; 1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
     dd8:	11 16       	cp	r1, r17
     dda:	9c f3       	brlt	.-26     	; 0xdc2 <prvUnlockQueue+0x56>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
     ddc:	8f ef       	ldi	r24, 0xFF	; 255
     dde:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
     de0:	0f 90       	pop	r0
     de2:	0f be       	out	0x3f, r0	; 63
}
     de4:	df 91       	pop	r29
     de6:	cf 91       	pop	r28
     de8:	1f 91       	pop	r17
     dea:	ff 90       	pop	r15
     dec:	ef 90       	pop	r14
     dee:	08 95       	ret

00000df0 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
     df0:	8f 92       	push	r8
     df2:	9f 92       	push	r9
     df4:	af 92       	push	r10
     df6:	bf 92       	push	r11
     df8:	cf 92       	push	r12
     dfa:	df 92       	push	r13
     dfc:	ef 92       	push	r14
     dfe:	ff 92       	push	r15
     e00:	0f 93       	push	r16
     e02:	1f 93       	push	r17
     e04:	df 93       	push	r29
     e06:	cf 93       	push	r28
     e08:	00 d0       	rcall	.+0      	; 0xe0a <xQueuePeek+0x1a>
     e0a:	00 d0       	rcall	.+0      	; 0xe0c <xQueuePeek+0x1c>
     e0c:	0f 92       	push	r0
     e0e:	cd b7       	in	r28, 0x3d	; 61
     e10:	de b7       	in	r29, 0x3e	; 62
     e12:	7c 01       	movw	r14, r24
     e14:	5b 01       	movw	r10, r22
     e16:	5d 83       	std	Y+5, r21	; 0x05
     e18:	4c 83       	std	Y+4, r20	; 0x04
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e1a:	41 e1       	ldi	r20, 0x11	; 17
     e1c:	c4 2e       	mov	r12, r20
     e1e:	d1 2c       	mov	r13, r1
     e20:	c8 0e       	add	r12, r24
     e22:	d9 1e       	adc	r13, r25
     e24:	20 e0       	ldi	r18, 0x00	; 0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     e26:	8e 01       	movw	r16, r28
     e28:	0f 5f       	subi	r16, 0xFF	; 255
     e2a:	1f 4f       	sbci	r17, 0xFF	; 255

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e2c:	34 e0       	ldi	r19, 0x04	; 4
     e2e:	83 2e       	mov	r8, r19
     e30:	91 2c       	mov	r9, r1
     e32:	8c 0e       	add	r8, r28
     e34:	9d 1e       	adc	r9, r29
     e36:	01 c0       	rjmp	.+2      	; 0xe3a <xQueuePeek+0x4a>
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e38:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
     e3a:	0f b6       	in	r0, 0x3f	; 63
     e3c:	f8 94       	cli
     e3e:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     e40:	f7 01       	movw	r30, r14
     e42:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     e44:	88 23       	and	r24, r24
     e46:	b9 f0       	breq	.+46     	; 0xe76 <xQueuePeek+0x86>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
     e48:	06 81       	ldd	r16, Z+6	; 0x06
     e4a:	17 81       	ldd	r17, Z+7	; 0x07

                prvCopyDataFromQueue( pxQueue, pvBuffer );
     e4c:	c7 01       	movw	r24, r14
     e4e:	b5 01       	movw	r22, r10
     e50:	0e 94 a4 05 	call	0xb48	; 0xb48 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
     e54:	f7 01       	movw	r30, r14
     e56:	17 83       	std	Z+7, r17	; 0x07
     e58:	06 83       	std	Z+6, r16	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e5a:	81 89       	ldd	r24, Z+17	; 0x11
     e5c:	88 23       	and	r24, r24
     e5e:	39 f0       	breq	.+14     	; 0xe6e <xQueuePeek+0x7e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e60:	c6 01       	movw	r24, r12
     e62:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
     e66:	88 23       	and	r24, r24
     e68:	11 f0       	breq	.+4      	; 0xe6e <xQueuePeek+0x7e>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
     e6a:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
     e6e:	0f 90       	pop	r0
     e70:	0f be       	out	0x3f, r0	; 63
     e72:	81 e0       	ldi	r24, 0x01	; 1
     e74:	54 c0       	rjmp	.+168    	; 0xf1e <xQueuePeek+0x12e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
     e76:	8c 81       	ldd	r24, Y+4	; 0x04
     e78:	9d 81       	ldd	r25, Y+5	; 0x05
     e7a:	89 2b       	or	r24, r25
     e7c:	21 f4       	brne	.+8      	; 0xe86 <xQueuePeek+0x96>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	80 e0       	ldi	r24, 0x00	; 0
     e84:	4c c0       	rjmp	.+152    	; 0xf1e <xQueuePeek+0x12e>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
     e86:	22 23       	and	r18, r18
     e88:	19 f4       	brne	.+6      	; 0xe90 <xQueuePeek+0xa0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     e8a:	c8 01       	movw	r24, r16
     e8c:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
     e90:	0f 90       	pop	r0
     e92:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
     e94:	0e 94 28 0a 	call	0x1450	; 0x1450 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
     e98:	0f b6       	in	r0, 0x3f	; 63
     e9a:	f8 94       	cli
     e9c:	0f 92       	push	r0
     e9e:	f7 01       	movw	r30, r14
     ea0:	85 8d       	ldd	r24, Z+29	; 0x1d
     ea2:	8f 3f       	cpi	r24, 0xFF	; 255
     ea4:	09 f4       	brne	.+2      	; 0xea8 <xQueuePeek+0xb8>
     ea6:	15 8e       	std	Z+29, r1	; 0x1d
     ea8:	f7 01       	movw	r30, r14
     eaa:	86 8d       	ldd	r24, Z+30	; 0x1e
     eac:	8f 3f       	cpi	r24, 0xFF	; 255
     eae:	09 f4       	brne	.+2      	; 0xeb2 <xQueuePeek+0xc2>
     eb0:	16 8e       	std	Z+30, r1	; 0x1e
     eb2:	0f 90       	pop	r0
     eb4:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     eb6:	c8 01       	movw	r24, r16
     eb8:	b4 01       	movw	r22, r8
     eba:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <xTaskCheckForTimeOut>
     ebe:	88 23       	and	r24, r24
     ec0:	f9 f4       	brne	.+62     	; 0xf00 <xQueuePeek+0x110>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     ec2:	0f b6       	in	r0, 0x3f	; 63
     ec4:	f8 94       	cli
     ec6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     ec8:	f7 01       	movw	r30, r14
     eca:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     ecc:	0f 90       	pop	r0
     ece:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ed0:	88 23       	and	r24, r24
     ed2:	81 f4       	brne	.+32     	; 0xef4 <xQueuePeek+0x104>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ed4:	6c 81       	ldd	r22, Y+4	; 0x04
     ed6:	7d 81       	ldd	r23, Y+5	; 0x05
     ed8:	c6 01       	movw	r24, r12
     eda:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
     ede:	c7 01       	movw	r24, r14
     ee0:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
     ee4:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
     ee8:	88 23       	and	r24, r24
     eea:	09 f0       	breq	.+2      	; 0xeee <xQueuePeek+0xfe>
     eec:	a5 cf       	rjmp	.-182    	; 0xe38 <xQueuePeek+0x48>
                {
                    portYIELD_WITHIN_API();
     eee:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
     ef2:	a2 cf       	rjmp	.-188    	; 0xe38 <xQueuePeek+0x48>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
     ef4:	c7 01       	movw	r24, r14
     ef6:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
     efa:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
     efe:	9c cf       	rjmp	.-200    	; 0xe38 <xQueuePeek+0x48>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
     f00:	c7 01       	movw	r24, r14
     f02:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
     f06:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     f0a:	0f b6       	in	r0, 0x3f	; 63
     f0c:	f8 94       	cli
     f0e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     f10:	f7 01       	movw	r30, r14
     f12:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     f14:	0f 90       	pop	r0
     f16:	0f be       	out	0x3f, r0	; 63
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f18:	88 23       	and	r24, r24
     f1a:	09 f0       	breq	.+2      	; 0xf1e <xQueuePeek+0x12e>
     f1c:	8d cf       	rjmp	.-230    	; 0xe38 <xQueuePeek+0x48>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
     f1e:	0f 90       	pop	r0
     f20:	0f 90       	pop	r0
     f22:	0f 90       	pop	r0
     f24:	0f 90       	pop	r0
     f26:	0f 90       	pop	r0
     f28:	cf 91       	pop	r28
     f2a:	df 91       	pop	r29
     f2c:	1f 91       	pop	r17
     f2e:	0f 91       	pop	r16
     f30:	ff 90       	pop	r15
     f32:	ef 90       	pop	r14
     f34:	df 90       	pop	r13
     f36:	cf 90       	pop	r12
     f38:	bf 90       	pop	r11
     f3a:	af 90       	pop	r10
     f3c:	9f 90       	pop	r9
     f3e:	8f 90       	pop	r8
     f40:	08 95       	ret

00000f42 <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
     f42:	af 92       	push	r10
     f44:	bf 92       	push	r11
     f46:	cf 92       	push	r12
     f48:	df 92       	push	r13
     f4a:	ef 92       	push	r14
     f4c:	ff 92       	push	r15
     f4e:	0f 93       	push	r16
     f50:	1f 93       	push	r17
     f52:	df 93       	push	r29
     f54:	cf 93       	push	r28
     f56:	00 d0       	rcall	.+0      	; 0xf58 <xQueueSemaphoreTake+0x16>
     f58:	00 d0       	rcall	.+0      	; 0xf5a <xQueueSemaphoreTake+0x18>
     f5a:	0f 92       	push	r0
     f5c:	cd b7       	in	r28, 0x3d	; 61
     f5e:	de b7       	in	r29, 0x3e	; 62
     f60:	8c 01       	movw	r16, r24
     f62:	7d 83       	std	Y+5, r23	; 0x05
     f64:	6c 83       	std	Y+4, r22	; 0x04
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f66:	61 e1       	ldi	r22, 0x11	; 17
     f68:	e6 2e       	mov	r14, r22
     f6a:	f1 2c       	mov	r15, r1
     f6c:	e8 0e       	add	r14, r24
     f6e:	f9 1e       	adc	r15, r25
     f70:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     f72:	6e 01       	movw	r12, r28
     f74:	08 94       	sec
     f76:	c1 1c       	adc	r12, r1
     f78:	d1 1c       	adc	r13, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f7a:	54 e0       	ldi	r21, 0x04	; 4
     f7c:	a5 2e       	mov	r10, r21
     f7e:	b1 2c       	mov	r11, r1
     f80:	ac 0e       	add	r10, r28
     f82:	bd 1e       	adc	r11, r29
     f84:	01 c0       	rjmp	.+2      	; 0xf88 <xQueueSemaphoreTake+0x46>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f86:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	f8 94       	cli
     f8c:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
     f8e:	f8 01       	movw	r30, r16
     f90:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
     f92:	88 23       	and	r24, r24
     f94:	89 f0       	breq	.+34     	; 0xfb8 <xQueueSemaphoreTake+0x76>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
     f96:	81 50       	subi	r24, 0x01	; 1
     f98:	82 8f       	std	Z+26, r24	; 0x1a
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f9a:	80 85       	ldd	r24, Z+8	; 0x08
     f9c:	88 23       	and	r24, r24
     f9e:	41 f0       	breq	.+16     	; 0xfb0 <xQueueSemaphoreTake+0x6e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     fa0:	c8 01       	movw	r24, r16
     fa2:	08 96       	adiw	r24, 0x08	; 8
     fa4:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
     fa8:	88 23       	and	r24, r24
     faa:	11 f0       	breq	.+4      	; 0xfb0 <xQueueSemaphoreTake+0x6e>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
     fac:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
     fb0:	0f 90       	pop	r0
     fb2:	0f be       	out	0x3f, r0	; 63
     fb4:	81 e0       	ldi	r24, 0x01	; 1
     fb6:	54 c0       	rjmp	.+168    	; 0x1060 <xQueueSemaphoreTake+0x11e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
     fb8:	8c 81       	ldd	r24, Y+4	; 0x04
     fba:	9d 81       	ldd	r25, Y+5	; 0x05
     fbc:	89 2b       	or	r24, r25
     fbe:	21 f4       	brne	.+8      	; 0xfc8 <xQueueSemaphoreTake+0x86>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
     fc0:	0f 90       	pop	r0
     fc2:	0f be       	out	0x3f, r0	; 63
     fc4:	80 e0       	ldi	r24, 0x00	; 0
     fc6:	4c c0       	rjmp	.+152    	; 0x1060 <xQueueSemaphoreTake+0x11e>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
     fc8:	22 23       	and	r18, r18
     fca:	19 f4       	brne	.+6      	; 0xfd2 <xQueueSemaphoreTake+0x90>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     fcc:	c6 01       	movw	r24, r12
     fce:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
     fd2:	0f 90       	pop	r0
     fd4:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
     fd6:	0e 94 28 0a 	call	0x1450	; 0x1450 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
     fda:	0f b6       	in	r0, 0x3f	; 63
     fdc:	f8 94       	cli
     fde:	0f 92       	push	r0
     fe0:	f8 01       	movw	r30, r16
     fe2:	85 8d       	ldd	r24, Z+29	; 0x1d
     fe4:	8f 3f       	cpi	r24, 0xFF	; 255
     fe6:	09 f4       	brne	.+2      	; 0xfea <xQueueSemaphoreTake+0xa8>
     fe8:	15 8e       	std	Z+29, r1	; 0x1d
     fea:	f8 01       	movw	r30, r16
     fec:	86 8d       	ldd	r24, Z+30	; 0x1e
     fee:	8f 3f       	cpi	r24, 0xFF	; 255
     ff0:	09 f4       	brne	.+2      	; 0xff4 <xQueueSemaphoreTake+0xb2>
     ff2:	16 8e       	std	Z+30, r1	; 0x1e
     ff4:	0f 90       	pop	r0
     ff6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ff8:	c6 01       	movw	r24, r12
     ffa:	b5 01       	movw	r22, r10
     ffc:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <xTaskCheckForTimeOut>
    1000:	88 23       	and	r24, r24
    1002:	f9 f4       	brne	.+62     	; 0x1042 <xQueueSemaphoreTake+0x100>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1004:	0f b6       	in	r0, 0x3f	; 63
    1006:	f8 94       	cli
    1008:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    100a:	f8 01       	movw	r30, r16
    100c:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    100e:	0f 90       	pop	r0
    1010:	0f be       	out	0x3f, r0	; 63
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1012:	88 23       	and	r24, r24
    1014:	81 f4       	brne	.+32     	; 0x1036 <xQueueSemaphoreTake+0xf4>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1016:	6c 81       	ldd	r22, Y+4	; 0x04
    1018:	7d 81       	ldd	r23, Y+5	; 0x05
    101a:	c7 01       	movw	r24, r14
    101c:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1020:	c8 01       	movw	r24, r16
    1022:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1026:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
    102a:	88 23       	and	r24, r24
    102c:	09 f0       	breq	.+2      	; 0x1030 <xQueueSemaphoreTake+0xee>
    102e:	ab cf       	rjmp	.-170    	; 0xf86 <xQueueSemaphoreTake+0x44>
                {
                    portYIELD_WITHIN_API();
    1030:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
    1034:	a8 cf       	rjmp	.-176    	; 0xf86 <xQueueSemaphoreTake+0x44>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    1036:	c8 01       	movw	r24, r16
    1038:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    103c:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
    1040:	a2 cf       	rjmp	.-188    	; 0xf86 <xQueueSemaphoreTake+0x44>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    1042:	c8 01       	movw	r24, r16
    1044:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1048:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    104c:	0f b6       	in	r0, 0x3f	; 63
    104e:	f8 94       	cli
    1050:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1052:	f8 01       	movw	r30, r16
    1054:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1056:	0f 90       	pop	r0
    1058:	0f be       	out	0x3f, r0	; 63

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    105a:	88 23       	and	r24, r24
    105c:	09 f0       	breq	.+2      	; 0x1060 <xQueueSemaphoreTake+0x11e>
    105e:	93 cf       	rjmp	.-218    	; 0xf86 <xQueueSemaphoreTake+0x44>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    1060:	0f 90       	pop	r0
    1062:	0f 90       	pop	r0
    1064:	0f 90       	pop	r0
    1066:	0f 90       	pop	r0
    1068:	0f 90       	pop	r0
    106a:	cf 91       	pop	r28
    106c:	df 91       	pop	r29
    106e:	1f 91       	pop	r17
    1070:	0f 91       	pop	r16
    1072:	ff 90       	pop	r15
    1074:	ef 90       	pop	r14
    1076:	df 90       	pop	r13
    1078:	cf 90       	pop	r12
    107a:	bf 90       	pop	r11
    107c:	af 90       	pop	r10
    107e:	08 95       	ret

00001080 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    1080:	6f 92       	push	r6
    1082:	7f 92       	push	r7
    1084:	8f 92       	push	r8
    1086:	9f 92       	push	r9
    1088:	af 92       	push	r10
    108a:	bf 92       	push	r11
    108c:	cf 92       	push	r12
    108e:	df 92       	push	r13
    1090:	ff 92       	push	r15
    1092:	0f 93       	push	r16
    1094:	1f 93       	push	r17
    1096:	df 93       	push	r29
    1098:	cf 93       	push	r28
    109a:	00 d0       	rcall	.+0      	; 0x109c <xQueueReceive+0x1c>
    109c:	00 d0       	rcall	.+0      	; 0x109e <xQueueReceive+0x1e>
    109e:	0f 92       	push	r0
    10a0:	cd b7       	in	r28, 0x3d	; 61
    10a2:	de b7       	in	r29, 0x3e	; 62
    10a4:	8c 01       	movw	r16, r24
    10a6:	5b 01       	movw	r10, r22
    10a8:	5d 83       	std	Y+5, r21	; 0x05
    10aa:	4c 83       	std	Y+4, r20	; 0x04
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    10ac:	e1 e1       	ldi	r30, 0x11	; 17
    10ae:	ce 2e       	mov	r12, r30
    10b0:	d1 2c       	mov	r13, r1
    10b2:	c8 0e       	add	r12, r24
    10b4:	d9 1e       	adc	r13, r25
    10b6:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    10b8:	4e 01       	movw	r8, r28
    10ba:	08 94       	sec
    10bc:	81 1c       	adc	r8, r1
    10be:	91 1c       	adc	r9, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    10c0:	74 e0       	ldi	r23, 0x04	; 4
    10c2:	67 2e       	mov	r6, r23
    10c4:	71 2c       	mov	r7, r1
    10c6:	6c 0e       	add	r6, r28
    10c8:	7d 1e       	adc	r7, r29
    10ca:	01 c0       	rjmp	.+2      	; 0x10ce <xQueueReceive+0x4e>
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    10cc:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    10ce:	0f b6       	in	r0, 0x3f	; 63
    10d0:	f8 94       	cli
    10d2:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    10d4:	f8 01       	movw	r30, r16
    10d6:	f2 8c       	ldd	r15, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    10d8:	ff 20       	and	r15, r15
    10da:	b1 f0       	breq	.+44     	; 0x1108 <xQueueReceive+0x88>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    10dc:	c8 01       	movw	r24, r16
    10de:	b5 01       	movw	r22, r10
    10e0:	0e 94 a4 05 	call	0xb48	; 0xb48 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    10e4:	fa 94       	dec	r15
    10e6:	f8 01       	movw	r30, r16
    10e8:	f2 8e       	std	Z+26, r15	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10ea:	80 85       	ldd	r24, Z+8	; 0x08
    10ec:	88 23       	and	r24, r24
    10ee:	41 f0       	breq	.+16     	; 0x1100 <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10f0:	c8 01       	movw	r24, r16
    10f2:	08 96       	adiw	r24, 0x08	; 8
    10f4:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
    10f8:	88 23       	and	r24, r24
    10fa:	11 f0       	breq	.+4      	; 0x1100 <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    10fc:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1100:	0f 90       	pop	r0
    1102:	0f be       	out	0x3f, r0	; 63
    1104:	81 e0       	ldi	r24, 0x01	; 1
    1106:	54 c0       	rjmp	.+168    	; 0x11b0 <xQueueReceive+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1108:	8c 81       	ldd	r24, Y+4	; 0x04
    110a:	9d 81       	ldd	r25, Y+5	; 0x05
    110c:	89 2b       	or	r24, r25
    110e:	21 f4       	brne	.+8      	; 0x1118 <xQueueReceive+0x98>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1110:	0f 90       	pop	r0
    1112:	0f be       	out	0x3f, r0	; 63
    1114:	80 e0       	ldi	r24, 0x00	; 0
    1116:	4c c0       	rjmp	.+152    	; 0x11b0 <xQueueReceive+0x130>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    1118:	22 23       	and	r18, r18
    111a:	19 f4       	brne	.+6      	; 0x1122 <xQueueReceive+0xa2>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    111c:	c4 01       	movw	r24, r8
    111e:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1122:	0f 90       	pop	r0
    1124:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1126:	0e 94 28 0a 	call	0x1450	; 0x1450 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    112a:	0f b6       	in	r0, 0x3f	; 63
    112c:	f8 94       	cli
    112e:	0f 92       	push	r0
    1130:	f8 01       	movw	r30, r16
    1132:	85 8d       	ldd	r24, Z+29	; 0x1d
    1134:	8f 3f       	cpi	r24, 0xFF	; 255
    1136:	09 f4       	brne	.+2      	; 0x113a <xQueueReceive+0xba>
    1138:	15 8e       	std	Z+29, r1	; 0x1d
    113a:	f8 01       	movw	r30, r16
    113c:	86 8d       	ldd	r24, Z+30	; 0x1e
    113e:	8f 3f       	cpi	r24, 0xFF	; 255
    1140:	09 f4       	brne	.+2      	; 0x1144 <xQueueReceive+0xc4>
    1142:	16 8e       	std	Z+30, r1	; 0x1e
    1144:	0f 90       	pop	r0
    1146:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1148:	c4 01       	movw	r24, r8
    114a:	b3 01       	movw	r22, r6
    114c:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <xTaskCheckForTimeOut>
    1150:	88 23       	and	r24, r24
    1152:	f9 f4       	brne	.+62     	; 0x1192 <xQueueReceive+0x112>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1154:	0f b6       	in	r0, 0x3f	; 63
    1156:	f8 94       	cli
    1158:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    115a:	f8 01       	movw	r30, r16
    115c:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    115e:	0f 90       	pop	r0
    1160:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1162:	88 23       	and	r24, r24
    1164:	81 f4       	brne	.+32     	; 0x1186 <xQueueReceive+0x106>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1166:	6c 81       	ldd	r22, Y+4	; 0x04
    1168:	7d 81       	ldd	r23, Y+5	; 0x05
    116a:	c6 01       	movw	r24, r12
    116c:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1170:	c8 01       	movw	r24, r16
    1172:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1176:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
    117a:	88 23       	and	r24, r24
    117c:	09 f0       	breq	.+2      	; 0x1180 <xQueueReceive+0x100>
    117e:	a6 cf       	rjmp	.-180    	; 0x10cc <xQueueReceive+0x4c>
                {
                    portYIELD_WITHIN_API();
    1180:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
    1184:	a3 cf       	rjmp	.-186    	; 0x10cc <xQueueReceive+0x4c>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    1186:	c8 01       	movw	r24, r16
    1188:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    118c:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
    1190:	9d cf       	rjmp	.-198    	; 0x10cc <xQueueReceive+0x4c>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    1192:	c8 01       	movw	r24, r16
    1194:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1198:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    119c:	0f b6       	in	r0, 0x3f	; 63
    119e:	f8 94       	cli
    11a0:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    11a2:	f8 01       	movw	r30, r16
    11a4:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    11a6:	0f 90       	pop	r0
    11a8:	0f be       	out	0x3f, r0	; 63
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    11aa:	88 23       	and	r24, r24
    11ac:	09 f0       	breq	.+2      	; 0x11b0 <xQueueReceive+0x130>
    11ae:	8e cf       	rjmp	.-228    	; 0x10cc <xQueueReceive+0x4c>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    11b0:	0f 90       	pop	r0
    11b2:	0f 90       	pop	r0
    11b4:	0f 90       	pop	r0
    11b6:	0f 90       	pop	r0
    11b8:	0f 90       	pop	r0
    11ba:	cf 91       	pop	r28
    11bc:	df 91       	pop	r29
    11be:	1f 91       	pop	r17
    11c0:	0f 91       	pop	r16
    11c2:	ff 90       	pop	r15
    11c4:	df 90       	pop	r13
    11c6:	cf 90       	pop	r12
    11c8:	bf 90       	pop	r11
    11ca:	af 90       	pop	r10
    11cc:	9f 90       	pop	r9
    11ce:	8f 90       	pop	r8
    11d0:	7f 90       	pop	r7
    11d2:	6f 90       	pop	r6
    11d4:	08 95       	ret

000011d6 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    11d6:	6f 92       	push	r6
    11d8:	7f 92       	push	r7
    11da:	9f 92       	push	r9
    11dc:	af 92       	push	r10
    11de:	bf 92       	push	r11
    11e0:	cf 92       	push	r12
    11e2:	df 92       	push	r13
    11e4:	ef 92       	push	r14
    11e6:	ff 92       	push	r15
    11e8:	0f 93       	push	r16
    11ea:	1f 93       	push	r17
    11ec:	df 93       	push	r29
    11ee:	cf 93       	push	r28
    11f0:	00 d0       	rcall	.+0      	; 0x11f2 <xQueueGenericSend+0x1c>
    11f2:	00 d0       	rcall	.+0      	; 0x11f4 <xQueueGenericSend+0x1e>
    11f4:	0f 92       	push	r0
    11f6:	cd b7       	in	r28, 0x3d	; 61
    11f8:	de b7       	in	r29, 0x3e	; 62
    11fa:	8c 01       	movw	r16, r24
    11fc:	6b 01       	movw	r12, r22
    11fe:	5d 83       	std	Y+5, r21	; 0x05
    1200:	4c 83       	std	Y+4, r20	; 0x04
    1202:	92 2e       	mov	r9, r18
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1204:	a8 e0       	ldi	r26, 0x08	; 8
    1206:	ea 2e       	mov	r14, r26
    1208:	f1 2c       	mov	r15, r1
    120a:	e8 0e       	add	r14, r24
    120c:	f9 1e       	adc	r15, r25
    120e:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1210:	5e 01       	movw	r10, r28
    1212:	08 94       	sec
    1214:	a1 1c       	adc	r10, r1
    1216:	b1 1c       	adc	r11, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1218:	f4 e0       	ldi	r31, 0x04	; 4
    121a:	6f 2e       	mov	r6, r31
    121c:	71 2c       	mov	r7, r1
    121e:	6c 0e       	add	r6, r28
    1220:	7d 1e       	adc	r7, r29
    1222:	01 c0       	rjmp	.+2      	; 0x1226 <xQueueGenericSend+0x50>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1224:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1226:	0f b6       	in	r0, 0x3f	; 63
    1228:	f8 94       	cli
    122a:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    122c:	f8 01       	movw	r30, r16
    122e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1230:	83 8d       	ldd	r24, Z+27	; 0x1b
    1232:	98 17       	cp	r25, r24
    1234:	18 f0       	brcs	.+6      	; 0x123c <xQueueGenericSend+0x66>
    1236:	f2 e0       	ldi	r31, 0x02	; 2
    1238:	9f 16       	cp	r9, r31
    123a:	c9 f4       	brne	.+50     	; 0x126e <xQueueGenericSend+0x98>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    123c:	c8 01       	movw	r24, r16
    123e:	b6 01       	movw	r22, r12
    1240:	49 2d       	mov	r20, r9
    1242:	0e 94 d7 05 	call	0xbae	; 0xbae <prvCopyDataToQueue>
    1246:	98 2f       	mov	r25, r24

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1248:	f8 01       	movw	r30, r16
    124a:	81 89       	ldd	r24, Z+17	; 0x11
    124c:	88 23       	and	r24, r24
    124e:	39 f0       	breq	.+14     	; 0x125e <xQueueGenericSend+0x88>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1250:	c8 01       	movw	r24, r16
    1252:	41 96       	adiw	r24, 0x11	; 17
    1254:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
    1258:	88 23       	and	r24, r24
    125a:	29 f0       	breq	.+10     	; 0x1266 <xQueueGenericSend+0x90>
    125c:	02 c0       	rjmp	.+4      	; 0x1262 <xQueueGenericSend+0x8c>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    125e:	99 23       	and	r25, r25
    1260:	11 f0       	breq	.+4      	; 0x1266 <xQueueGenericSend+0x90>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    1262:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1266:	0f 90       	pop	r0
    1268:	0f be       	out	0x3f, r0	; 63
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	4c c0       	rjmp	.+152    	; 0x1306 <xQueueGenericSend+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    126e:	8c 81       	ldd	r24, Y+4	; 0x04
    1270:	9d 81       	ldd	r25, Y+5	; 0x05
    1272:	89 2b       	or	r24, r25
    1274:	19 f4       	brne	.+6      	; 0x127c <xQueueGenericSend+0xa6>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1276:	0f 90       	pop	r0
    1278:	0f be       	out	0x3f, r0	; 63
    127a:	44 c0       	rjmp	.+136    	; 0x1304 <xQueueGenericSend+0x12e>
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
    127c:	22 23       	and	r18, r18
    127e:	19 f4       	brne	.+6      	; 0x1286 <xQueueGenericSend+0xb0>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1280:	c5 01       	movw	r24, r10
    1282:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1286:	0f 90       	pop	r0
    1288:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    128a:	0e 94 28 0a 	call	0x1450	; 0x1450 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    128e:	0f b6       	in	r0, 0x3f	; 63
    1290:	f8 94       	cli
    1292:	0f 92       	push	r0
    1294:	f8 01       	movw	r30, r16
    1296:	85 8d       	ldd	r24, Z+29	; 0x1d
    1298:	8f 3f       	cpi	r24, 0xFF	; 255
    129a:	09 f4       	brne	.+2      	; 0x129e <xQueueGenericSend+0xc8>
    129c:	15 8e       	std	Z+29, r1	; 0x1d
    129e:	f8 01       	movw	r30, r16
    12a0:	86 8d       	ldd	r24, Z+30	; 0x1e
    12a2:	8f 3f       	cpi	r24, 0xFF	; 255
    12a4:	09 f4       	brne	.+2      	; 0x12a8 <xQueueGenericSend+0xd2>
    12a6:	16 8e       	std	Z+30, r1	; 0x1e
    12a8:	0f 90       	pop	r0
    12aa:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12ac:	c5 01       	movw	r24, r10
    12ae:	b3 01       	movw	r22, r6
    12b0:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <xTaskCheckForTimeOut>
    12b4:	88 23       	and	r24, r24
    12b6:	09 f5       	brne	.+66     	; 0x12fa <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    12b8:	0f b6       	in	r0, 0x3f	; 63
    12ba:	f8 94       	cli
    12bc:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    12be:	f8 01       	movw	r30, r16
    12c0:	92 8d       	ldd	r25, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    12c2:	0f 90       	pop	r0
    12c4:	0f be       	out	0x3f, r0	; 63
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    12c6:	f8 01       	movw	r30, r16
    12c8:	83 8d       	ldd	r24, Z+27	; 0x1b
    12ca:	98 17       	cp	r25, r24
    12cc:	81 f4       	brne	.+32     	; 0x12ee <xQueueGenericSend+0x118>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    12ce:	6c 81       	ldd	r22, Y+4	; 0x04
    12d0:	7d 81       	ldd	r23, Y+5	; 0x05
    12d2:	c7 01       	movw	r24, r14
    12d4:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    12d8:	c8 01       	movw	r24, r16
    12da:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    12de:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
    12e2:	88 23       	and	r24, r24
    12e4:	09 f0       	breq	.+2      	; 0x12e8 <xQueueGenericSend+0x112>
    12e6:	9e cf       	rjmp	.-196    	; 0x1224 <xQueueGenericSend+0x4e>
                {
                    portYIELD_WITHIN_API();
    12e8:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
    12ec:	9b cf       	rjmp	.-202    	; 0x1224 <xQueueGenericSend+0x4e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    12ee:	c8 01       	movw	r24, r16
    12f0:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    12f4:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
    12f8:	95 cf       	rjmp	.-214    	; 0x1224 <xQueueGenericSend+0x4e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    12fa:	c8 01       	movw	r24, r16
    12fc:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1300:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
    1304:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
    1306:	0f 90       	pop	r0
    1308:	0f 90       	pop	r0
    130a:	0f 90       	pop	r0
    130c:	0f 90       	pop	r0
    130e:	0f 90       	pop	r0
    1310:	cf 91       	pop	r28
    1312:	df 91       	pop	r29
    1314:	1f 91       	pop	r17
    1316:	0f 91       	pop	r16
    1318:	ff 90       	pop	r15
    131a:	ef 90       	pop	r14
    131c:	df 90       	pop	r13
    131e:	cf 90       	pop	r12
    1320:	bf 90       	pop	r11
    1322:	af 90       	pop	r10
    1324:	9f 90       	pop	r9
    1326:	7f 90       	pop	r7
    1328:	6f 90       	pop	r6
    132a:	08 95       	ret

0000132c <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    132c:	cf 93       	push	r28
    132e:	df 93       	push	r29
    1330:	ec 01       	movw	r28, r24
    1332:	e6 2f       	mov	r30, r22
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1334:	00 97       	sbiw	r24, 0x00	; 0
    1336:	09 f4       	brne	.+2      	; 0x133a <xQueueGenericReset+0xe>
    1338:	4f c0       	rjmp	.+158    	; 0x13d8 <xQueueGenericReset+0xac>
    133a:	2b 8d       	ldd	r18, Y+27	; 0x1b
    133c:	22 23       	and	r18, r18
    133e:	09 f4       	brne	.+2      	; 0x1342 <xQueueGenericReset+0x16>
    1340:	4b c0       	rjmp	.+150    	; 0x13d8 <xQueueGenericReset+0xac>
    1342:	3c 8d       	ldd	r19, Y+28	; 0x1c
    1344:	8f ef       	ldi	r24, 0xFF	; 255
    1346:	9f e7       	ldi	r25, 0x7F	; 127
    1348:	62 2f       	mov	r22, r18
    134a:	70 e0       	ldi	r23, 0x00	; 0
    134c:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <__udivmodhi4>
    1350:	83 2f       	mov	r24, r19
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	68 17       	cp	r22, r24
    1356:	79 07       	cpc	r23, r25
    1358:	08 f4       	brcc	.+2      	; 0x135c <xQueueGenericReset+0x30>
    135a:	3e c0       	rjmp	.+124    	; 0x13d8 <xQueueGenericReset+0xac>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    135c:	0f b6       	in	r0, 0x3f	; 63
    135e:	f8 94       	cli
    1360:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1362:	32 9f       	mul	r19, r18
    1364:	c0 01       	movw	r24, r0
    1366:	11 24       	eor	r1, r1
    1368:	48 81       	ld	r20, Y
    136a:	59 81       	ldd	r21, Y+1	; 0x01
    136c:	84 0f       	add	r24, r20
    136e:	95 1f       	adc	r25, r21
    1370:	9d 83       	std	Y+5, r25	; 0x05
    1372:	8c 83       	std	Y+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1374:	1a 8e       	std	Y+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1376:	5b 83       	std	Y+3, r21	; 0x03
    1378:	4a 83       	std	Y+2, r20	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    137a:	2b 8d       	ldd	r18, Y+27	; 0x1b
    137c:	30 e0       	ldi	r19, 0x00	; 0
    137e:	21 50       	subi	r18, 0x01	; 1
    1380:	30 40       	sbci	r19, 0x00	; 0
    1382:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	bc 01       	movw	r22, r24
    1388:	26 9f       	mul	r18, r22
    138a:	c0 01       	movw	r24, r0
    138c:	27 9f       	mul	r18, r23
    138e:	90 0d       	add	r25, r0
    1390:	36 9f       	mul	r19, r22
    1392:	90 0d       	add	r25, r0
    1394:	11 24       	eor	r1, r1
    1396:	48 0f       	add	r20, r24
    1398:	59 1f       	adc	r21, r25
    139a:	5f 83       	std	Y+7, r21	; 0x07
    139c:	4e 83       	std	Y+6, r20	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    139e:	8f ef       	ldi	r24, 0xFF	; 255
    13a0:	8d 8f       	std	Y+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    13a2:	8e 8f       	std	Y+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    13a4:	ee 23       	and	r30, r30
    13a6:	61 f4       	brne	.+24     	; 0x13c0 <xQueueGenericReset+0x94>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13a8:	88 85       	ldd	r24, Y+8	; 0x08
    13aa:	88 23       	and	r24, r24
    13ac:	89 f0       	breq	.+34     	; 0x13d0 <xQueueGenericReset+0xa4>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13ae:	ce 01       	movw	r24, r28
    13b0:	08 96       	adiw	r24, 0x08	; 8
    13b2:	0e 94 9f 0b 	call	0x173e	; 0x173e <xTaskRemoveFromEventList>
    13b6:	88 23       	and	r24, r24
    13b8:	59 f0       	breq	.+22     	; 0x13d0 <xQueueGenericReset+0xa4>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    13ba:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
    13be:	08 c0       	rjmp	.+16     	; 0x13d0 <xQueueGenericReset+0xa4>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    13c0:	ce 01       	movw	r24, r28
    13c2:	08 96       	adiw	r24, 0x08	; 8
    13c4:	0e 94 b4 03 	call	0x768	; 0x768 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    13c8:	ce 01       	movw	r24, r28
    13ca:	41 96       	adiw	r24, 0x11	; 17
    13cc:	0e 94 b4 03 	call	0x768	; 0x768 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    13d0:	0f 90       	pop	r0
    13d2:	0f be       	out	0x3f, r0	; 63
    13d4:	81 e0       	ldi	r24, 0x01	; 1
    13d6:	01 c0       	rjmp	.+2      	; 0x13da <xQueueGenericReset+0xae>
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    13d8:	80 e0       	ldi	r24, 0x00	; 0
    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
}
    13da:	df 91       	pop	r29
    13dc:	cf 91       	pop	r28
    13de:	08 95       	ret

000013e0 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    13e0:	0f 93       	push	r16
    13e2:	1f 93       	push	r17
    13e4:	cf 93       	push	r28
    13e6:	df 93       	push	r29
    13e8:	18 2f       	mov	r17, r24
    13ea:	06 2f       	mov	r16, r22
        Queue_t * pxNewQueue = NULL;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    13ec:	88 23       	and	r24, r24
    13ee:	41 f1       	breq	.+80     	; 0x1440 <xQueueGenericCreate+0x60>
    13f0:	8f ef       	ldi	r24, 0xFF	; 255
    13f2:	9f e7       	ldi	r25, 0x7F	; 127
    13f4:	61 2f       	mov	r22, r17
    13f6:	70 e0       	ldi	r23, 0x00	; 0
    13f8:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <__udivmodhi4>
    13fc:	80 2f       	mov	r24, r16
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	68 17       	cp	r22, r24
    1402:	79 07       	cpc	r23, r25
    1404:	e8 f0       	brcs	.+58     	; 0x1440 <xQueueGenericCreate+0x60>
    1406:	01 9f       	mul	r16, r17
    1408:	c0 01       	movw	r24, r0
    140a:	11 24       	eor	r1, r1
    140c:	2f e7       	ldi	r18, 0x7F	; 127
    140e:	81 3e       	cpi	r24, 0xE1	; 225
    1410:	92 07       	cpc	r25, r18
    1412:	b0 f4       	brcc	.+44     	; 0x1440 <xQueueGenericCreate+0x60>
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1414:	4f 96       	adiw	r24, 0x1f	; 31
    1416:	0e 94 cf 02 	call	0x59e	; 0x59e <pvPortMalloc>
    141a:	fc 01       	movw	r30, r24
    141c:	ec 01       	movw	r28, r24

            if( pxNewQueue != NULL )
    141e:	00 97       	sbiw	r24, 0x00	; 0
    1420:	89 f0       	breq	.+34     	; 0x1444 <xQueueGenericCreate+0x64>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    1422:	00 23       	and	r16, r16
    1424:	19 f4       	brne	.+6      	; 0x142c <xQueueGenericCreate+0x4c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1426:	91 83       	std	Z+1, r25	; 0x01
    1428:	80 83       	st	Z, r24
    142a:	03 c0       	rjmp	.+6      	; 0x1432 <xQueueGenericCreate+0x52>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    142c:	4f 96       	adiw	r24, 0x1f	; 31
    142e:	91 83       	std	Z+1, r25	; 0x01
    1430:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    1432:	13 8f       	std	Z+27, r17	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    1434:	04 8f       	std	Z+28, r16	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1436:	cf 01       	movw	r24, r30
    1438:	61 e0       	ldi	r22, 0x01	; 1
    143a:	0e 94 96 09 	call	0x132c	; 0x132c <xQueueGenericReset>
    143e:	02 c0       	rjmp	.+4      	; 0x1444 <xQueueGenericCreate+0x64>
    1440:	c0 e0       	ldi	r28, 0x00	; 0
    1442:	d0 e0       	ldi	r29, 0x00	; 0
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
    1444:	ce 01       	movw	r24, r28
    1446:	df 91       	pop	r29
    1448:	cf 91       	pop	r28
    144a:	1f 91       	pop	r17
    144c:	0f 91       	pop	r16
    144e:	08 95       	ret

00001450 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    1450:	80 91 ec 03 	lds	r24, 0x03EC
    1454:	8f 5f       	subi	r24, 0xFF	; 255
    1456:	80 93 ec 03 	sts	0x03EC, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    145a:	08 95       	ret

0000145c <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    145c:	0f b6       	in	r0, 0x3f	; 63
    145e:	f8 94       	cli
    1460:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    1462:	20 91 ef 03 	lds	r18, 0x03EF
    1466:	30 91 f0 03 	lds	r19, 0x03F0
    }
    portTICK_TYPE_EXIT_CRITICAL();
    146a:	0f 90       	pop	r0
    146c:	0f be       	out	0x3f, r0	; 63

    return xTicks;
}
    146e:	c9 01       	movw	r24, r18
    1470:	08 95       	ret

00001472 <xTaskGetTickCountFromISR>:
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    1472:	20 91 ef 03 	lds	r18, 0x03EF
    1476:	30 91 f0 03 	lds	r19, 0x03F0
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    147a:	c9 01       	movw	r24, r18
    147c:	08 95       	ret

0000147e <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    147e:	80 91 f6 03 	lds	r24, 0x03F6
}
    1482:	08 95       	ret

00001484 <pcTaskGetName>:
{
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1484:	00 97       	sbiw	r24, 0x00	; 0
    1486:	21 f4       	brne	.+8      	; 0x1490 <pcTaskGetName+0xc>
    1488:	80 91 ea 03 	lds	r24, 0x03EA
    148c:	90 91 eb 03 	lds	r25, 0x03EB
    1490:	9c 01       	movw	r18, r24
    1492:	27 5e       	subi	r18, 0xE7	; 231
    1494:	3f 4f       	sbci	r19, 0xFF	; 255
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
}
    1496:	c9 01       	movw	r24, r18
    1498:	08 95       	ret

0000149a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    149a:	ef 92       	push	r14
    149c:	ff 92       	push	r15
    149e:	0f 93       	push	r16
    14a0:	1f 93       	push	r17
    14a2:	cf 93       	push	r28
    14a4:	df 93       	push	r29
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    14a6:	80 91 ec 03 	lds	r24, 0x03EC
    14aa:	88 23       	and	r24, r24
    14ac:	09 f0       	breq	.+2      	; 0x14b0 <xTaskIncrementTick+0x16>
    14ae:	fb c0       	rjmp	.+502    	; 0x16a6 <xTaskIncrementTick+0x20c>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    14b0:	00 91 ef 03 	lds	r16, 0x03EF
    14b4:	10 91 f0 03 	lds	r17, 0x03F0
    14b8:	0f 5f       	subi	r16, 0xFF	; 255
    14ba:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    14bc:	10 93 f0 03 	sts	0x03F0, r17
    14c0:	00 93 ef 03 	sts	0x03EF, r16

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    14c4:	01 15       	cp	r16, r1
    14c6:	11 05       	cpc	r17, r1
    14c8:	61 f5       	brne	.+88     	; 0x1522 <xTaskIncrementTick+0x88>
        {
            taskSWITCH_DELAYED_LISTS();
    14ca:	20 91 3b 04 	lds	r18, 0x043B
    14ce:	30 91 3c 04 	lds	r19, 0x043C
    14d2:	80 91 3d 04 	lds	r24, 0x043D
    14d6:	90 91 3e 04 	lds	r25, 0x043E
    14da:	90 93 3c 04 	sts	0x043C, r25
    14de:	80 93 3b 04 	sts	0x043B, r24
    14e2:	30 93 3e 04 	sts	0x043E, r19
    14e6:	20 93 3d 04 	sts	0x043D, r18
    14ea:	80 91 f3 03 	lds	r24, 0x03F3
    14ee:	8f 5f       	subi	r24, 0xFF	; 255
    14f0:	80 93 f3 03 	sts	0x03F3, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    14f4:	e0 91 3b 04 	lds	r30, 0x043B
    14f8:	f0 91 3c 04 	lds	r31, 0x043C
    14fc:	80 81       	ld	r24, Z
    14fe:	88 23       	and	r24, r24
    1500:	19 f4       	brne	.+6      	; 0x1508 <xTaskIncrementTick+0x6e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    1502:	8f ef       	ldi	r24, 0xFF	; 255
    1504:	9f ef       	ldi	r25, 0xFF	; 255
    1506:	09 c0       	rjmp	.+18     	; 0x151a <xTaskIncrementTick+0x80>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1508:	e0 91 3b 04 	lds	r30, 0x043B
    150c:	f0 91 3c 04 	lds	r31, 0x043C
    1510:	05 80       	ldd	r0, Z+5	; 0x05
    1512:	f6 81       	ldd	r31, Z+6	; 0x06
    1514:	e0 2d       	mov	r30, r0
    1516:	80 81       	ld	r24, Z
    1518:	91 81       	ldd	r25, Z+1	; 0x01
    151a:	90 93 f2 03 	sts	0x03F2, r25
    151e:	80 93 f1 03 	sts	0x03F1, r24

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    1522:	80 91 f1 03 	lds	r24, 0x03F1
    1526:	90 91 f2 03 	lds	r25, 0x03F2
    152a:	08 17       	cp	r16, r24
    152c:	19 07       	cpc	r17, r25
    152e:	08 f4       	brcc	.+2      	; 0x1532 <xTaskIncrementTick+0x98>
    1530:	a2 c0       	rjmp	.+324    	; 0x1676 <xTaskIncrementTick+0x1dc>
    1532:	ff 24       	eor	r15, r15
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    1534:	39 e0       	ldi	r19, 0x09	; 9
    1536:	e3 2e       	mov	r14, r19
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1538:	e0 91 3b 04 	lds	r30, 0x043B
    153c:	f0 91 3c 04 	lds	r31, 0x043C
    1540:	80 81       	ld	r24, Z
    1542:	88 23       	and	r24, r24
    1544:	19 f4       	brne	.+6      	; 0x154c <xTaskIncrementTick+0xb2>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1546:	8f ef       	ldi	r24, 0xFF	; 255
    1548:	9f ef       	ldi	r25, 0xFF	; 255
    154a:	0e c0       	rjmp	.+28     	; 0x1568 <xTaskIncrementTick+0xce>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    154c:	e0 91 3b 04 	lds	r30, 0x043B
    1550:	f0 91 3c 04 	lds	r31, 0x043C
    1554:	05 80       	ldd	r0, Z+5	; 0x05
    1556:	f6 81       	ldd	r31, Z+6	; 0x06
    1558:	e0 2d       	mov	r30, r0
    155a:	c6 81       	ldd	r28, Z+6	; 0x06
    155c:	d7 81       	ldd	r29, Z+7	; 0x07
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    155e:	8a 81       	ldd	r24, Y+2	; 0x02
    1560:	9b 81       	ldd	r25, Y+3	; 0x03

                    if( xConstTickCount < xItemValue )
    1562:	08 17       	cp	r16, r24
    1564:	19 07       	cpc	r17, r25
    1566:	28 f4       	brcc	.+10     	; 0x1572 <xTaskIncrementTick+0xd8>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    1568:	90 93 f2 03 	sts	0x03F2, r25
    156c:	80 93 f1 03 	sts	0x03F1, r24
    1570:	83 c0       	rjmp	.+262    	; 0x1678 <xTaskIncrementTick+0x1de>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1572:	aa 85       	ldd	r26, Y+10	; 0x0a
    1574:	bb 85       	ldd	r27, Y+11	; 0x0b
    1576:	4c 81       	ldd	r20, Y+4	; 0x04
    1578:	5d 81       	ldd	r21, Y+5	; 0x05
    157a:	8e 81       	ldd	r24, Y+6	; 0x06
    157c:	9f 81       	ldd	r25, Y+7	; 0x07
    157e:	fa 01       	movw	r30, r20
    1580:	95 83       	std	Z+5, r25	; 0x05
    1582:	84 83       	std	Z+4, r24	; 0x04
    1584:	2e 81       	ldd	r18, Y+6	; 0x06
    1586:	3f 81       	ldd	r19, Y+7	; 0x07
    1588:	f9 01       	movw	r30, r18
    158a:	53 83       	std	Z+3, r21	; 0x03
    158c:	42 83       	std	Z+2, r20	; 0x02
    158e:	be 01       	movw	r22, r28
    1590:	6e 5f       	subi	r22, 0xFE	; 254
    1592:	7f 4f       	sbci	r23, 0xFF	; 255
    1594:	11 96       	adiw	r26, 0x01	; 1
    1596:	8d 91       	ld	r24, X+
    1598:	9c 91       	ld	r25, X
    159a:	12 97       	sbiw	r26, 0x02	; 2
    159c:	86 17       	cp	r24, r22
    159e:	97 07       	cpc	r25, r23
    15a0:	21 f4       	brne	.+8      	; 0x15aa <xTaskIncrementTick+0x110>
    15a2:	12 96       	adiw	r26, 0x02	; 2
    15a4:	3c 93       	st	X, r19
    15a6:	2e 93       	st	-X, r18
    15a8:	11 97       	sbiw	r26, 0x01	; 1
    15aa:	1b 86       	std	Y+11, r1	; 0x0b
    15ac:	1a 86       	std	Y+10, r1	; 0x0a
    15ae:	8c 91       	ld	r24, X
    15b0:	81 50       	subi	r24, 0x01	; 1
    15b2:	8c 93       	st	X, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    15b4:	ac 89       	ldd	r26, Y+20	; 0x14
    15b6:	bd 89       	ldd	r27, Y+21	; 0x15
    15b8:	10 97       	sbiw	r26, 0x00	; 0
    15ba:	f9 f0       	breq	.+62     	; 0x15fa <xTaskIncrementTick+0x160>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    15bc:	2e 85       	ldd	r18, Y+14	; 0x0e
    15be:	3f 85       	ldd	r19, Y+15	; 0x0f
    15c0:	88 89       	ldd	r24, Y+16	; 0x10
    15c2:	99 89       	ldd	r25, Y+17	; 0x11
    15c4:	f9 01       	movw	r30, r18
    15c6:	95 83       	std	Z+5, r25	; 0x05
    15c8:	84 83       	std	Z+4, r24	; 0x04
    15ca:	48 89       	ldd	r20, Y+16	; 0x10
    15cc:	59 89       	ldd	r21, Y+17	; 0x11
    15ce:	fa 01       	movw	r30, r20
    15d0:	33 83       	std	Z+3, r19	; 0x03
    15d2:	22 83       	std	Z+2, r18	; 0x02
    15d4:	9e 01       	movw	r18, r28
    15d6:	24 5f       	subi	r18, 0xF4	; 244
    15d8:	3f 4f       	sbci	r19, 0xFF	; 255
    15da:	11 96       	adiw	r26, 0x01	; 1
    15dc:	8d 91       	ld	r24, X+
    15de:	9c 91       	ld	r25, X
    15e0:	12 97       	sbiw	r26, 0x02	; 2
    15e2:	82 17       	cp	r24, r18
    15e4:	93 07       	cpc	r25, r19
    15e6:	21 f4       	brne	.+8      	; 0x15f0 <xTaskIncrementTick+0x156>
    15e8:	12 96       	adiw	r26, 0x02	; 2
    15ea:	5c 93       	st	X, r21
    15ec:	4e 93       	st	-X, r20
    15ee:	11 97       	sbiw	r26, 0x01	; 1
    15f0:	1d 8a       	std	Y+21, r1	; 0x15
    15f2:	1c 8a       	std	Y+20, r1	; 0x14
    15f4:	8c 91       	ld	r24, X
    15f6:	81 50       	subi	r24, 0x01	; 1
    15f8:	8c 93       	st	X, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    15fa:	9e 89       	ldd	r25, Y+22	; 0x16
    15fc:	80 91 ed 03 	lds	r24, 0x03ED
    1600:	89 17       	cp	r24, r25
    1602:	10 f4       	brcc	.+4      	; 0x1608 <xTaskIncrementTick+0x16e>
    1604:	90 93 ed 03 	sts	0x03ED, r25
    1608:	89 2f       	mov	r24, r25
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	fc 01       	movw	r30, r24
    160e:	23 e0       	ldi	r18, 0x03	; 3
    1610:	ee 0f       	add	r30, r30
    1612:	ff 1f       	adc	r31, r31
    1614:	2a 95       	dec	r18
    1616:	e1 f7       	brne	.-8      	; 0x1610 <xTaskIncrementTick+0x176>
    1618:	e8 0f       	add	r30, r24
    161a:	f9 1f       	adc	r31, r25
    161c:	e4 50       	subi	r30, 0x04	; 4
    161e:	fc 4f       	sbci	r31, 0xFC	; 252
    1620:	a1 81       	ldd	r26, Z+1	; 0x01
    1622:	b2 81       	ldd	r27, Z+2	; 0x02
    1624:	bd 83       	std	Y+5, r27	; 0x05
    1626:	ac 83       	std	Y+4, r26	; 0x04
    1628:	14 96       	adiw	r26, 0x04	; 4
    162a:	8d 91       	ld	r24, X+
    162c:	9c 91       	ld	r25, X
    162e:	15 97       	sbiw	r26, 0x05	; 5
    1630:	9f 83       	std	Y+7, r25	; 0x07
    1632:	8e 83       	std	Y+6, r24	; 0x06
    1634:	14 96       	adiw	r26, 0x04	; 4
    1636:	ed 91       	ld	r30, X+
    1638:	fc 91       	ld	r31, X
    163a:	15 97       	sbiw	r26, 0x05	; 5
    163c:	73 83       	std	Z+3, r23	; 0x03
    163e:	62 83       	std	Z+2, r22	; 0x02
    1640:	15 96       	adiw	r26, 0x05	; 5
    1642:	7c 93       	st	X, r23
    1644:	6e 93       	st	-X, r22
    1646:	14 97       	sbiw	r26, 0x04	; 4
    1648:	ee 89       	ldd	r30, Y+22	; 0x16
    164a:	ee 9d       	mul	r30, r14
    164c:	f0 01       	movw	r30, r0
    164e:	11 24       	eor	r1, r1
    1650:	e4 50       	subi	r30, 0x04	; 4
    1652:	fc 4f       	sbci	r31, 0xFC	; 252
    1654:	fb 87       	std	Y+11, r31	; 0x0b
    1656:	ea 87       	std	Y+10, r30	; 0x0a
    1658:	80 81       	ld	r24, Z
    165a:	8f 5f       	subi	r24, 0xFF	; 255
    165c:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    165e:	e0 91 ea 03 	lds	r30, 0x03EA
    1662:	f0 91 eb 03 	lds	r31, 0x03EB
    1666:	9e 89       	ldd	r25, Y+22	; 0x16
    1668:	86 89       	ldd	r24, Z+22	; 0x16
    166a:	89 17       	cp	r24, r25
    166c:	08 f0       	brcs	.+2      	; 0x1670 <xTaskIncrementTick+0x1d6>
    166e:	64 cf       	rjmp	.-312    	; 0x1538 <xTaskIncrementTick+0x9e>
    1670:	ff 24       	eor	r15, r15
    1672:	f3 94       	inc	r15
    1674:	61 cf       	rjmp	.-318    	; 0x1538 <xTaskIncrementTick+0x9e>
    1676:	ff 24       	eor	r15, r15
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1678:	e0 91 ea 03 	lds	r30, 0x03EA
    167c:	f0 91 eb 03 	lds	r31, 0x03EB
    1680:	e6 89       	ldd	r30, Z+22	; 0x16
    1682:	89 e0       	ldi	r24, 0x09	; 9
    1684:	e8 9f       	mul	r30, r24
    1686:	f0 01       	movw	r30, r0
    1688:	11 24       	eor	r1, r1
    168a:	e4 50       	subi	r30, 0x04	; 4
    168c:	fc 4f       	sbci	r31, 0xFC	; 252
    168e:	80 81       	ld	r24, Z
    1690:	82 30       	cpi	r24, 0x02	; 2
    1692:	10 f0       	brcs	.+4      	; 0x1698 <xTaskIncrementTick+0x1fe>
    1694:	ff 24       	eor	r15, r15
    1696:	f3 94       	inc	r15
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    1698:	80 91 ee 03 	lds	r24, 0x03EE
    169c:	88 23       	and	r24, r24
    169e:	69 f0       	breq	.+26     	; 0x16ba <xTaskIncrementTick+0x220>
    16a0:	ff 24       	eor	r15, r15
    16a2:	f3 94       	inc	r15
    16a4:	0a c0       	rjmp	.+20     	; 0x16ba <xTaskIncrementTick+0x220>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    16a6:	80 91 f4 03 	lds	r24, 0x03F4
    16aa:	90 91 f5 03 	lds	r25, 0x03F5
    16ae:	01 96       	adiw	r24, 0x01	; 1
    16b0:	90 93 f5 03 	sts	0x03F5, r25
    16b4:	80 93 f4 03 	sts	0x03F4, r24
    16b8:	ff 24       	eor	r15, r15
        }
        #endif
    }

    return xSwitchRequired;
}
    16ba:	8f 2d       	mov	r24, r15
    16bc:	df 91       	pop	r29
    16be:	cf 91       	pop	r28
    16c0:	1f 91       	pop	r17
    16c2:	0f 91       	pop	r16
    16c4:	ff 90       	pop	r15
    16c6:	ef 90       	pop	r14
    16c8:	08 95       	ret

000016ca <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    16ca:	80 91 ec 03 	lds	r24, 0x03EC
    16ce:	88 23       	and	r24, r24
    16d0:	21 f0       	breq	.+8      	; 0x16da <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	80 93 ee 03 	sts	0x03EE, r24
    16d8:	08 95       	ret
    }
    else
    {
        xYieldPending = pdFALSE;
    16da:	10 92 ee 03 	sts	0x03EE, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    16de:	20 91 ed 03 	lds	r18, 0x03ED
    16e2:	99 e0       	ldi	r25, 0x09	; 9
    16e4:	01 c0       	rjmp	.+2      	; 0x16e8 <vTaskSwitchContext+0x1e>
    16e6:	21 50       	subi	r18, 0x01	; 1
    16e8:	29 9f       	mul	r18, r25
    16ea:	d0 01       	movw	r26, r0
    16ec:	11 24       	eor	r1, r1
    16ee:	a4 50       	subi	r26, 0x04	; 4
    16f0:	bc 4f       	sbci	r27, 0xFC	; 252
    16f2:	8c 91       	ld	r24, X
    16f4:	88 23       	and	r24, r24
    16f6:	b9 f3       	breq	.-18     	; 0x16e6 <vTaskSwitchContext+0x1c>
    16f8:	11 96       	adiw	r26, 0x01	; 1
    16fa:	ed 91       	ld	r30, X+
    16fc:	fc 91       	ld	r31, X
    16fe:	12 97       	sbiw	r26, 0x02	; 2
    1700:	02 80       	ldd	r0, Z+2	; 0x02
    1702:	f3 81       	ldd	r31, Z+3	; 0x03
    1704:	e0 2d       	mov	r30, r0
    1706:	12 96       	adiw	r26, 0x02	; 2
    1708:	fc 93       	st	X, r31
    170a:	ee 93       	st	-X, r30
    170c:	11 97       	sbiw	r26, 0x01	; 1
    170e:	cd 01       	movw	r24, r26
    1710:	03 96       	adiw	r24, 0x03	; 3
    1712:	e8 17       	cp	r30, r24
    1714:	f9 07       	cpc	r31, r25
    1716:	31 f4       	brne	.+12     	; 0x1724 <vTaskSwitchContext+0x5a>
    1718:	82 81       	ldd	r24, Z+2	; 0x02
    171a:	93 81       	ldd	r25, Z+3	; 0x03
    171c:	12 96       	adiw	r26, 0x02	; 2
    171e:	9c 93       	st	X, r25
    1720:	8e 93       	st	-X, r24
    1722:	11 97       	sbiw	r26, 0x01	; 1
    1724:	11 96       	adiw	r26, 0x01	; 1
    1726:	ed 91       	ld	r30, X+
    1728:	fc 91       	ld	r31, X
    172a:	12 97       	sbiw	r26, 0x02	; 2
    172c:	86 81       	ldd	r24, Z+6	; 0x06
    172e:	97 81       	ldd	r25, Z+7	; 0x07
    1730:	90 93 eb 03 	sts	0x03EB, r25
    1734:	80 93 ea 03 	sts	0x03EA, r24
    1738:	20 93 ed 03 	sts	0x03ED, r18
    173c:	08 95       	ret

0000173e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    173e:	cf 93       	push	r28
    1740:	df 93       	push	r29
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1742:	dc 01       	movw	r26, r24
    1744:	15 96       	adiw	r26, 0x05	; 5
    1746:	ed 91       	ld	r30, X+
    1748:	fc 91       	ld	r31, X
    174a:	16 97       	sbiw	r26, 0x06	; 6
    174c:	c6 81       	ldd	r28, Z+6	; 0x06
    174e:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    1750:	ac 89       	ldd	r26, Y+20	; 0x14
    1752:	bd 89       	ldd	r27, Y+21	; 0x15
    1754:	4e 85       	ldd	r20, Y+14	; 0x0e
    1756:	5f 85       	ldd	r21, Y+15	; 0x0f
    1758:	88 89       	ldd	r24, Y+16	; 0x10
    175a:	99 89       	ldd	r25, Y+17	; 0x11
    175c:	fa 01       	movw	r30, r20
    175e:	95 83       	std	Z+5, r25	; 0x05
    1760:	84 83       	std	Z+4, r24	; 0x04
    1762:	28 89       	ldd	r18, Y+16	; 0x10
    1764:	39 89       	ldd	r19, Y+17	; 0x11
    1766:	f9 01       	movw	r30, r18
    1768:	53 83       	std	Z+3, r21	; 0x03
    176a:	42 83       	std	Z+2, r20	; 0x02
    176c:	ae 01       	movw	r20, r28
    176e:	44 5f       	subi	r20, 0xF4	; 244
    1770:	5f 4f       	sbci	r21, 0xFF	; 255
    1772:	11 96       	adiw	r26, 0x01	; 1
    1774:	8d 91       	ld	r24, X+
    1776:	9c 91       	ld	r25, X
    1778:	12 97       	sbiw	r26, 0x02	; 2
    177a:	84 17       	cp	r24, r20
    177c:	95 07       	cpc	r25, r21
    177e:	21 f4       	brne	.+8      	; 0x1788 <xTaskRemoveFromEventList+0x4a>
    1780:	12 96       	adiw	r26, 0x02	; 2
    1782:	3c 93       	st	X, r19
    1784:	2e 93       	st	-X, r18
    1786:	11 97       	sbiw	r26, 0x01	; 1
    1788:	1d 8a       	std	Y+21, r1	; 0x15
    178a:	1c 8a       	std	Y+20, r1	; 0x14
    178c:	8c 91       	ld	r24, X
    178e:	81 50       	subi	r24, 0x01	; 1
    1790:	8c 93       	st	X, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1792:	80 91 ec 03 	lds	r24, 0x03EC
    1796:	88 23       	and	r24, r24
    1798:	09 f0       	breq	.+2      	; 0x179c <xTaskRemoveFromEventList+0x5e>
    179a:	55 c0       	rjmp	.+170    	; 0x1846 <xTaskRemoveFromEventList+0x108>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    179c:	aa 85       	ldd	r26, Y+10	; 0x0a
    179e:	bb 85       	ldd	r27, Y+11	; 0x0b
    17a0:	4c 81       	ldd	r20, Y+4	; 0x04
    17a2:	5d 81       	ldd	r21, Y+5	; 0x05
    17a4:	8e 81       	ldd	r24, Y+6	; 0x06
    17a6:	9f 81       	ldd	r25, Y+7	; 0x07
    17a8:	fa 01       	movw	r30, r20
    17aa:	95 83       	std	Z+5, r25	; 0x05
    17ac:	84 83       	std	Z+4, r24	; 0x04
    17ae:	2e 81       	ldd	r18, Y+6	; 0x06
    17b0:	3f 81       	ldd	r19, Y+7	; 0x07
    17b2:	f9 01       	movw	r30, r18
    17b4:	53 83       	std	Z+3, r21	; 0x03
    17b6:	42 83       	std	Z+2, r20	; 0x02
    17b8:	ae 01       	movw	r20, r28
    17ba:	4e 5f       	subi	r20, 0xFE	; 254
    17bc:	5f 4f       	sbci	r21, 0xFF	; 255
    17be:	11 96       	adiw	r26, 0x01	; 1
    17c0:	8d 91       	ld	r24, X+
    17c2:	9c 91       	ld	r25, X
    17c4:	12 97       	sbiw	r26, 0x02	; 2
    17c6:	84 17       	cp	r24, r20
    17c8:	95 07       	cpc	r25, r21
    17ca:	21 f4       	brne	.+8      	; 0x17d4 <xTaskRemoveFromEventList+0x96>
    17cc:	12 96       	adiw	r26, 0x02	; 2
    17ce:	3c 93       	st	X, r19
    17d0:	2e 93       	st	-X, r18
    17d2:	11 97       	sbiw	r26, 0x01	; 1
    17d4:	1b 86       	std	Y+11, r1	; 0x0b
    17d6:	1a 86       	std	Y+10, r1	; 0x0a
    17d8:	8c 91       	ld	r24, X
    17da:	81 50       	subi	r24, 0x01	; 1
    17dc:	8c 93       	st	X, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    17de:	9e 89       	ldd	r25, Y+22	; 0x16
    17e0:	80 91 ed 03 	lds	r24, 0x03ED
    17e4:	89 17       	cp	r24, r25
    17e6:	10 f4       	brcc	.+4      	; 0x17ec <xTaskRemoveFromEventList+0xae>
    17e8:	90 93 ed 03 	sts	0x03ED, r25
    17ec:	89 2f       	mov	r24, r25
    17ee:	90 e0       	ldi	r25, 0x00	; 0
    17f0:	fc 01       	movw	r30, r24
    17f2:	63 e0       	ldi	r22, 0x03	; 3
    17f4:	ee 0f       	add	r30, r30
    17f6:	ff 1f       	adc	r31, r31
    17f8:	6a 95       	dec	r22
    17fa:	e1 f7       	brne	.-8      	; 0x17f4 <xTaskRemoveFromEventList+0xb6>
    17fc:	e8 0f       	add	r30, r24
    17fe:	f9 1f       	adc	r31, r25
    1800:	e4 50       	subi	r30, 0x04	; 4
    1802:	fc 4f       	sbci	r31, 0xFC	; 252
    1804:	a1 81       	ldd	r26, Z+1	; 0x01
    1806:	b2 81       	ldd	r27, Z+2	; 0x02
    1808:	bd 83       	std	Y+5, r27	; 0x05
    180a:	ac 83       	std	Y+4, r26	; 0x04
    180c:	14 96       	adiw	r26, 0x04	; 4
    180e:	8d 91       	ld	r24, X+
    1810:	9c 91       	ld	r25, X
    1812:	15 97       	sbiw	r26, 0x05	; 5
    1814:	9f 83       	std	Y+7, r25	; 0x07
    1816:	8e 83       	std	Y+6, r24	; 0x06
    1818:	14 96       	adiw	r26, 0x04	; 4
    181a:	ed 91       	ld	r30, X+
    181c:	fc 91       	ld	r31, X
    181e:	15 97       	sbiw	r26, 0x05	; 5
    1820:	53 83       	std	Z+3, r21	; 0x03
    1822:	42 83       	std	Z+2, r20	; 0x02
    1824:	15 96       	adiw	r26, 0x05	; 5
    1826:	5c 93       	st	X, r21
    1828:	4e 93       	st	-X, r20
    182a:	14 97       	sbiw	r26, 0x04	; 4
    182c:	ee 89       	ldd	r30, Y+22	; 0x16
    182e:	89 e0       	ldi	r24, 0x09	; 9
    1830:	e8 9f       	mul	r30, r24
    1832:	f0 01       	movw	r30, r0
    1834:	11 24       	eor	r1, r1
    1836:	e4 50       	subi	r30, 0x04	; 4
    1838:	fc 4f       	sbci	r31, 0xFC	; 252
    183a:	fb 87       	std	Y+11, r31	; 0x0b
    183c:	ea 87       	std	Y+10, r30	; 0x0a
    183e:	80 81       	ld	r24, Z
    1840:	8f 5f       	subi	r24, 0xFF	; 255
    1842:	80 83       	st	Z, r24
    1844:	1f c0       	rjmp	.+62     	; 0x1884 <xTaskRemoveFromEventList+0x146>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1846:	a0 91 40 04 	lds	r26, 0x0440
    184a:	b0 91 41 04 	lds	r27, 0x0441
    184e:	bf 87       	std	Y+15, r27	; 0x0f
    1850:	ae 87       	std	Y+14, r26	; 0x0e
    1852:	14 96       	adiw	r26, 0x04	; 4
    1854:	8d 91       	ld	r24, X+
    1856:	9c 91       	ld	r25, X
    1858:	15 97       	sbiw	r26, 0x05	; 5
    185a:	99 8b       	std	Y+17, r25	; 0x11
    185c:	88 8b       	std	Y+16, r24	; 0x10
    185e:	14 96       	adiw	r26, 0x04	; 4
    1860:	ed 91       	ld	r30, X+
    1862:	fc 91       	ld	r31, X
    1864:	15 97       	sbiw	r26, 0x05	; 5
    1866:	53 83       	std	Z+3, r21	; 0x03
    1868:	42 83       	std	Z+2, r20	; 0x02
    186a:	15 96       	adiw	r26, 0x05	; 5
    186c:	5c 93       	st	X, r21
    186e:	4e 93       	st	-X, r20
    1870:	14 97       	sbiw	r26, 0x04	; 4
    1872:	8f e3       	ldi	r24, 0x3F	; 63
    1874:	94 e0       	ldi	r25, 0x04	; 4
    1876:	9d 8b       	std	Y+21, r25	; 0x15
    1878:	8c 8b       	std	Y+20, r24	; 0x14
    187a:	80 91 3f 04 	lds	r24, 0x043F
    187e:	8f 5f       	subi	r24, 0xFF	; 255
    1880:	80 93 3f 04 	sts	0x043F, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1884:	e0 91 ea 03 	lds	r30, 0x03EA
    1888:	f0 91 eb 03 	lds	r31, 0x03EB
    188c:	9e 89       	ldd	r25, Y+22	; 0x16
    188e:	86 89       	ldd	r24, Z+22	; 0x16
    1890:	89 17       	cp	r24, r25
    1892:	10 f0       	brcs	.+4      	; 0x1898 <xTaskRemoveFromEventList+0x15a>
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	03 c0       	rjmp	.+6      	; 0x189e <xTaskRemoveFromEventList+0x160>
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	80 93 ee 03 	sts	0x03EE, r24
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    189e:	df 91       	pop	r29
    18a0:	cf 91       	pop	r28
    18a2:	08 95       	ret

000018a4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    18a4:	cf 93       	push	r28
    18a6:	df 93       	push	r29
    18a8:	dc 01       	movw	r26, r24
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    18aa:	70 68       	ori	r23, 0x80	; 128
    18ac:	11 96       	adiw	r26, 0x01	; 1
    18ae:	7c 93       	st	X, r23
    18b0:	6e 93       	st	-X, r22

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    18b2:	16 96       	adiw	r26, 0x06	; 6
    18b4:	2d 91       	ld	r18, X+
    18b6:	3c 91       	ld	r19, X
    18b8:	17 97       	sbiw	r26, 0x07	; 7
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    18ba:	18 96       	adiw	r26, 0x08	; 8
    18bc:	cd 91       	ld	r28, X+
    18be:	dc 91       	ld	r29, X
    18c0:	19 97       	sbiw	r26, 0x09	; 9
    18c2:	12 96       	adiw	r26, 0x02	; 2
    18c4:	6d 91       	ld	r22, X+
    18c6:	7c 91       	ld	r23, X
    18c8:	13 97       	sbiw	r26, 0x03	; 3
    18ca:	14 96       	adiw	r26, 0x04	; 4
    18cc:	8d 91       	ld	r24, X+
    18ce:	9c 91       	ld	r25, X
    18d0:	15 97       	sbiw	r26, 0x05	; 5
    18d2:	fb 01       	movw	r30, r22
    18d4:	95 83       	std	Z+5, r25	; 0x05
    18d6:	84 83       	std	Z+4, r24	; 0x04
    18d8:	14 96       	adiw	r26, 0x04	; 4
    18da:	4d 91       	ld	r20, X+
    18dc:	5c 91       	ld	r21, X
    18de:	15 97       	sbiw	r26, 0x05	; 5
    18e0:	fa 01       	movw	r30, r20
    18e2:	73 83       	std	Z+3, r23	; 0x03
    18e4:	62 83       	std	Z+2, r22	; 0x02
    18e6:	89 81       	ldd	r24, Y+1	; 0x01
    18e8:	9a 81       	ldd	r25, Y+2	; 0x02
    18ea:	8a 17       	cp	r24, r26
    18ec:	9b 07       	cpc	r25, r27
    18ee:	11 f4       	brne	.+4      	; 0x18f4 <vTaskRemoveFromUnorderedEventList+0x50>
    18f0:	5a 83       	std	Y+2, r21	; 0x02
    18f2:	49 83       	std	Y+1, r20	; 0x01
    18f4:	19 96       	adiw	r26, 0x09	; 9
    18f6:	1c 92       	st	X, r1
    18f8:	1e 92       	st	-X, r1
    18fa:	18 97       	sbiw	r26, 0x08	; 8
    18fc:	88 81       	ld	r24, Y
    18fe:	81 50       	subi	r24, 0x01	; 1
    1900:	88 83       	st	Y, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    1902:	e9 01       	movw	r28, r18
    1904:	aa 85       	ldd	r26, Y+10	; 0x0a
    1906:	bb 85       	ldd	r27, Y+11	; 0x0b
    1908:	4c 81       	ldd	r20, Y+4	; 0x04
    190a:	5d 81       	ldd	r21, Y+5	; 0x05
    190c:	8e 81       	ldd	r24, Y+6	; 0x06
    190e:	9f 81       	ldd	r25, Y+7	; 0x07
    1910:	fa 01       	movw	r30, r20
    1912:	95 83       	std	Z+5, r25	; 0x05
    1914:	84 83       	std	Z+4, r24	; 0x04
    1916:	0e 80       	ldd	r0, Y+6	; 0x06
    1918:	df 81       	ldd	r29, Y+7	; 0x07
    191a:	c0 2d       	mov	r28, r0
    191c:	5b 83       	std	Y+3, r21	; 0x03
    191e:	4a 83       	std	Y+2, r20	; 0x02
    1920:	a9 01       	movw	r20, r18
    1922:	4e 5f       	subi	r20, 0xFE	; 254
    1924:	5f 4f       	sbci	r21, 0xFF	; 255
    1926:	11 96       	adiw	r26, 0x01	; 1
    1928:	8d 91       	ld	r24, X+
    192a:	9c 91       	ld	r25, X
    192c:	12 97       	sbiw	r26, 0x02	; 2
    192e:	84 17       	cp	r24, r20
    1930:	95 07       	cpc	r25, r21
    1932:	21 f4       	brne	.+8      	; 0x193c <vTaskRemoveFromUnorderedEventList+0x98>
    1934:	12 96       	adiw	r26, 0x02	; 2
    1936:	dc 93       	st	X, r29
    1938:	ce 93       	st	-X, r28
    193a:	11 97       	sbiw	r26, 0x01	; 1
    193c:	e9 01       	movw	r28, r18
    193e:	1b 86       	std	Y+11, r1	; 0x0b
    1940:	1a 86       	std	Y+10, r1	; 0x0a
    1942:	8c 91       	ld	r24, X
    1944:	81 50       	subi	r24, 0x01	; 1
    1946:	8c 93       	st	X, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    1948:	9e 89       	ldd	r25, Y+22	; 0x16
    194a:	80 91 ed 03 	lds	r24, 0x03ED
    194e:	89 17       	cp	r24, r25
    1950:	10 f4       	brcc	.+4      	; 0x1956 <vTaskRemoveFromUnorderedEventList+0xb2>
    1952:	90 93 ed 03 	sts	0x03ED, r25
    1956:	89 2f       	mov	r24, r25
    1958:	90 e0       	ldi	r25, 0x00	; 0
    195a:	fc 01       	movw	r30, r24
    195c:	73 e0       	ldi	r23, 0x03	; 3
    195e:	ee 0f       	add	r30, r30
    1960:	ff 1f       	adc	r31, r31
    1962:	7a 95       	dec	r23
    1964:	e1 f7       	brne	.-8      	; 0x195e <vTaskRemoveFromUnorderedEventList+0xba>
    1966:	e8 0f       	add	r30, r24
    1968:	f9 1f       	adc	r31, r25
    196a:	e4 50       	subi	r30, 0x04	; 4
    196c:	fc 4f       	sbci	r31, 0xFC	; 252
    196e:	a1 81       	ldd	r26, Z+1	; 0x01
    1970:	b2 81       	ldd	r27, Z+2	; 0x02
    1972:	f9 01       	movw	r30, r18
    1974:	b5 83       	std	Z+5, r27	; 0x05
    1976:	a4 83       	std	Z+4, r26	; 0x04
    1978:	14 96       	adiw	r26, 0x04	; 4
    197a:	8d 91       	ld	r24, X+
    197c:	9c 91       	ld	r25, X
    197e:	15 97       	sbiw	r26, 0x05	; 5
    1980:	97 83       	std	Z+7, r25	; 0x07
    1982:	86 83       	std	Z+6, r24	; 0x06
    1984:	14 96       	adiw	r26, 0x04	; 4
    1986:	ed 91       	ld	r30, X+
    1988:	fc 91       	ld	r31, X
    198a:	15 97       	sbiw	r26, 0x05	; 5
    198c:	53 83       	std	Z+3, r21	; 0x03
    198e:	42 83       	std	Z+2, r20	; 0x02
    1990:	15 96       	adiw	r26, 0x05	; 5
    1992:	5c 93       	st	X, r21
    1994:	4e 93       	st	-X, r20
    1996:	14 97       	sbiw	r26, 0x04	; 4
    1998:	d9 01       	movw	r26, r18
    199a:	56 96       	adiw	r26, 0x16	; 22
    199c:	ec 91       	ld	r30, X
    199e:	56 97       	sbiw	r26, 0x16	; 22
    19a0:	89 e0       	ldi	r24, 0x09	; 9
    19a2:	e8 9f       	mul	r30, r24
    19a4:	f0 01       	movw	r30, r0
    19a6:	11 24       	eor	r1, r1
    19a8:	e4 50       	subi	r30, 0x04	; 4
    19aa:	fc 4f       	sbci	r31, 0xFC	; 252
    19ac:	1b 96       	adiw	r26, 0x0b	; 11
    19ae:	fc 93       	st	X, r31
    19b0:	ee 93       	st	-X, r30
    19b2:	1a 97       	sbiw	r26, 0x0a	; 10
    19b4:	80 81       	ld	r24, Z
    19b6:	8f 5f       	subi	r24, 0xFF	; 255
    19b8:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    19ba:	e0 91 ea 03 	lds	r30, 0x03EA
    19be:	f0 91 eb 03 	lds	r31, 0x03EB
    19c2:	56 96       	adiw	r26, 0x16	; 22
    19c4:	9c 91       	ld	r25, X
    19c6:	86 89       	ldd	r24, Z+22	; 0x16
    19c8:	89 17       	cp	r24, r25
    19ca:	18 f4       	brcc	.+6      	; 0x19d2 <vTaskRemoveFromUnorderedEventList+0x12e>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	80 93 ee 03 	sts	0x03EE, r24
    }
}
    19d2:	df 91       	pop	r29
    19d4:	cf 91       	pop	r28
    19d6:	08 95       	ret

000019d8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    19d8:	fc 01       	movw	r30, r24
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    19da:	0f b6       	in	r0, 0x3f	; 63
    19dc:	f8 94       	cli
    19de:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    19e0:	80 91 f3 03 	lds	r24, 0x03F3
    19e4:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    19e6:	80 91 ef 03 	lds	r24, 0x03EF
    19ea:	90 91 f0 03 	lds	r25, 0x03F0
    19ee:	92 83       	std	Z+2, r25	; 0x02
    19f0:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    19f2:	0f 90       	pop	r0
    19f4:	0f be       	out	0x3f, r0	; 63
}
    19f6:	08 95       	ret

000019f8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    19f8:	fc 01       	movw	r30, r24
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    19fa:	80 91 f3 03 	lds	r24, 0x03F3
    19fe:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    1a00:	80 91 ef 03 	lds	r24, 0x03EF
    1a04:	90 91 f0 03 	lds	r25, 0x03F0
    1a08:	92 83       	std	Z+2, r25	; 0x02
    1a0a:	81 83       	std	Z+1, r24	; 0x01
}
    1a0c:	08 95       	ret

00001a0e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    1a0e:	dc 01       	movw	r26, r24
    1a10:	fb 01       	movw	r30, r22
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    1a12:	0f b6       	in	r0, 0x3f	; 63
    1a14:	f8 94       	cli
    1a16:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    1a18:	40 91 ef 03 	lds	r20, 0x03EF
    1a1c:	50 91 f0 03 	lds	r21, 0x03F0
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1a20:	11 96       	adiw	r26, 0x01	; 1
    1a22:	2d 91       	ld	r18, X+
    1a24:	3c 91       	ld	r19, X
    1a26:	12 97       	sbiw	r26, 0x02	; 2
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1a28:	90 91 f3 03 	lds	r25, 0x03F3
    1a2c:	8c 91       	ld	r24, X
    1a2e:	98 17       	cp	r25, r24
    1a30:	19 f0       	breq	.+6      	; 0x1a38 <xTaskCheckForTimeOut+0x2a>
    1a32:	42 17       	cp	r20, r18
    1a34:	53 07       	cpc	r21, r19
    1a36:	d0 f4       	brcc	.+52     	; 0x1a6c <xTaskCheckForTimeOut+0x5e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1a38:	ca 01       	movw	r24, r20
    1a3a:	82 1b       	sub	r24, r18
    1a3c:	93 0b       	sbc	r25, r19
    1a3e:	9c 01       	movw	r18, r24
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1a40:	80 81       	ld	r24, Z
    1a42:	91 81       	ldd	r25, Z+1	; 0x01
    1a44:	28 17       	cp	r18, r24
    1a46:	39 07       	cpc	r19, r25
    1a48:	88 f4       	brcc	.+34     	; 0x1a6c <xTaskCheckForTimeOut+0x5e>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    1a4a:	82 1b       	sub	r24, r18
    1a4c:	93 0b       	sbc	r25, r19
    1a4e:	91 83       	std	Z+1, r25	; 0x01
    1a50:	80 83       	st	Z, r24
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    1a52:	80 91 f3 03 	lds	r24, 0x03F3
    1a56:	8c 93       	st	X, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    1a58:	80 91 ef 03 	lds	r24, 0x03EF
    1a5c:	90 91 f0 03 	lds	r25, 0x03F0
    1a60:	12 96       	adiw	r26, 0x02	; 2
    1a62:	9c 93       	st	X, r25
    1a64:	8e 93       	st	-X, r24
    1a66:	11 97       	sbiw	r26, 0x01	; 1
    1a68:	80 e0       	ldi	r24, 0x00	; 0
    1a6a:	03 c0       	rjmp	.+6      	; 0x1a72 <xTaskCheckForTimeOut+0x64>
            vTaskInternalSetTimeOutState( pxTimeOut );
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    1a6c:	11 82       	std	Z+1, r1	; 0x01
    1a6e:	10 82       	st	Z, r1
    1a70:	81 e0       	ldi	r24, 0x01	; 1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    1a72:	0f 90       	pop	r0
    1a74:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    1a76:	08 95       	ret

00001a78 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	80 93 ee 03 	sts	0x03EE, r24
}
    1a7e:	08 95       	ret

00001a80 <xTaskGetCurrentTaskHandle>:
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    1a80:	20 91 ea 03 	lds	r18, 0x03EA
    1a84:	30 91 eb 03 	lds	r19, 0x03EB

        return xReturn;
    }
    1a88:	c9 01       	movw	r24, r18
    1a8a:	08 95       	ret

00001a8c <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1a8c:	e0 91 ea 03 	lds	r30, 0x03EA
    1a90:	f0 91 eb 03 	lds	r31, 0x03EB
    1a94:	84 85       	ldd	r24, Z+12	; 0x0c
    1a96:	95 85       	ldd	r25, Z+13	; 0x0d

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a98:	a0 91 ea 03 	lds	r26, 0x03EA
    1a9c:	b0 91 eb 03 	lds	r27, 0x03EB
    1aa0:	e0 91 ea 03 	lds	r30, 0x03EA
    1aa4:	f0 91 eb 03 	lds	r31, 0x03EB
    1aa8:	46 89       	ldd	r20, Z+22	; 0x16
    1aaa:	25 e0       	ldi	r18, 0x05	; 5
    1aac:	30 e0       	ldi	r19, 0x00	; 0
    1aae:	24 1b       	sub	r18, r20
    1ab0:	31 09       	sbc	r19, r1
    1ab2:	1d 96       	adiw	r26, 0x0d	; 13
    1ab4:	3c 93       	st	X, r19
    1ab6:	2e 93       	st	-X, r18
    1ab8:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
}
    1aba:	08 95       	ret

00001abc <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    1abc:	cf 92       	push	r12
    1abe:	df 92       	push	r13
    1ac0:	ef 92       	push	r14
    1ac2:	ff 92       	push	r15
    1ac4:	0f 93       	push	r16
    1ac6:	cf 93       	push	r28
    1ac8:	df 93       	push	r29
    1aca:	ec 01       	movw	r28, r24

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
    1acc:	e1 14       	cp	r14, r1
    1ace:	f1 04       	cpc	r15, r1
    1ad0:	89 f0       	breq	.+34     	; 0x1af4 <xTaskGenericNotifyFromISR+0x38>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    1ad2:	e6 2f       	mov	r30, r22
    1ad4:	f0 e0       	ldi	r31, 0x00	; 0
    1ad6:	ee 0f       	add	r30, r30
    1ad8:	ff 1f       	adc	r31, r31
    1ada:	ee 0f       	add	r30, r30
    1adc:	ff 1f       	adc	r31, r31
    1ade:	e8 0f       	add	r30, r24
    1ae0:	f9 1f       	adc	r31, r25
    1ae2:	81 a1       	ldd	r24, Z+33	; 0x21
    1ae4:	92 a1       	ldd	r25, Z+34	; 0x22
    1ae6:	a3 a1       	ldd	r26, Z+35	; 0x23
    1ae8:	b4 a1       	ldd	r27, Z+36	; 0x24
    1aea:	f7 01       	movw	r30, r14
    1aec:	80 83       	st	Z, r24
    1aee:	91 83       	std	Z+1, r25	; 0x01
    1af0:	a2 83       	std	Z+2, r26	; 0x02
    1af2:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1af4:	a6 2f       	mov	r26, r22
    1af6:	b0 e0       	ldi	r27, 0x00	; 0
    1af8:	fe 01       	movw	r30, r28
    1afa:	ea 0f       	add	r30, r26
    1afc:	fb 1f       	adc	r31, r27
    1afe:	65 a1       	ldd	r22, Z+37	; 0x25
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1b00:	82 e0       	ldi	r24, 0x02	; 2
    1b02:	85 a3       	std	Z+37, r24	; 0x25

            switch( eAction )
    1b04:	02 30       	cpi	r16, 0x02	; 2
    1b06:	d1 f0       	breq	.+52     	; 0x1b3c <xTaskGenericNotifyFromISR+0x80>
    1b08:	03 30       	cpi	r16, 0x03	; 3
    1b0a:	18 f4       	brcc	.+6      	; 0x1b12 <xTaskGenericNotifyFromISR+0x56>
    1b0c:	01 30       	cpi	r16, 0x01	; 1
    1b0e:	c9 f5       	brne	.+114    	; 0x1b82 <xTaskGenericNotifyFromISR+0xc6>
    1b10:	05 c0       	rjmp	.+10     	; 0x1b1c <xTaskGenericNotifyFromISR+0x60>
    1b12:	03 30       	cpi	r16, 0x03	; 3
    1b14:	51 f1       	breq	.+84     	; 0x1b6a <xTaskGenericNotifyFromISR+0xae>
    1b16:	04 30       	cpi	r16, 0x04	; 4
    1b18:	a1 f5       	brne	.+104    	; 0x1b82 <xTaskGenericNotifyFromISR+0xc6>
    1b1a:	23 c0       	rjmp	.+70     	; 0x1b62 <xTaskGenericNotifyFromISR+0xa6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1b1c:	fd 01       	movw	r30, r26
    1b1e:	ee 0f       	add	r30, r30
    1b20:	ff 1f       	adc	r31, r31
    1b22:	ee 0f       	add	r30, r30
    1b24:	ff 1f       	adc	r31, r31
    1b26:	ec 0f       	add	r30, r28
    1b28:	fd 1f       	adc	r31, r29
    1b2a:	81 a1       	ldd	r24, Z+33	; 0x21
    1b2c:	92 a1       	ldd	r25, Z+34	; 0x22
    1b2e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1b30:	b4 a1       	ldd	r27, Z+36	; 0x24
    1b32:	82 2b       	or	r24, r18
    1b34:	93 2b       	or	r25, r19
    1b36:	a4 2b       	or	r26, r20
    1b38:	b5 2b       	or	r27, r21
    1b3a:	0e c0       	rjmp	.+28     	; 0x1b58 <xTaskGenericNotifyFromISR+0x9c>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1b3c:	fd 01       	movw	r30, r26
    1b3e:	ee 0f       	add	r30, r30
    1b40:	ff 1f       	adc	r31, r31
    1b42:	ee 0f       	add	r30, r30
    1b44:	ff 1f       	adc	r31, r31
    1b46:	ec 0f       	add	r30, r28
    1b48:	fd 1f       	adc	r31, r29
    1b4a:	81 a1       	ldd	r24, Z+33	; 0x21
    1b4c:	92 a1       	ldd	r25, Z+34	; 0x22
    1b4e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1b50:	b4 a1       	ldd	r27, Z+36	; 0x24
    1b52:	01 96       	adiw	r24, 0x01	; 1
    1b54:	a1 1d       	adc	r26, r1
    1b56:	b1 1d       	adc	r27, r1
    1b58:	81 a3       	std	Z+33, r24	; 0x21
    1b5a:	92 a3       	std	Z+34, r25	; 0x22
    1b5c:	a3 a3       	std	Z+35, r26	; 0x23
    1b5e:	b4 a3       	std	Z+36, r27	; 0x24
    1b60:	10 c0       	rjmp	.+32     	; 0x1b82 <xTaskGenericNotifyFromISR+0xc6>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1b62:	62 30       	cpi	r22, 0x02	; 2
    1b64:	11 f4       	brne	.+4      	; 0x1b6a <xTaskGenericNotifyFromISR+0xae>
    1b66:	80 e0       	ldi	r24, 0x00	; 0
    1b68:	9d c0       	rjmp	.+314    	; 0x1ca4 <xTaskGenericNotifyFromISR+0x1e8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    1b6a:	aa 0f       	add	r26, r26
    1b6c:	bb 1f       	adc	r27, r27
    1b6e:	aa 0f       	add	r26, r26
    1b70:	bb 1f       	adc	r27, r27
    1b72:	ac 0f       	add	r26, r28
    1b74:	bd 1f       	adc	r27, r29
    1b76:	91 96       	adiw	r26, 0x21	; 33
    1b78:	2d 93       	st	X+, r18
    1b7a:	3d 93       	st	X+, r19
    1b7c:	4d 93       	st	X+, r20
    1b7e:	5c 93       	st	X, r21
    1b80:	94 97       	sbiw	r26, 0x24	; 36

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1b82:	61 30       	cpi	r22, 0x01	; 1
    1b84:	09 f0       	breq	.+2      	; 0x1b88 <xTaskGenericNotifyFromISR+0xcc>
    1b86:	8d c0       	rjmp	.+282    	; 0x1ca2 <xTaskGenericNotifyFromISR+0x1e6>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1b88:	80 91 ec 03 	lds	r24, 0x03EC
    1b8c:	88 23       	and	r24, r24
    1b8e:	09 f0       	breq	.+2      	; 0x1b92 <xTaskGenericNotifyFromISR+0xd6>
    1b90:	55 c0       	rjmp	.+170    	; 0x1c3c <xTaskGenericNotifyFromISR+0x180>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1b92:	aa 85       	ldd	r26, Y+10	; 0x0a
    1b94:	bb 85       	ldd	r27, Y+11	; 0x0b
    1b96:	4c 81       	ldd	r20, Y+4	; 0x04
    1b98:	5d 81       	ldd	r21, Y+5	; 0x05
    1b9a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b9c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b9e:	fa 01       	movw	r30, r20
    1ba0:	95 83       	std	Z+5, r25	; 0x05
    1ba2:	84 83       	std	Z+4, r24	; 0x04
    1ba4:	2e 81       	ldd	r18, Y+6	; 0x06
    1ba6:	3f 81       	ldd	r19, Y+7	; 0x07
    1ba8:	f9 01       	movw	r30, r18
    1baa:	53 83       	std	Z+3, r21	; 0x03
    1bac:	42 83       	std	Z+2, r20	; 0x02
    1bae:	ae 01       	movw	r20, r28
    1bb0:	4e 5f       	subi	r20, 0xFE	; 254
    1bb2:	5f 4f       	sbci	r21, 0xFF	; 255
    1bb4:	11 96       	adiw	r26, 0x01	; 1
    1bb6:	8d 91       	ld	r24, X+
    1bb8:	9c 91       	ld	r25, X
    1bba:	12 97       	sbiw	r26, 0x02	; 2
    1bbc:	84 17       	cp	r24, r20
    1bbe:	95 07       	cpc	r25, r21
    1bc0:	21 f4       	brne	.+8      	; 0x1bca <xTaskGenericNotifyFromISR+0x10e>
    1bc2:	12 96       	adiw	r26, 0x02	; 2
    1bc4:	3c 93       	st	X, r19
    1bc6:	2e 93       	st	-X, r18
    1bc8:	11 97       	sbiw	r26, 0x01	; 1
    1bca:	1b 86       	std	Y+11, r1	; 0x0b
    1bcc:	1a 86       	std	Y+10, r1	; 0x0a
    1bce:	8c 91       	ld	r24, X
    1bd0:	81 50       	subi	r24, 0x01	; 1
    1bd2:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    1bd4:	9e 89       	ldd	r25, Y+22	; 0x16
    1bd6:	80 91 ed 03 	lds	r24, 0x03ED
    1bda:	89 17       	cp	r24, r25
    1bdc:	10 f4       	brcc	.+4      	; 0x1be2 <xTaskGenericNotifyFromISR+0x126>
    1bde:	90 93 ed 03 	sts	0x03ED, r25
    1be2:	89 2f       	mov	r24, r25
    1be4:	90 e0       	ldi	r25, 0x00	; 0
    1be6:	fc 01       	movw	r30, r24
    1be8:	a3 e0       	ldi	r26, 0x03	; 3
    1bea:	ee 0f       	add	r30, r30
    1bec:	ff 1f       	adc	r31, r31
    1bee:	aa 95       	dec	r26
    1bf0:	e1 f7       	brne	.-8      	; 0x1bea <xTaskGenericNotifyFromISR+0x12e>
    1bf2:	e8 0f       	add	r30, r24
    1bf4:	f9 1f       	adc	r31, r25
    1bf6:	e4 50       	subi	r30, 0x04	; 4
    1bf8:	fc 4f       	sbci	r31, 0xFC	; 252
    1bfa:	a1 81       	ldd	r26, Z+1	; 0x01
    1bfc:	b2 81       	ldd	r27, Z+2	; 0x02
    1bfe:	bd 83       	std	Y+5, r27	; 0x05
    1c00:	ac 83       	std	Y+4, r26	; 0x04
    1c02:	14 96       	adiw	r26, 0x04	; 4
    1c04:	8d 91       	ld	r24, X+
    1c06:	9c 91       	ld	r25, X
    1c08:	15 97       	sbiw	r26, 0x05	; 5
    1c0a:	9f 83       	std	Y+7, r25	; 0x07
    1c0c:	8e 83       	std	Y+6, r24	; 0x06
    1c0e:	14 96       	adiw	r26, 0x04	; 4
    1c10:	ed 91       	ld	r30, X+
    1c12:	fc 91       	ld	r31, X
    1c14:	15 97       	sbiw	r26, 0x05	; 5
    1c16:	53 83       	std	Z+3, r21	; 0x03
    1c18:	42 83       	std	Z+2, r20	; 0x02
    1c1a:	15 96       	adiw	r26, 0x05	; 5
    1c1c:	5c 93       	st	X, r21
    1c1e:	4e 93       	st	-X, r20
    1c20:	14 97       	sbiw	r26, 0x04	; 4
    1c22:	ee 89       	ldd	r30, Y+22	; 0x16
    1c24:	89 e0       	ldi	r24, 0x09	; 9
    1c26:	e8 9f       	mul	r30, r24
    1c28:	f0 01       	movw	r30, r0
    1c2a:	11 24       	eor	r1, r1
    1c2c:	e4 50       	subi	r30, 0x04	; 4
    1c2e:	fc 4f       	sbci	r31, 0xFC	; 252
    1c30:	fb 87       	std	Y+11, r31	; 0x0b
    1c32:	ea 87       	std	Y+10, r30	; 0x0a
    1c34:	80 81       	ld	r24, Z
    1c36:	8f 5f       	subi	r24, 0xFF	; 255
    1c38:	80 83       	st	Z, r24
    1c3a:	21 c0       	rjmp	.+66     	; 0x1c7e <xTaskGenericNotifyFromISR+0x1c2>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1c3c:	a0 91 40 04 	lds	r26, 0x0440
    1c40:	b0 91 41 04 	lds	r27, 0x0441
    1c44:	bf 87       	std	Y+15, r27	; 0x0f
    1c46:	ae 87       	std	Y+14, r26	; 0x0e
    1c48:	14 96       	adiw	r26, 0x04	; 4
    1c4a:	8d 91       	ld	r24, X+
    1c4c:	9c 91       	ld	r25, X
    1c4e:	15 97       	sbiw	r26, 0x05	; 5
    1c50:	99 8b       	std	Y+17, r25	; 0x11
    1c52:	88 8b       	std	Y+16, r24	; 0x10
    1c54:	ce 01       	movw	r24, r28
    1c56:	0c 96       	adiw	r24, 0x0c	; 12
    1c58:	14 96       	adiw	r26, 0x04	; 4
    1c5a:	ed 91       	ld	r30, X+
    1c5c:	fc 91       	ld	r31, X
    1c5e:	15 97       	sbiw	r26, 0x05	; 5
    1c60:	93 83       	std	Z+3, r25	; 0x03
    1c62:	82 83       	std	Z+2, r24	; 0x02
    1c64:	15 96       	adiw	r26, 0x05	; 5
    1c66:	9c 93       	st	X, r25
    1c68:	8e 93       	st	-X, r24
    1c6a:	14 97       	sbiw	r26, 0x04	; 4
    1c6c:	8f e3       	ldi	r24, 0x3F	; 63
    1c6e:	94 e0       	ldi	r25, 0x04	; 4
    1c70:	9d 8b       	std	Y+21, r25	; 0x15
    1c72:	8c 8b       	std	Y+20, r24	; 0x14
    1c74:	80 91 3f 04 	lds	r24, 0x043F
    1c78:	8f 5f       	subi	r24, 0xFF	; 255
    1c7a:	80 93 3f 04 	sts	0x043F, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1c7e:	e0 91 ea 03 	lds	r30, 0x03EA
    1c82:	f0 91 eb 03 	lds	r31, 0x03EB
    1c86:	9e 89       	ldd	r25, Y+22	; 0x16
    1c88:	86 89       	ldd	r24, Z+22	; 0x16
    1c8a:	89 17       	cp	r24, r25
    1c8c:	50 f4       	brcc	.+20     	; 0x1ca2 <xTaskGenericNotifyFromISR+0x1e6>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    1c8e:	c1 14       	cp	r12, r1
    1c90:	d1 04       	cpc	r13, r1
    1c92:	19 f0       	breq	.+6      	; 0x1c9a <xTaskGenericNotifyFromISR+0x1de>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    1c94:	81 e0       	ldi	r24, 0x01	; 1
    1c96:	f6 01       	movw	r30, r12
    1c98:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    1c9a:	81 e0       	ldi	r24, 0x01	; 1
    1c9c:	80 93 ee 03 	sts	0x03EE, r24
    1ca0:	01 c0       	rjmp	.+2      	; 0x1ca4 <xTaskGenericNotifyFromISR+0x1e8>
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }
    1ca4:	df 91       	pop	r29
    1ca6:	cf 91       	pop	r28
    1ca8:	0f 91       	pop	r16
    1caa:	ff 90       	pop	r15
    1cac:	ef 90       	pop	r14
    1cae:	df 90       	pop	r13
    1cb0:	cf 90       	pop	r12
    1cb2:	08 95       	ret

00001cb4 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    1cb4:	cf 93       	push	r28
    1cb6:	df 93       	push	r29
    1cb8:	ec 01       	movw	r28, r24
    1cba:	e6 2f       	mov	r30, r22
    1cbc:	ba 01       	movw	r22, r20

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1cbe:	f0 e0       	ldi	r31, 0x00	; 0
    1cc0:	dc 01       	movw	r26, r24
    1cc2:	ae 0f       	add	r26, r30
    1cc4:	bf 1f       	adc	r27, r31
    1cc6:	95 96       	adiw	r26, 0x25	; 37
    1cc8:	2c 91       	ld	r18, X
    1cca:	95 97       	sbiw	r26, 0x25	; 37
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1ccc:	82 e0       	ldi	r24, 0x02	; 2
    1cce:	95 96       	adiw	r26, 0x25	; 37
    1cd0:	8c 93       	st	X, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1cd2:	ee 0f       	add	r30, r30
    1cd4:	ff 1f       	adc	r31, r31
    1cd6:	ee 0f       	add	r30, r30
    1cd8:	ff 1f       	adc	r31, r31
    1cda:	ec 0f       	add	r30, r28
    1cdc:	fd 1f       	adc	r31, r29
    1cde:	81 a1       	ldd	r24, Z+33	; 0x21
    1ce0:	92 a1       	ldd	r25, Z+34	; 0x22
    1ce2:	a3 a1       	ldd	r26, Z+35	; 0x23
    1ce4:	b4 a1       	ldd	r27, Z+36	; 0x24
    1ce6:	01 96       	adiw	r24, 0x01	; 1
    1ce8:	a1 1d       	adc	r26, r1
    1cea:	b1 1d       	adc	r27, r1
    1cec:	81 a3       	std	Z+33, r24	; 0x21
    1cee:	92 a3       	std	Z+34, r25	; 0x22
    1cf0:	a3 a3       	std	Z+35, r26	; 0x23
    1cf2:	b4 a3       	std	Z+36, r27	; 0x24

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1cf4:	21 30       	cpi	r18, 0x01	; 1
    1cf6:	09 f0       	breq	.+2      	; 0x1cfa <vTaskGenericNotifyGiveFromISR+0x46>
    1cf8:	8c c0       	rjmp	.+280    	; 0x1e12 <vTaskGenericNotifyGiveFromISR+0x15e>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1cfa:	80 91 ec 03 	lds	r24, 0x03EC
    1cfe:	88 23       	and	r24, r24
    1d00:	09 f0       	breq	.+2      	; 0x1d04 <vTaskGenericNotifyGiveFromISR+0x50>
    1d02:	55 c0       	rjmp	.+170    	; 0x1dae <vTaskGenericNotifyGiveFromISR+0xfa>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1d04:	aa 85       	ldd	r26, Y+10	; 0x0a
    1d06:	bb 85       	ldd	r27, Y+11	; 0x0b
    1d08:	4c 81       	ldd	r20, Y+4	; 0x04
    1d0a:	5d 81       	ldd	r21, Y+5	; 0x05
    1d0c:	8e 81       	ldd	r24, Y+6	; 0x06
    1d0e:	9f 81       	ldd	r25, Y+7	; 0x07
    1d10:	fa 01       	movw	r30, r20
    1d12:	95 83       	std	Z+5, r25	; 0x05
    1d14:	84 83       	std	Z+4, r24	; 0x04
    1d16:	2e 81       	ldd	r18, Y+6	; 0x06
    1d18:	3f 81       	ldd	r19, Y+7	; 0x07
    1d1a:	f9 01       	movw	r30, r18
    1d1c:	53 83       	std	Z+3, r21	; 0x03
    1d1e:	42 83       	std	Z+2, r20	; 0x02
    1d20:	ae 01       	movw	r20, r28
    1d22:	4e 5f       	subi	r20, 0xFE	; 254
    1d24:	5f 4f       	sbci	r21, 0xFF	; 255
    1d26:	11 96       	adiw	r26, 0x01	; 1
    1d28:	8d 91       	ld	r24, X+
    1d2a:	9c 91       	ld	r25, X
    1d2c:	12 97       	sbiw	r26, 0x02	; 2
    1d2e:	84 17       	cp	r24, r20
    1d30:	95 07       	cpc	r25, r21
    1d32:	21 f4       	brne	.+8      	; 0x1d3c <vTaskGenericNotifyGiveFromISR+0x88>
    1d34:	12 96       	adiw	r26, 0x02	; 2
    1d36:	3c 93       	st	X, r19
    1d38:	2e 93       	st	-X, r18
    1d3a:	11 97       	sbiw	r26, 0x01	; 1
    1d3c:	1b 86       	std	Y+11, r1	; 0x0b
    1d3e:	1a 86       	std	Y+10, r1	; 0x0a
    1d40:	8c 91       	ld	r24, X
    1d42:	81 50       	subi	r24, 0x01	; 1
    1d44:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    1d46:	9e 89       	ldd	r25, Y+22	; 0x16
    1d48:	80 91 ed 03 	lds	r24, 0x03ED
    1d4c:	89 17       	cp	r24, r25
    1d4e:	10 f4       	brcc	.+4      	; 0x1d54 <vTaskGenericNotifyGiveFromISR+0xa0>
    1d50:	90 93 ed 03 	sts	0x03ED, r25
    1d54:	89 2f       	mov	r24, r25
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	fc 01       	movw	r30, r24
    1d5a:	a3 e0       	ldi	r26, 0x03	; 3
    1d5c:	ee 0f       	add	r30, r30
    1d5e:	ff 1f       	adc	r31, r31
    1d60:	aa 95       	dec	r26
    1d62:	e1 f7       	brne	.-8      	; 0x1d5c <vTaskGenericNotifyGiveFromISR+0xa8>
    1d64:	e8 0f       	add	r30, r24
    1d66:	f9 1f       	adc	r31, r25
    1d68:	e4 50       	subi	r30, 0x04	; 4
    1d6a:	fc 4f       	sbci	r31, 0xFC	; 252
    1d6c:	a1 81       	ldd	r26, Z+1	; 0x01
    1d6e:	b2 81       	ldd	r27, Z+2	; 0x02
    1d70:	bd 83       	std	Y+5, r27	; 0x05
    1d72:	ac 83       	std	Y+4, r26	; 0x04
    1d74:	14 96       	adiw	r26, 0x04	; 4
    1d76:	8d 91       	ld	r24, X+
    1d78:	9c 91       	ld	r25, X
    1d7a:	15 97       	sbiw	r26, 0x05	; 5
    1d7c:	9f 83       	std	Y+7, r25	; 0x07
    1d7e:	8e 83       	std	Y+6, r24	; 0x06
    1d80:	14 96       	adiw	r26, 0x04	; 4
    1d82:	ed 91       	ld	r30, X+
    1d84:	fc 91       	ld	r31, X
    1d86:	15 97       	sbiw	r26, 0x05	; 5
    1d88:	53 83       	std	Z+3, r21	; 0x03
    1d8a:	42 83       	std	Z+2, r20	; 0x02
    1d8c:	15 96       	adiw	r26, 0x05	; 5
    1d8e:	5c 93       	st	X, r21
    1d90:	4e 93       	st	-X, r20
    1d92:	14 97       	sbiw	r26, 0x04	; 4
    1d94:	ee 89       	ldd	r30, Y+22	; 0x16
    1d96:	89 e0       	ldi	r24, 0x09	; 9
    1d98:	e8 9f       	mul	r30, r24
    1d9a:	f0 01       	movw	r30, r0
    1d9c:	11 24       	eor	r1, r1
    1d9e:	e4 50       	subi	r30, 0x04	; 4
    1da0:	fc 4f       	sbci	r31, 0xFC	; 252
    1da2:	fb 87       	std	Y+11, r31	; 0x0b
    1da4:	ea 87       	std	Y+10, r30	; 0x0a
    1da6:	80 81       	ld	r24, Z
    1da8:	8f 5f       	subi	r24, 0xFF	; 255
    1daa:	80 83       	st	Z, r24
    1dac:	21 c0       	rjmp	.+66     	; 0x1df0 <vTaskGenericNotifyGiveFromISR+0x13c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1dae:	a0 91 40 04 	lds	r26, 0x0440
    1db2:	b0 91 41 04 	lds	r27, 0x0441
    1db6:	bf 87       	std	Y+15, r27	; 0x0f
    1db8:	ae 87       	std	Y+14, r26	; 0x0e
    1dba:	14 96       	adiw	r26, 0x04	; 4
    1dbc:	8d 91       	ld	r24, X+
    1dbe:	9c 91       	ld	r25, X
    1dc0:	15 97       	sbiw	r26, 0x05	; 5
    1dc2:	99 8b       	std	Y+17, r25	; 0x11
    1dc4:	88 8b       	std	Y+16, r24	; 0x10
    1dc6:	ce 01       	movw	r24, r28
    1dc8:	0c 96       	adiw	r24, 0x0c	; 12
    1dca:	14 96       	adiw	r26, 0x04	; 4
    1dcc:	ed 91       	ld	r30, X+
    1dce:	fc 91       	ld	r31, X
    1dd0:	15 97       	sbiw	r26, 0x05	; 5
    1dd2:	93 83       	std	Z+3, r25	; 0x03
    1dd4:	82 83       	std	Z+2, r24	; 0x02
    1dd6:	15 96       	adiw	r26, 0x05	; 5
    1dd8:	9c 93       	st	X, r25
    1dda:	8e 93       	st	-X, r24
    1ddc:	14 97       	sbiw	r26, 0x04	; 4
    1dde:	8f e3       	ldi	r24, 0x3F	; 63
    1de0:	94 e0       	ldi	r25, 0x04	; 4
    1de2:	9d 8b       	std	Y+21, r25	; 0x15
    1de4:	8c 8b       	std	Y+20, r24	; 0x14
    1de6:	80 91 3f 04 	lds	r24, 0x043F
    1dea:	8f 5f       	subi	r24, 0xFF	; 255
    1dec:	80 93 3f 04 	sts	0x043F, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1df0:	e0 91 ea 03 	lds	r30, 0x03EA
    1df4:	f0 91 eb 03 	lds	r31, 0x03EB
    1df8:	9e 89       	ldd	r25, Y+22	; 0x16
    1dfa:	86 89       	ldd	r24, Z+22	; 0x16
    1dfc:	89 17       	cp	r24, r25
    1dfe:	48 f4       	brcc	.+18     	; 0x1e12 <vTaskGenericNotifyGiveFromISR+0x15e>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    1e00:	61 15       	cp	r22, r1
    1e02:	71 05       	cpc	r23, r1
    1e04:	19 f0       	breq	.+6      	; 0x1e0c <vTaskGenericNotifyGiveFromISR+0x158>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    1e06:	81 e0       	ldi	r24, 0x01	; 1
    1e08:	fb 01       	movw	r30, r22
    1e0a:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	80 93 ee 03 	sts	0x03EE, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    1e12:	df 91       	pop	r29
    1e14:	cf 91       	pop	r28
    1e16:	08 95       	ret

00001e18 <xTaskGenericNotifyStateClear>:

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    1e18:	00 97       	sbiw	r24, 0x00	; 0
    1e1a:	21 f4       	brne	.+8      	; 0x1e24 <xTaskGenericNotifyStateClear+0xc>
    1e1c:	80 91 ea 03 	lds	r24, 0x03EA
    1e20:	90 91 eb 03 	lds	r25, 0x03EB

        taskENTER_CRITICAL();
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    1e2a:	fc 01       	movw	r30, r24
    1e2c:	e6 0f       	add	r30, r22
    1e2e:	f1 1d       	adc	r31, r1
    1e30:	85 a1       	ldd	r24, Z+37	; 0x25
    1e32:	82 30       	cpi	r24, 0x02	; 2
    1e34:	11 f0       	breq	.+4      	; 0x1e3a <xTaskGenericNotifyStateClear+0x22>
    1e36:	80 e0       	ldi	r24, 0x00	; 0
    1e38:	02 c0       	rjmp	.+4      	; 0x1e3e <xTaskGenericNotifyStateClear+0x26>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    1e3a:	15 a2       	std	Z+37, r1	; 0x25
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();
    1e3e:	0f 90       	pop	r0
    1e40:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    1e42:	08 95       	ret

00001e44 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    1e44:	ef 92       	push	r14
    1e46:	ff 92       	push	r15
    1e48:	0f 93       	push	r16
    1e4a:	1f 93       	push	r17
    1e4c:	79 01       	movw	r14, r18
    1e4e:	8a 01       	movw	r16, r20
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    1e50:	00 97       	sbiw	r24, 0x00	; 0
    1e52:	21 f4       	brne	.+8      	; 0x1e5c <ulTaskGenericNotifyValueClear+0x18>
    1e54:	80 91 ea 03 	lds	r24, 0x03EA
    1e58:	90 91 eb 03 	lds	r25, 0x03EB

        taskENTER_CRITICAL();
    1e5c:	0f b6       	in	r0, 0x3f	; 63
    1e5e:	f8 94       	cli
    1e60:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    1e62:	e6 2f       	mov	r30, r22
    1e64:	f0 e0       	ldi	r31, 0x00	; 0
    1e66:	ee 0f       	add	r30, r30
    1e68:	ff 1f       	adc	r31, r31
    1e6a:	ee 0f       	add	r30, r30
    1e6c:	ff 1f       	adc	r31, r31
    1e6e:	e8 0f       	add	r30, r24
    1e70:	f9 1f       	adc	r31, r25
    1e72:	21 a1       	ldd	r18, Z+33	; 0x21
    1e74:	32 a1       	ldd	r19, Z+34	; 0x22
    1e76:	43 a1       	ldd	r20, Z+35	; 0x23
    1e78:	54 a1       	ldd	r21, Z+36	; 0x24
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    1e7a:	81 a1       	ldd	r24, Z+33	; 0x21
    1e7c:	92 a1       	ldd	r25, Z+34	; 0x22
    1e7e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1e80:	b4 a1       	ldd	r27, Z+36	; 0x24
    1e82:	e0 94       	com	r14
    1e84:	f0 94       	com	r15
    1e86:	00 95       	com	r16
    1e88:	10 95       	com	r17
    1e8a:	8e 21       	and	r24, r14
    1e8c:	9f 21       	and	r25, r15
    1e8e:	a0 23       	and	r26, r16
    1e90:	b1 23       	and	r27, r17
    1e92:	81 a3       	std	Z+33, r24	; 0x21
    1e94:	92 a3       	std	Z+34, r25	; 0x22
    1e96:	a3 a3       	std	Z+35, r26	; 0x23
    1e98:	b4 a3       	std	Z+36, r27	; 0x24
        }
        taskEXIT_CRITICAL();
    1e9a:	0f 90       	pop	r0
    1e9c:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    1e9e:	b9 01       	movw	r22, r18
    1ea0:	ca 01       	movw	r24, r20
    1ea2:	1f 91       	pop	r17
    1ea4:	0f 91       	pop	r16
    1ea6:	ff 90       	pop	r15
    1ea8:	ef 90       	pop	r14
    1eaa:	08 95       	ret

00001eac <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    1eac:	ef 92       	push	r14
    1eae:	ff 92       	push	r15
    1eb0:	0f 93       	push	r16
    1eb2:	cf 93       	push	r28
    1eb4:	df 93       	push	r29
    1eb6:	ec 01       	movw	r28, r24

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
    1eb8:	0f b6       	in	r0, 0x3f	; 63
    1eba:	f8 94       	cli
    1ebc:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    1ebe:	e1 14       	cp	r14, r1
    1ec0:	f1 04       	cpc	r15, r1
    1ec2:	89 f0       	breq	.+34     	; 0x1ee6 <xTaskGenericNotify+0x3a>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    1ec4:	e6 2f       	mov	r30, r22
    1ec6:	f0 e0       	ldi	r31, 0x00	; 0
    1ec8:	ee 0f       	add	r30, r30
    1eca:	ff 1f       	adc	r31, r31
    1ecc:	ee 0f       	add	r30, r30
    1ece:	ff 1f       	adc	r31, r31
    1ed0:	ec 0f       	add	r30, r28
    1ed2:	fd 1f       	adc	r31, r29
    1ed4:	81 a1       	ldd	r24, Z+33	; 0x21
    1ed6:	92 a1       	ldd	r25, Z+34	; 0x22
    1ed8:	a3 a1       	ldd	r26, Z+35	; 0x23
    1eda:	b4 a1       	ldd	r27, Z+36	; 0x24
    1edc:	f7 01       	movw	r30, r14
    1ede:	80 83       	st	Z, r24
    1ee0:	91 83       	std	Z+1, r25	; 0x01
    1ee2:	a2 83       	std	Z+2, r26	; 0x02
    1ee4:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1ee6:	a6 2f       	mov	r26, r22
    1ee8:	b0 e0       	ldi	r27, 0x00	; 0
    1eea:	fe 01       	movw	r30, r28
    1eec:	ea 0f       	add	r30, r26
    1eee:	fb 1f       	adc	r31, r27
    1ef0:	65 a1       	ldd	r22, Z+37	; 0x25

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1ef2:	82 e0       	ldi	r24, 0x02	; 2
    1ef4:	85 a3       	std	Z+37, r24	; 0x25

            switch( eAction )
    1ef6:	02 30       	cpi	r16, 0x02	; 2
    1ef8:	d1 f0       	breq	.+52     	; 0x1f2e <xTaskGenericNotify+0x82>
    1efa:	03 30       	cpi	r16, 0x03	; 3
    1efc:	18 f4       	brcc	.+6      	; 0x1f04 <xTaskGenericNotify+0x58>
    1efe:	01 30       	cpi	r16, 0x01	; 1
    1f00:	c9 f5       	brne	.+114    	; 0x1f74 <xTaskGenericNotify+0xc8>
    1f02:	05 c0       	rjmp	.+10     	; 0x1f0e <xTaskGenericNotify+0x62>
    1f04:	03 30       	cpi	r16, 0x03	; 3
    1f06:	51 f1       	breq	.+84     	; 0x1f5c <xTaskGenericNotify+0xb0>
    1f08:	04 30       	cpi	r16, 0x04	; 4
    1f0a:	a1 f5       	brne	.+104    	; 0x1f74 <xTaskGenericNotify+0xc8>
    1f0c:	23 c0       	rjmp	.+70     	; 0x1f54 <xTaskGenericNotify+0xa8>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1f0e:	fd 01       	movw	r30, r26
    1f10:	ee 0f       	add	r30, r30
    1f12:	ff 1f       	adc	r31, r31
    1f14:	ee 0f       	add	r30, r30
    1f16:	ff 1f       	adc	r31, r31
    1f18:	ec 0f       	add	r30, r28
    1f1a:	fd 1f       	adc	r31, r29
    1f1c:	81 a1       	ldd	r24, Z+33	; 0x21
    1f1e:	92 a1       	ldd	r25, Z+34	; 0x22
    1f20:	a3 a1       	ldd	r26, Z+35	; 0x23
    1f22:	b4 a1       	ldd	r27, Z+36	; 0x24
    1f24:	82 2b       	or	r24, r18
    1f26:	93 2b       	or	r25, r19
    1f28:	a4 2b       	or	r26, r20
    1f2a:	b5 2b       	or	r27, r21
    1f2c:	0e c0       	rjmp	.+28     	; 0x1f4a <xTaskGenericNotify+0x9e>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1f2e:	fd 01       	movw	r30, r26
    1f30:	ee 0f       	add	r30, r30
    1f32:	ff 1f       	adc	r31, r31
    1f34:	ee 0f       	add	r30, r30
    1f36:	ff 1f       	adc	r31, r31
    1f38:	ec 0f       	add	r30, r28
    1f3a:	fd 1f       	adc	r31, r29
    1f3c:	81 a1       	ldd	r24, Z+33	; 0x21
    1f3e:	92 a1       	ldd	r25, Z+34	; 0x22
    1f40:	a3 a1       	ldd	r26, Z+35	; 0x23
    1f42:	b4 a1       	ldd	r27, Z+36	; 0x24
    1f44:	01 96       	adiw	r24, 0x01	; 1
    1f46:	a1 1d       	adc	r26, r1
    1f48:	b1 1d       	adc	r27, r1
    1f4a:	81 a3       	std	Z+33, r24	; 0x21
    1f4c:	92 a3       	std	Z+34, r25	; 0x22
    1f4e:	a3 a3       	std	Z+35, r26	; 0x23
    1f50:	b4 a3       	std	Z+36, r27	; 0x24
    1f52:	10 c0       	rjmp	.+32     	; 0x1f74 <xTaskGenericNotify+0xc8>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1f54:	62 30       	cpi	r22, 0x02	; 2
    1f56:	11 f4       	brne	.+4      	; 0x1f5c <xTaskGenericNotify+0xb0>
    1f58:	80 e0       	ldi	r24, 0x00	; 0
    1f5a:	6e c0       	rjmp	.+220    	; 0x2038 <xTaskGenericNotify+0x18c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    1f5c:	aa 0f       	add	r26, r26
    1f5e:	bb 1f       	adc	r27, r27
    1f60:	aa 0f       	add	r26, r26
    1f62:	bb 1f       	adc	r27, r27
    1f64:	ac 0f       	add	r26, r28
    1f66:	bd 1f       	adc	r27, r29
    1f68:	91 96       	adiw	r26, 0x21	; 33
    1f6a:	2d 93       	st	X+, r18
    1f6c:	3d 93       	st	X+, r19
    1f6e:	4d 93       	st	X+, r20
    1f70:	5c 93       	st	X, r21
    1f72:	94 97       	sbiw	r26, 0x24	; 36

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1f74:	61 30       	cpi	r22, 0x01	; 1
    1f76:	09 f0       	breq	.+2      	; 0x1f7a <xTaskGenericNotify+0xce>
    1f78:	5e c0       	rjmp	.+188    	; 0x2036 <xTaskGenericNotify+0x18a>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1f7a:	aa 85       	ldd	r26, Y+10	; 0x0a
    1f7c:	bb 85       	ldd	r27, Y+11	; 0x0b
    1f7e:	4c 81       	ldd	r20, Y+4	; 0x04
    1f80:	5d 81       	ldd	r21, Y+5	; 0x05
    1f82:	8e 81       	ldd	r24, Y+6	; 0x06
    1f84:	9f 81       	ldd	r25, Y+7	; 0x07
    1f86:	fa 01       	movw	r30, r20
    1f88:	95 83       	std	Z+5, r25	; 0x05
    1f8a:	84 83       	std	Z+4, r24	; 0x04
    1f8c:	2e 81       	ldd	r18, Y+6	; 0x06
    1f8e:	3f 81       	ldd	r19, Y+7	; 0x07
    1f90:	f9 01       	movw	r30, r18
    1f92:	53 83       	std	Z+3, r21	; 0x03
    1f94:	42 83       	std	Z+2, r20	; 0x02
    1f96:	ae 01       	movw	r20, r28
    1f98:	4e 5f       	subi	r20, 0xFE	; 254
    1f9a:	5f 4f       	sbci	r21, 0xFF	; 255
    1f9c:	11 96       	adiw	r26, 0x01	; 1
    1f9e:	8d 91       	ld	r24, X+
    1fa0:	9c 91       	ld	r25, X
    1fa2:	12 97       	sbiw	r26, 0x02	; 2
    1fa4:	84 17       	cp	r24, r20
    1fa6:	95 07       	cpc	r25, r21
    1fa8:	21 f4       	brne	.+8      	; 0x1fb2 <xTaskGenericNotify+0x106>
    1faa:	12 96       	adiw	r26, 0x02	; 2
    1fac:	3c 93       	st	X, r19
    1fae:	2e 93       	st	-X, r18
    1fb0:	11 97       	sbiw	r26, 0x01	; 1
    1fb2:	1b 86       	std	Y+11, r1	; 0x0b
    1fb4:	1a 86       	std	Y+10, r1	; 0x0a
    1fb6:	8c 91       	ld	r24, X
    1fb8:	81 50       	subi	r24, 0x01	; 1
    1fba:	8c 93       	st	X, r24
                prvAddTaskToReadyList( pxTCB );
    1fbc:	9e 89       	ldd	r25, Y+22	; 0x16
    1fbe:	80 91 ed 03 	lds	r24, 0x03ED
    1fc2:	89 17       	cp	r24, r25
    1fc4:	10 f4       	brcc	.+4      	; 0x1fca <xTaskGenericNotify+0x11e>
    1fc6:	90 93 ed 03 	sts	0x03ED, r25
    1fca:	89 2f       	mov	r24, r25
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	fc 01       	movw	r30, r24
    1fd0:	33 e0       	ldi	r19, 0x03	; 3
    1fd2:	ee 0f       	add	r30, r30
    1fd4:	ff 1f       	adc	r31, r31
    1fd6:	3a 95       	dec	r19
    1fd8:	e1 f7       	brne	.-8      	; 0x1fd2 <xTaskGenericNotify+0x126>
    1fda:	e8 0f       	add	r30, r24
    1fdc:	f9 1f       	adc	r31, r25
    1fde:	e4 50       	subi	r30, 0x04	; 4
    1fe0:	fc 4f       	sbci	r31, 0xFC	; 252
    1fe2:	a1 81       	ldd	r26, Z+1	; 0x01
    1fe4:	b2 81       	ldd	r27, Z+2	; 0x02
    1fe6:	bd 83       	std	Y+5, r27	; 0x05
    1fe8:	ac 83       	std	Y+4, r26	; 0x04
    1fea:	14 96       	adiw	r26, 0x04	; 4
    1fec:	8d 91       	ld	r24, X+
    1fee:	9c 91       	ld	r25, X
    1ff0:	15 97       	sbiw	r26, 0x05	; 5
    1ff2:	9f 83       	std	Y+7, r25	; 0x07
    1ff4:	8e 83       	std	Y+6, r24	; 0x06
    1ff6:	14 96       	adiw	r26, 0x04	; 4
    1ff8:	ed 91       	ld	r30, X+
    1ffa:	fc 91       	ld	r31, X
    1ffc:	15 97       	sbiw	r26, 0x05	; 5
    1ffe:	53 83       	std	Z+3, r21	; 0x03
    2000:	42 83       	std	Z+2, r20	; 0x02
    2002:	15 96       	adiw	r26, 0x05	; 5
    2004:	5c 93       	st	X, r21
    2006:	4e 93       	st	-X, r20
    2008:	14 97       	sbiw	r26, 0x04	; 4
    200a:	ee 89       	ldd	r30, Y+22	; 0x16
    200c:	89 e0       	ldi	r24, 0x09	; 9
    200e:	e8 9f       	mul	r30, r24
    2010:	f0 01       	movw	r30, r0
    2012:	11 24       	eor	r1, r1
    2014:	e4 50       	subi	r30, 0x04	; 4
    2016:	fc 4f       	sbci	r31, 0xFC	; 252
    2018:	fb 87       	std	Y+11, r31	; 0x0b
    201a:	ea 87       	std	Y+10, r30	; 0x0a
    201c:	80 81       	ld	r24, Z
    201e:	8f 5f       	subi	r24, 0xFF	; 255
    2020:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2022:	e0 91 ea 03 	lds	r30, 0x03EA
    2026:	f0 91 eb 03 	lds	r31, 0x03EB
    202a:	9e 89       	ldd	r25, Y+22	; 0x16
    202c:	86 89       	ldd	r24, Z+22	; 0x16
    202e:	89 17       	cp	r24, r25
    2030:	10 f4       	brcc	.+4      	; 0x2036 <xTaskGenericNotify+0x18a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    2032:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
    2036:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2038:	0f 90       	pop	r0
    203a:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    203c:	df 91       	pop	r29
    203e:	cf 91       	pop	r28
    2040:	0f 91       	pop	r16
    2042:	ff 90       	pop	r15
    2044:	ef 90       	pop	r14
    2046:	08 95       	ret

00002048 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2048:	1f 93       	push	r17
    204a:	cf 93       	push	r28
    204c:	df 93       	push	r29
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    204e:	0f b6       	in	r0, 0x3f	; 63
    2050:	f8 94       	cli
    2052:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    2054:	80 91 ec 03 	lds	r24, 0x03EC
    2058:	81 50       	subi	r24, 0x01	; 1
    205a:	80 93 ec 03 	sts	0x03EC, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    205e:	80 91 ec 03 	lds	r24, 0x03EC
    2062:	88 23       	and	r24, r24
    2064:	09 f0       	breq	.+2      	; 0x2068 <xTaskResumeAll+0x20>
    2066:	c7 c0       	rjmp	.+398    	; 0x21f6 <xTaskResumeAll+0x1ae>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2068:	80 91 f6 03 	lds	r24, 0x03F6
    206c:	88 23       	and	r24, r24
    206e:	09 f4       	brne	.+2      	; 0x2072 <xTaskResumeAll+0x2a>
    2070:	c2 c0       	rjmp	.+388    	; 0x21f6 <xTaskResumeAll+0x1ae>
    2072:	c0 e0       	ldi	r28, 0x00	; 0
    2074:	d0 e0       	ldi	r29, 0x00	; 0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    2076:	79 e0       	ldi	r23, 0x09	; 9

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    2078:	61 e0       	ldi	r22, 0x01	; 1
    207a:	84 c0       	rjmp	.+264    	; 0x2184 <xTaskResumeAll+0x13c>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    207c:	e0 91 44 04 	lds	r30, 0x0444
    2080:	f0 91 45 04 	lds	r31, 0x0445
    2084:	c6 81       	ldd	r28, Z+6	; 0x06
    2086:	d7 81       	ldd	r29, Z+7	; 0x07
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    2088:	ac 89       	ldd	r26, Y+20	; 0x14
    208a:	bd 89       	ldd	r27, Y+21	; 0x15
    208c:	2e 85       	ldd	r18, Y+14	; 0x0e
    208e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2090:	88 89       	ldd	r24, Y+16	; 0x10
    2092:	99 89       	ldd	r25, Y+17	; 0x11
    2094:	f9 01       	movw	r30, r18
    2096:	95 83       	std	Z+5, r25	; 0x05
    2098:	84 83       	std	Z+4, r24	; 0x04
    209a:	48 89       	ldd	r20, Y+16	; 0x10
    209c:	59 89       	ldd	r21, Y+17	; 0x11
    209e:	fa 01       	movw	r30, r20
    20a0:	33 83       	std	Z+3, r19	; 0x03
    20a2:	22 83       	std	Z+2, r18	; 0x02
    20a4:	9e 01       	movw	r18, r28
    20a6:	24 5f       	subi	r18, 0xF4	; 244
    20a8:	3f 4f       	sbci	r19, 0xFF	; 255
    20aa:	11 96       	adiw	r26, 0x01	; 1
    20ac:	8d 91       	ld	r24, X+
    20ae:	9c 91       	ld	r25, X
    20b0:	12 97       	sbiw	r26, 0x02	; 2
    20b2:	82 17       	cp	r24, r18
    20b4:	93 07       	cpc	r25, r19
    20b6:	21 f4       	brne	.+8      	; 0x20c0 <xTaskResumeAll+0x78>
    20b8:	12 96       	adiw	r26, 0x02	; 2
    20ba:	5c 93       	st	X, r21
    20bc:	4e 93       	st	-X, r20
    20be:	11 97       	sbiw	r26, 0x01	; 1
    20c0:	1d 8a       	std	Y+21, r1	; 0x15
    20c2:	1c 8a       	std	Y+20, r1	; 0x14
    20c4:	8c 91       	ld	r24, X
    20c6:	81 50       	subi	r24, 0x01	; 1
    20c8:	8c 93       	st	X, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    20ca:	aa 85       	ldd	r26, Y+10	; 0x0a
    20cc:	bb 85       	ldd	r27, Y+11	; 0x0b
    20ce:	4c 81       	ldd	r20, Y+4	; 0x04
    20d0:	5d 81       	ldd	r21, Y+5	; 0x05
    20d2:	8e 81       	ldd	r24, Y+6	; 0x06
    20d4:	9f 81       	ldd	r25, Y+7	; 0x07
    20d6:	fa 01       	movw	r30, r20
    20d8:	95 83       	std	Z+5, r25	; 0x05
    20da:	84 83       	std	Z+4, r24	; 0x04
    20dc:	2e 81       	ldd	r18, Y+6	; 0x06
    20de:	3f 81       	ldd	r19, Y+7	; 0x07
    20e0:	f9 01       	movw	r30, r18
    20e2:	53 83       	std	Z+3, r21	; 0x03
    20e4:	42 83       	std	Z+2, r20	; 0x02
    20e6:	ae 01       	movw	r20, r28
    20e8:	4e 5f       	subi	r20, 0xFE	; 254
    20ea:	5f 4f       	sbci	r21, 0xFF	; 255
    20ec:	11 96       	adiw	r26, 0x01	; 1
    20ee:	8d 91       	ld	r24, X+
    20f0:	9c 91       	ld	r25, X
    20f2:	12 97       	sbiw	r26, 0x02	; 2
    20f4:	84 17       	cp	r24, r20
    20f6:	95 07       	cpc	r25, r21
    20f8:	21 f4       	brne	.+8      	; 0x2102 <xTaskResumeAll+0xba>
    20fa:	12 96       	adiw	r26, 0x02	; 2
    20fc:	3c 93       	st	X, r19
    20fe:	2e 93       	st	-X, r18
    2100:	11 97       	sbiw	r26, 0x01	; 1
    2102:	1b 86       	std	Y+11, r1	; 0x0b
    2104:	1a 86       	std	Y+10, r1	; 0x0a
    2106:	8c 91       	ld	r24, X
    2108:	81 50       	subi	r24, 0x01	; 1
    210a:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    210c:	9e 89       	ldd	r25, Y+22	; 0x16
    210e:	80 91 ed 03 	lds	r24, 0x03ED
    2112:	89 17       	cp	r24, r25
    2114:	10 f4       	brcc	.+4      	; 0x211a <xTaskResumeAll+0xd2>
    2116:	90 93 ed 03 	sts	0x03ED, r25
    211a:	89 2f       	mov	r24, r25
    211c:	90 e0       	ldi	r25, 0x00	; 0
    211e:	fc 01       	movw	r30, r24
    2120:	23 e0       	ldi	r18, 0x03	; 3
    2122:	ee 0f       	add	r30, r30
    2124:	ff 1f       	adc	r31, r31
    2126:	2a 95       	dec	r18
    2128:	e1 f7       	brne	.-8      	; 0x2122 <xTaskResumeAll+0xda>
    212a:	e8 0f       	add	r30, r24
    212c:	f9 1f       	adc	r31, r25
    212e:	e4 50       	subi	r30, 0x04	; 4
    2130:	fc 4f       	sbci	r31, 0xFC	; 252
    2132:	a1 81       	ldd	r26, Z+1	; 0x01
    2134:	b2 81       	ldd	r27, Z+2	; 0x02
    2136:	bd 83       	std	Y+5, r27	; 0x05
    2138:	ac 83       	std	Y+4, r26	; 0x04
    213a:	14 96       	adiw	r26, 0x04	; 4
    213c:	8d 91       	ld	r24, X+
    213e:	9c 91       	ld	r25, X
    2140:	15 97       	sbiw	r26, 0x05	; 5
    2142:	9f 83       	std	Y+7, r25	; 0x07
    2144:	8e 83       	std	Y+6, r24	; 0x06
    2146:	14 96       	adiw	r26, 0x04	; 4
    2148:	ed 91       	ld	r30, X+
    214a:	fc 91       	ld	r31, X
    214c:	15 97       	sbiw	r26, 0x05	; 5
    214e:	53 83       	std	Z+3, r21	; 0x03
    2150:	42 83       	std	Z+2, r20	; 0x02
    2152:	15 96       	adiw	r26, 0x05	; 5
    2154:	5c 93       	st	X, r21
    2156:	4e 93       	st	-X, r20
    2158:	14 97       	sbiw	r26, 0x04	; 4
    215a:	ee 89       	ldd	r30, Y+22	; 0x16
    215c:	e7 9f       	mul	r30, r23
    215e:	f0 01       	movw	r30, r0
    2160:	11 24       	eor	r1, r1
    2162:	e4 50       	subi	r30, 0x04	; 4
    2164:	fc 4f       	sbci	r31, 0xFC	; 252
    2166:	fb 87       	std	Y+11, r31	; 0x0b
    2168:	ea 87       	std	Y+10, r30	; 0x0a
    216a:	80 81       	ld	r24, Z
    216c:	8f 5f       	subi	r24, 0xFF	; 255
    216e:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2170:	e0 91 ea 03 	lds	r30, 0x03EA
    2174:	f0 91 eb 03 	lds	r31, 0x03EB
    2178:	9e 89       	ldd	r25, Y+22	; 0x16
    217a:	86 89       	ldd	r24, Z+22	; 0x16
    217c:	98 17       	cp	r25, r24
    217e:	10 f0       	brcs	.+4      	; 0x2184 <xTaskResumeAll+0x13c>
                    {
                        xYieldPending = pdTRUE;
    2180:	60 93 ee 03 	sts	0x03EE, r22
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2184:	80 91 3f 04 	lds	r24, 0x043F
    2188:	88 23       	and	r24, r24
    218a:	09 f0       	breq	.+2      	; 0x218e <xTaskResumeAll+0x146>
    218c:	77 cf       	rjmp	.-274    	; 0x207c <xTaskResumeAll+0x34>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    218e:	cd 2b       	or	r28, r29
    2190:	b9 f0       	breq	.+46     	; 0x21c0 <xTaskResumeAll+0x178>
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2192:	e0 91 3b 04 	lds	r30, 0x043B
    2196:	f0 91 3c 04 	lds	r31, 0x043C
    219a:	80 81       	ld	r24, Z
    219c:	88 23       	and	r24, r24
    219e:	19 f4       	brne	.+6      	; 0x21a6 <xTaskResumeAll+0x15e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    21a0:	8f ef       	ldi	r24, 0xFF	; 255
    21a2:	9f ef       	ldi	r25, 0xFF	; 255
    21a4:	09 c0       	rjmp	.+18     	; 0x21b8 <xTaskResumeAll+0x170>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    21a6:	e0 91 3b 04 	lds	r30, 0x043B
    21aa:	f0 91 3c 04 	lds	r31, 0x043C
    21ae:	05 80       	ldd	r0, Z+5	; 0x05
    21b0:	f6 81       	ldd	r31, Z+6	; 0x06
    21b2:	e0 2d       	mov	r30, r0
    21b4:	80 81       	ld	r24, Z
    21b6:	91 81       	ldd	r25, Z+1	; 0x01
    21b8:	90 93 f2 03 	sts	0x03F2, r25
    21bc:	80 93 f1 03 	sts	0x03F1, r24
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    21c0:	c0 91 f4 03 	lds	r28, 0x03F4
    21c4:	d0 91 f5 03 	lds	r29, 0x03F5

                    if( xPendedCounts > ( TickType_t ) 0U )
    21c8:	20 97       	sbiw	r28, 0x00	; 0
    21ca:	69 f0       	breq	.+26     	; 0x21e6 <xTaskResumeAll+0x19e>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    21cc:	11 e0       	ldi	r17, 0x01	; 1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    21ce:	0e 94 4d 0a 	call	0x149a	; 0x149a <xTaskIncrementTick>
    21d2:	88 23       	and	r24, r24
    21d4:	11 f0       	breq	.+4      	; 0x21da <xTaskResumeAll+0x192>
                            {
                                xYieldPending = pdTRUE;
    21d6:	10 93 ee 03 	sts	0x03EE, r17
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    21da:	21 97       	sbiw	r28, 0x01	; 1
                        } while( xPendedCounts > ( TickType_t ) 0U );
    21dc:	c1 f7       	brne	.-16     	; 0x21ce <xTaskResumeAll+0x186>

                        xPendedTicks = 0;
    21de:	10 92 f5 03 	sts	0x03F5, r1
    21e2:	10 92 f4 03 	sts	0x03F4, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    21e6:	80 91 ee 03 	lds	r24, 0x03EE
    21ea:	88 23       	and	r24, r24
    21ec:	21 f0       	breq	.+8      	; 0x21f6 <xTaskResumeAll+0x1ae>
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    21ee:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
    21f2:	81 e0       	ldi	r24, 0x01	; 1
    21f4:	01 c0       	rjmp	.+2      	; 0x21f8 <xTaskResumeAll+0x1b0>
    21f6:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    21f8:	0f 90       	pop	r0
    21fa:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
}
    21fc:	df 91       	pop	r29
    21fe:	cf 91       	pop	r28
    2200:	1f 91       	pop	r17
    2202:	08 95       	ret

00002204 <xTaskCatchUpTicks>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2204:	20 91 ec 03 	lds	r18, 0x03EC
    2208:	2f 5f       	subi	r18, 0xFF	; 255
    220a:	20 93 ec 03 	sts	0x03EC, r18
    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    220e:	0f b6       	in	r0, 0x3f	; 63
    2210:	f8 94       	cli
    2212:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    2214:	20 91 f4 03 	lds	r18, 0x03F4
    2218:	30 91 f5 03 	lds	r19, 0x03F5
    221c:	28 0f       	add	r18, r24
    221e:	39 1f       	adc	r19, r25
    2220:	30 93 f5 03 	sts	0x03F5, r19
    2224:	20 93 f4 03 	sts	0x03F4, r18
    }
    taskEXIT_CRITICAL();
    2228:	0f 90       	pop	r0
    222a:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    222c:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>

    return xYieldOccurred;
}
    2230:	08 95       	ret

00002232 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    2232:	0f 93       	push	r16
    2234:	1f 93       	push	r17
    2236:	cf 93       	push	r28
    2238:	df 93       	push	r29
    223a:	ec 01       	movw	r28, r24
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    223c:	00 91 ef 03 	lds	r16, 0x03EF
    2240:	10 91 f0 03 	lds	r17, 0x03F0
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2244:	80 91 ea 03 	lds	r24, 0x03EA
    2248:	90 91 eb 03 	lds	r25, 0x03EB
    224c:	02 96       	adiw	r24, 0x02	; 2
    224e:	0e 94 19 04 	call	0x832	; 0x832 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    2252:	c0 0f       	add	r28, r16
    2254:	d1 1f       	adc	r29, r17

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    2256:	e0 91 ea 03 	lds	r30, 0x03EA
    225a:	f0 91 eb 03 	lds	r31, 0x03EB
    225e:	d3 83       	std	Z+3, r29	; 0x03
    2260:	c2 83       	std	Z+2, r28	; 0x02

        if( xTimeToWake < xConstTickCount )
    2262:	c0 17       	cp	r28, r16
    2264:	d1 07       	cpc	r29, r17
    2266:	68 f4       	brcc	.+26     	; 0x2282 <prvAddCurrentTaskToDelayedList+0x50>
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    2268:	80 91 3d 04 	lds	r24, 0x043D
    226c:	90 91 3e 04 	lds	r25, 0x043E
    2270:	60 91 ea 03 	lds	r22, 0x03EA
    2274:	70 91 eb 03 	lds	r23, 0x03EB
    2278:	6e 5f       	subi	r22, 0xFE	; 254
    227a:	7f 4f       	sbci	r23, 0xFF	; 255
    227c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <vListInsert>
    2280:	17 c0       	rjmp	.+46     	; 0x22b0 <prvAddCurrentTaskToDelayedList+0x7e>
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    2282:	80 91 3b 04 	lds	r24, 0x043B
    2286:	90 91 3c 04 	lds	r25, 0x043C
    228a:	60 91 ea 03 	lds	r22, 0x03EA
    228e:	70 91 eb 03 	lds	r23, 0x03EB
    2292:	6e 5f       	subi	r22, 0xFE	; 254
    2294:	7f 4f       	sbci	r23, 0xFF	; 255
    2296:	0e 94 e7 03 	call	0x7ce	; 0x7ce <vListInsert>

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
    229a:	80 91 f1 03 	lds	r24, 0x03F1
    229e:	90 91 f2 03 	lds	r25, 0x03F2
    22a2:	c8 17       	cp	r28, r24
    22a4:	d9 07       	cpc	r29, r25
    22a6:	20 f4       	brcc	.+8      	; 0x22b0 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                xNextTaskUnblockTime = xTimeToWake;
    22a8:	d0 93 f2 03 	sts	0x03F2, r29
    22ac:	c0 93 f1 03 	sts	0x03F1, r28

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    22b0:	df 91       	pop	r29
    22b2:	cf 91       	pop	r28
    22b4:	1f 91       	pop	r17
    22b6:	0f 91       	pop	r16
    22b8:	08 95       	ret

000022ba <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    22ba:	8f 92       	push	r8
    22bc:	9f 92       	push	r9
    22be:	af 92       	push	r10
    22c0:	bf 92       	push	r11
    22c2:	cf 92       	push	r12
    22c4:	df 92       	push	r13
    22c6:	ef 92       	push	r14
    22c8:	ff 92       	push	r15
    22ca:	0f 93       	push	r16
    22cc:	1f 93       	push	r17
    22ce:	cf 93       	push	r28
    22d0:	df 93       	push	r29
    22d2:	48 01       	movw	r8, r16
    22d4:	59 01       	movw	r10, r18
    22d6:	e7 01       	movw	r28, r14
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    22d8:	0f b6       	in	r0, 0x3f	; 63
    22da:	f8 94       	cli
    22dc:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    22de:	e0 91 ea 03 	lds	r30, 0x03EA
    22e2:	f0 91 eb 03 	lds	r31, 0x03EB
    22e6:	e8 2e       	mov	r14, r24
    22e8:	ff 24       	eor	r15, r15
    22ea:	ee 0d       	add	r30, r14
    22ec:	ff 1d       	adc	r31, r15
    22ee:	85 a1       	ldd	r24, Z+37	; 0x25
    22f0:	82 30       	cpi	r24, 0x02	; 2
    22f2:	61 f1       	breq	.+88     	; 0x234c <xTaskGenericNotifyWait+0x92>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    22f4:	e0 91 ea 03 	lds	r30, 0x03EA
    22f8:	f0 91 eb 03 	lds	r31, 0x03EB
    22fc:	c7 01       	movw	r24, r14
    22fe:	88 0f       	add	r24, r24
    2300:	99 1f       	adc	r25, r25
    2302:	88 0f       	add	r24, r24
    2304:	99 1f       	adc	r25, r25
    2306:	e8 0f       	add	r30, r24
    2308:	f9 1f       	adc	r31, r25
    230a:	81 a1       	ldd	r24, Z+33	; 0x21
    230c:	92 a1       	ldd	r25, Z+34	; 0x22
    230e:	a3 a1       	ldd	r26, Z+35	; 0x23
    2310:	b4 a1       	ldd	r27, Z+36	; 0x24
    2312:	40 95       	com	r20
    2314:	50 95       	com	r21
    2316:	60 95       	com	r22
    2318:	70 95       	com	r23
    231a:	84 23       	and	r24, r20
    231c:	95 23       	and	r25, r21
    231e:	a6 23       	and	r26, r22
    2320:	b7 23       	and	r27, r23
    2322:	81 a3       	std	Z+33, r24	; 0x21
    2324:	92 a3       	std	Z+34, r25	; 0x22
    2326:	a3 a3       	std	Z+35, r26	; 0x23
    2328:	b4 a3       	std	Z+36, r27	; 0x24

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    232a:	e0 91 ea 03 	lds	r30, 0x03EA
    232e:	f0 91 eb 03 	lds	r31, 0x03EB
    2332:	ee 0d       	add	r30, r14
    2334:	ff 1d       	adc	r31, r15
    2336:	81 e0       	ldi	r24, 0x01	; 1
    2338:	85 a3       	std	Z+37, r24	; 0x25

                if( xTicksToWait > ( TickType_t ) 0 )
    233a:	c1 14       	cp	r12, r1
    233c:	d1 04       	cpc	r13, r1
    233e:	31 f0       	breq	.+12     	; 0x234c <xTaskGenericNotifyWait+0x92>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2340:	c6 01       	movw	r24, r12
    2342:	61 e0       	ldi	r22, 0x01	; 1
    2344:	0e 94 19 11 	call	0x2232	; 0x2232 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    2348:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    234c:	0f 90       	pop	r0
    234e:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    2350:	0f b6       	in	r0, 0x3f	; 63
    2352:	f8 94       	cli
    2354:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    2356:	20 97       	sbiw	r28, 0x00	; 0
    2358:	99 f0       	breq	.+38     	; 0x2380 <xTaskGenericNotifyWait+0xc6>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    235a:	e0 91 ea 03 	lds	r30, 0x03EA
    235e:	f0 91 eb 03 	lds	r31, 0x03EB
    2362:	c7 01       	movw	r24, r14
    2364:	88 0f       	add	r24, r24
    2366:	99 1f       	adc	r25, r25
    2368:	88 0f       	add	r24, r24
    236a:	99 1f       	adc	r25, r25
    236c:	e8 0f       	add	r30, r24
    236e:	f9 1f       	adc	r31, r25
    2370:	81 a1       	ldd	r24, Z+33	; 0x21
    2372:	92 a1       	ldd	r25, Z+34	; 0x22
    2374:	a3 a1       	ldd	r26, Z+35	; 0x23
    2376:	b4 a1       	ldd	r27, Z+36	; 0x24
    2378:	88 83       	st	Y, r24
    237a:	99 83       	std	Y+1, r25	; 0x01
    237c:	aa 83       	std	Y+2, r26	; 0x02
    237e:	bb 83       	std	Y+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    2380:	e0 91 ea 03 	lds	r30, 0x03EA
    2384:	f0 91 eb 03 	lds	r31, 0x03EB
    2388:	ee 0d       	add	r30, r14
    238a:	ff 1d       	adc	r31, r15
    238c:	85 a1       	ldd	r24, Z+37	; 0x25
    238e:	82 30       	cpi	r24, 0x02	; 2
    2390:	11 f0       	breq	.+4      	; 0x2396 <xTaskGenericNotifyWait+0xdc>
    2392:	80 e0       	ldi	r24, 0x00	; 0
    2394:	1c c0       	rjmp	.+56     	; 0x23ce <xTaskGenericNotifyWait+0x114>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    2396:	e0 91 ea 03 	lds	r30, 0x03EA
    239a:	f0 91 eb 03 	lds	r31, 0x03EB
    239e:	c7 01       	movw	r24, r14
    23a0:	88 0f       	add	r24, r24
    23a2:	99 1f       	adc	r25, r25
    23a4:	88 0f       	add	r24, r24
    23a6:	99 1f       	adc	r25, r25
    23a8:	e8 0f       	add	r30, r24
    23aa:	f9 1f       	adc	r31, r25
    23ac:	81 a1       	ldd	r24, Z+33	; 0x21
    23ae:	92 a1       	ldd	r25, Z+34	; 0x22
    23b0:	a3 a1       	ldd	r26, Z+35	; 0x23
    23b2:	b4 a1       	ldd	r27, Z+36	; 0x24
    23b4:	80 94       	com	r8
    23b6:	90 94       	com	r9
    23b8:	a0 94       	com	r10
    23ba:	b0 94       	com	r11
    23bc:	88 21       	and	r24, r8
    23be:	99 21       	and	r25, r9
    23c0:	aa 21       	and	r26, r10
    23c2:	bb 21       	and	r27, r11
    23c4:	81 a3       	std	Z+33, r24	; 0x21
    23c6:	92 a3       	std	Z+34, r25	; 0x22
    23c8:	a3 a3       	std	Z+35, r26	; 0x23
    23ca:	b4 a3       	std	Z+36, r27	; 0x24
    23cc:	81 e0       	ldi	r24, 0x01	; 1
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    23ce:	e0 91 ea 03 	lds	r30, 0x03EA
    23d2:	f0 91 eb 03 	lds	r31, 0x03EB
    23d6:	ee 0d       	add	r30, r14
    23d8:	ff 1d       	adc	r31, r15
    23da:	15 a2       	std	Z+37, r1	; 0x25
        }
        taskEXIT_CRITICAL();
    23dc:	0f 90       	pop	r0
    23de:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    23e0:	df 91       	pop	r29
    23e2:	cf 91       	pop	r28
    23e4:	1f 91       	pop	r17
    23e6:	0f 91       	pop	r16
    23e8:	ff 90       	pop	r15
    23ea:	ef 90       	pop	r14
    23ec:	df 90       	pop	r13
    23ee:	cf 90       	pop	r12
    23f0:	bf 90       	pop	r11
    23f2:	af 90       	pop	r10
    23f4:	9f 90       	pop	r9
    23f6:	8f 90       	pop	r8
    23f8:	08 95       	ret

000023fa <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    23fa:	1f 93       	push	r17
    23fc:	cf 93       	push	r28
    23fe:	df 93       	push	r29
    2400:	16 2f       	mov	r17, r22
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    2402:	0f b6       	in	r0, 0x3f	; 63
    2404:	f8 94       	cli
    2406:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    2408:	e0 91 ea 03 	lds	r30, 0x03EA
    240c:	f0 91 eb 03 	lds	r31, 0x03EB
    2410:	c8 2f       	mov	r28, r24
    2412:	d0 e0       	ldi	r29, 0x00	; 0
    2414:	ce 01       	movw	r24, r28
    2416:	88 0f       	add	r24, r24
    2418:	99 1f       	adc	r25, r25
    241a:	88 0f       	add	r24, r24
    241c:	99 1f       	adc	r25, r25
    241e:	e8 0f       	add	r30, r24
    2420:	f9 1f       	adc	r31, r25
    2422:	81 a1       	ldd	r24, Z+33	; 0x21
    2424:	92 a1       	ldd	r25, Z+34	; 0x22
    2426:	a3 a1       	ldd	r26, Z+35	; 0x23
    2428:	b4 a1       	ldd	r27, Z+36	; 0x24
    242a:	00 97       	sbiw	r24, 0x00	; 0
    242c:	a1 05       	cpc	r26, r1
    242e:	b1 05       	cpc	r27, r1
    2430:	89 f4       	brne	.+34     	; 0x2454 <ulTaskGenericNotifyTake+0x5a>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    2432:	e0 91 ea 03 	lds	r30, 0x03EA
    2436:	f0 91 eb 03 	lds	r31, 0x03EB
    243a:	ec 0f       	add	r30, r28
    243c:	fd 1f       	adc	r31, r29
    243e:	81 e0       	ldi	r24, 0x01	; 1
    2440:	85 a3       	std	Z+37, r24	; 0x25

                if( xTicksToWait > ( TickType_t ) 0 )
    2442:	41 15       	cp	r20, r1
    2444:	51 05       	cpc	r21, r1
    2446:	31 f0       	breq	.+12     	; 0x2454 <ulTaskGenericNotifyTake+0x5a>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2448:	ca 01       	movw	r24, r20
    244a:	61 e0       	ldi	r22, 0x01	; 1
    244c:	0e 94 19 11 	call	0x2232	; 0x2232 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    2450:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2454:	0f 90       	pop	r0
    2456:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    2458:	0f b6       	in	r0, 0x3f	; 63
    245a:	f8 94       	cli
    245c:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    245e:	e0 91 ea 03 	lds	r30, 0x03EA
    2462:	f0 91 eb 03 	lds	r31, 0x03EB
    2466:	ce 01       	movw	r24, r28
    2468:	88 0f       	add	r24, r24
    246a:	99 1f       	adc	r25, r25
    246c:	88 0f       	add	r24, r24
    246e:	99 1f       	adc	r25, r25
    2470:	e8 0f       	add	r30, r24
    2472:	f9 1f       	adc	r31, r25
    2474:	21 a1       	ldd	r18, Z+33	; 0x21
    2476:	32 a1       	ldd	r19, Z+34	; 0x22
    2478:	43 a1       	ldd	r20, Z+35	; 0x23
    247a:	54 a1       	ldd	r21, Z+36	; 0x24

            if( ulReturn != 0UL )
    247c:	21 15       	cp	r18, r1
    247e:	31 05       	cpc	r19, r1
    2480:	41 05       	cpc	r20, r1
    2482:	51 05       	cpc	r21, r1
    2484:	f9 f0       	breq	.+62     	; 0x24c4 <ulTaskGenericNotifyTake+0xca>
            {
                if( xClearCountOnExit != pdFALSE )
    2486:	11 23       	and	r17, r17
    2488:	59 f0       	breq	.+22     	; 0x24a0 <ulTaskGenericNotifyTake+0xa6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    248a:	e0 91 ea 03 	lds	r30, 0x03EA
    248e:	f0 91 eb 03 	lds	r31, 0x03EB
    2492:	e8 0f       	add	r30, r24
    2494:	f9 1f       	adc	r31, r25
    2496:	11 a2       	std	Z+33, r1	; 0x21
    2498:	12 a2       	std	Z+34, r1	; 0x22
    249a:	13 a2       	std	Z+35, r1	; 0x23
    249c:	14 a2       	std	Z+36, r1	; 0x24
    249e:	12 c0       	rjmp	.+36     	; 0x24c4 <ulTaskGenericNotifyTake+0xca>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    24a0:	e0 91 ea 03 	lds	r30, 0x03EA
    24a4:	f0 91 eb 03 	lds	r31, 0x03EB
    24a8:	21 50       	subi	r18, 0x01	; 1
    24aa:	30 40       	sbci	r19, 0x00	; 0
    24ac:	40 40       	sbci	r20, 0x00	; 0
    24ae:	50 40       	sbci	r21, 0x00	; 0
    24b0:	e8 0f       	add	r30, r24
    24b2:	f9 1f       	adc	r31, r25
    24b4:	21 a3       	std	Z+33, r18	; 0x21
    24b6:	32 a3       	std	Z+34, r19	; 0x22
    24b8:	43 a3       	std	Z+35, r20	; 0x23
    24ba:	54 a3       	std	Z+36, r21	; 0x24
    24bc:	2f 5f       	subi	r18, 0xFF	; 255
    24be:	3f 4f       	sbci	r19, 0xFF	; 255
    24c0:	4f 4f       	sbci	r20, 0xFF	; 255
    24c2:	5f 4f       	sbci	r21, 0xFF	; 255
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    24c4:	e0 91 ea 03 	lds	r30, 0x03EA
    24c8:	f0 91 eb 03 	lds	r31, 0x03EB
    24cc:	ec 0f       	add	r30, r28
    24ce:	fd 1f       	adc	r31, r29
    24d0:	15 a2       	std	Z+37, r1	; 0x25
        }
        taskEXIT_CRITICAL();
    24d2:	0f 90       	pop	r0
    24d4:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    24d6:	b9 01       	movw	r22, r18
    24d8:	ca 01       	movw	r24, r20
    24da:	df 91       	pop	r29
    24dc:	cf 91       	pop	r28
    24de:	1f 91       	pop	r17
    24e0:	08 95       	ret

000024e2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    24e2:	0f 93       	push	r16
    24e4:	1f 93       	push	r17
    24e6:	8c 01       	movw	r16, r24
    24e8:	ca 01       	movw	r24, r20
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    24ea:	e0 91 ea 03 	lds	r30, 0x03EA
    24ee:	f0 91 eb 03 	lds	r31, 0x03EB
    24f2:	70 68       	ori	r23, 0x80	; 128
    24f4:	75 87       	std	Z+13, r23	; 0x0d
    24f6:	64 87       	std	Z+12, r22	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    24f8:	f8 01       	movw	r30, r16
    24fa:	a1 81       	ldd	r26, Z+1	; 0x01
    24fc:	b2 81       	ldd	r27, Z+2	; 0x02
    24fe:	e0 91 ea 03 	lds	r30, 0x03EA
    2502:	f0 91 eb 03 	lds	r31, 0x03EB
    2506:	b7 87       	std	Z+15, r27	; 0x0f
    2508:	a6 87       	std	Z+14, r26	; 0x0e
    250a:	e0 91 ea 03 	lds	r30, 0x03EA
    250e:	f0 91 eb 03 	lds	r31, 0x03EB
    2512:	14 96       	adiw	r26, 0x04	; 4
    2514:	2d 91       	ld	r18, X+
    2516:	3c 91       	ld	r19, X
    2518:	15 97       	sbiw	r26, 0x05	; 5
    251a:	31 8b       	std	Z+17, r19	; 0x11
    251c:	20 8b       	std	Z+16, r18	; 0x10
    251e:	20 91 ea 03 	lds	r18, 0x03EA
    2522:	30 91 eb 03 	lds	r19, 0x03EB
    2526:	14 96       	adiw	r26, 0x04	; 4
    2528:	ed 91       	ld	r30, X+
    252a:	fc 91       	ld	r31, X
    252c:	15 97       	sbiw	r26, 0x05	; 5
    252e:	24 5f       	subi	r18, 0xF4	; 244
    2530:	3f 4f       	sbci	r19, 0xFF	; 255
    2532:	33 83       	std	Z+3, r19	; 0x03
    2534:	22 83       	std	Z+2, r18	; 0x02
    2536:	20 91 ea 03 	lds	r18, 0x03EA
    253a:	30 91 eb 03 	lds	r19, 0x03EB
    253e:	24 5f       	subi	r18, 0xF4	; 244
    2540:	3f 4f       	sbci	r19, 0xFF	; 255
    2542:	15 96       	adiw	r26, 0x05	; 5
    2544:	3c 93       	st	X, r19
    2546:	2e 93       	st	-X, r18
    2548:	14 97       	sbiw	r26, 0x04	; 4
    254a:	e0 91 ea 03 	lds	r30, 0x03EA
    254e:	f0 91 eb 03 	lds	r31, 0x03EB
    2552:	15 8b       	std	Z+21, r17	; 0x15
    2554:	04 8b       	std	Z+20, r16	; 0x14
    2556:	f8 01       	movw	r30, r16
    2558:	20 81       	ld	r18, Z
    255a:	2f 5f       	subi	r18, 0xFF	; 255
    255c:	20 83       	st	Z, r18

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    255e:	61 e0       	ldi	r22, 0x01	; 1
    2560:	0e 94 19 11 	call	0x2232	; 0x2232 <prvAddCurrentTaskToDelayedList>
}
    2564:	1f 91       	pop	r17
    2566:	0f 91       	pop	r16
    2568:	08 95       	ret

0000256a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    256a:	9c 01       	movw	r18, r24
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    256c:	00 97       	sbiw	r24, 0x00	; 0
    256e:	69 f0       	breq	.+26     	; 0x258a <vTaskDelay+0x20>
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2570:	80 91 ec 03 	lds	r24, 0x03EC
    2574:	8f 5f       	subi	r24, 0xFF	; 255
    2576:	80 93 ec 03 	sts	0x03EC, r24
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    257a:	c9 01       	movw	r24, r18
    257c:	60 e0       	ldi	r22, 0x00	; 0
    257e:	0e 94 19 11 	call	0x2232	; 0x2232 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    2582:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    2586:	88 23       	and	r24, r24
    2588:	11 f4       	brne	.+4      	; 0x258e <vTaskDelay+0x24>
        {
            portYIELD_WITHIN_API();
    258a:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
    258e:	08 95       	ret

00002590 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    2590:	1f 93       	push	r17
    2592:	fc 01       	movw	r30, r24
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2594:	80 91 ec 03 	lds	r24, 0x03EC
    2598:	8f 5f       	subi	r24, 0xFF	; 255
    259a:	80 93 ec 03 	sts	0x03EC, r24

        vTaskSuspendAll();
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    259e:	80 91 ef 03 	lds	r24, 0x03EF
    25a2:	90 91 f0 03 	lds	r25, 0x03F0

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    25a6:	20 81       	ld	r18, Z
    25a8:	31 81       	ldd	r19, Z+1	; 0x01
    25aa:	62 0f       	add	r22, r18
    25ac:	73 1f       	adc	r23, r19

            if( xConstTickCount < *pxPreviousWakeTime )
    25ae:	82 17       	cp	r24, r18
    25b0:	93 07       	cpc	r25, r19
    25b2:	28 f4       	brcc	.+10     	; 0x25be <xTaskDelayUntil+0x2e>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    25b4:	62 17       	cp	r22, r18
    25b6:	73 07       	cpc	r23, r19
    25b8:	28 f0       	brcs	.+10     	; 0x25c4 <xTaskDelayUntil+0x34>
    25ba:	10 e0       	ldi	r17, 0x00	; 0
    25bc:	08 c0       	rjmp	.+16     	; 0x25ce <xTaskDelayUntil+0x3e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    25be:	62 17       	cp	r22, r18
    25c0:	73 07       	cpc	r23, r19
    25c2:	20 f0       	brcs	.+8      	; 0x25cc <xTaskDelayUntil+0x3c>
    25c4:	10 e0       	ldi	r17, 0x00	; 0
    25c6:	86 17       	cp	r24, r22
    25c8:	97 07       	cpc	r25, r23
    25ca:	08 f4       	brcc	.+2      	; 0x25ce <xTaskDelayUntil+0x3e>
    25cc:	11 e0       	ldi	r17, 0x01	; 1
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    25ce:	71 83       	std	Z+1, r23	; 0x01
    25d0:	60 83       	st	Z, r22

            if( xShouldDelay != pdFALSE )
    25d2:	11 23       	and	r17, r17
    25d4:	39 f0       	breq	.+14     	; 0x25e4 <xTaskDelayUntil+0x54>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    25d6:	9b 01       	movw	r18, r22
    25d8:	28 1b       	sub	r18, r24
    25da:	39 0b       	sbc	r19, r25
    25dc:	c9 01       	movw	r24, r18
    25de:	60 e0       	ldi	r22, 0x00	; 0
    25e0:	0e 94 19 11 	call	0x2232	; 0x2232 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    25e4:	0e 94 24 10 	call	0x2048	; 0x2048 <xTaskResumeAll>

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    25e8:	88 23       	and	r24, r24
    25ea:	11 f4       	brne	.+4      	; 0x25f0 <xTaskDelayUntil+0x60>
        {
            portYIELD_WITHIN_API();
    25ec:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    }
    25f0:	81 2f       	mov	r24, r17
    25f2:	1f 91       	pop	r17
    25f4:	08 95       	ret

000025f6 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    25f6:	0f 93       	push	r16
    25f8:	1f 93       	push	r17
    25fa:	8b 01       	movw	r16, r22
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    25fc:	60 91 ea 03 	lds	r22, 0x03EA
    2600:	70 91 eb 03 	lds	r23, 0x03EB
    2604:	64 5f       	subi	r22, 0xF4	; 244
    2606:	7f 4f       	sbci	r23, 0xFF	; 255
    2608:	0e 94 e7 03 	call	0x7ce	; 0x7ce <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    260c:	c8 01       	movw	r24, r16
    260e:	61 e0       	ldi	r22, 0x01	; 1
    2610:	0e 94 19 11 	call	0x2232	; 0x2232 <prvAddCurrentTaskToDelayedList>
}
    2614:	1f 91       	pop	r17
    2616:	0f 91       	pop	r16
    2618:	08 95       	ret

0000261a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    261a:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    261c:	10 92 f7 03 	sts	0x03F7, r1
    vPortEndScheduler();
    2620:	0e 94 c1 04 	call	0x982	; 0x982 <vPortEndScheduler>
}
    2624:	08 95       	ret

00002626 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2626:	0f 93       	push	r16
    2628:	1f 93       	push	r17
    262a:	21 c0       	rjmp	.+66     	; 0x266e <prvIdleTask+0x48>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    262c:	0f b6       	in	r0, 0x3f	; 63
    262e:	f8 94       	cli
    2630:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2632:	e0 91 4d 04 	lds	r30, 0x044D
    2636:	f0 91 4e 04 	lds	r31, 0x044E
    263a:	06 81       	ldd	r16, Z+6	; 0x06
    263c:	17 81       	ldd	r17, Z+7	; 0x07
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    263e:	c8 01       	movw	r24, r16
    2640:	02 96       	adiw	r24, 0x02	; 2
    2642:	0e 94 19 04 	call	0x832	; 0x832 <uxListRemove>
                --uxCurrentNumberOfTasks;
    2646:	80 91 f6 03 	lds	r24, 0x03F6
    264a:	81 50       	subi	r24, 0x01	; 1
    264c:	80 93 f6 03 	sts	0x03F6, r24
                --uxDeletedTasksWaitingCleanUp;
    2650:	80 91 fa 03 	lds	r24, 0x03FA
    2654:	81 50       	subi	r24, 0x01	; 1
    2656:	80 93 fa 03 	sts	0x03FA, r24
            }
            taskEXIT_CRITICAL();
    265a:	0f 90       	pop	r0
    265c:	0f be       	out	0x3f, r0	; 63

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    265e:	f8 01       	movw	r30, r16
    2660:	87 89       	ldd	r24, Z+23	; 0x17
    2662:	90 8d       	ldd	r25, Z+24	; 0x18
    2664:	0e 94 9f 02 	call	0x53e	; 0x53e <vPortFree>
            vPortFree( pxTCB );
    2668:	c8 01       	movw	r24, r16
    266a:	0e 94 9f 02 	call	0x53e	; 0x53e <vPortFree>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    266e:	80 91 fa 03 	lds	r24, 0x03FA
    2672:	88 23       	and	r24, r24
    2674:	e1 f3       	breq	.-8      	; 0x266e <prvIdleTask+0x48>
    2676:	da cf       	rjmp	.-76     	; 0x262c <prvIdleTask+0x6>

00002678 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    2678:	0f 93       	push	r16
    267a:	1f 93       	push	r17
    267c:	cf 93       	push	r28
    267e:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    2680:	0f b6       	in	r0, 0x3f	; 63
    2682:	f8 94       	cli
    2684:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2686:	00 97       	sbiw	r24, 0x00	; 0
    2688:	11 f0       	breq	.+4      	; 0x268e <vTaskDelete+0x16>
    268a:	ec 01       	movw	r28, r24
    268c:	04 c0       	rjmp	.+8      	; 0x2696 <vTaskDelete+0x1e>
    268e:	c0 91 ea 03 	lds	r28, 0x03EA
    2692:	d0 91 eb 03 	lds	r29, 0x03EB

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2696:	8e 01       	movw	r16, r28
    2698:	0e 5f       	subi	r16, 0xFE	; 254
    269a:	1f 4f       	sbci	r17, 0xFF	; 255
    269c:	c8 01       	movw	r24, r16
    269e:	0e 94 19 04 	call	0x832	; 0x832 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    26a2:	8c 89       	ldd	r24, Y+20	; 0x14
    26a4:	9d 89       	ldd	r25, Y+21	; 0x15
    26a6:	89 2b       	or	r24, r25
    26a8:	21 f0       	breq	.+8      	; 0x26b2 <vTaskDelete+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    26aa:	ce 01       	movw	r24, r28
    26ac:	0c 96       	adiw	r24, 0x0c	; 12
    26ae:	0e 94 19 04 	call	0x832	; 0x832 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    26b2:	80 91 fb 03 	lds	r24, 0x03FB
    26b6:	8f 5f       	subi	r24, 0xFF	; 255
    26b8:	80 93 fb 03 	sts	0x03FB, r24

            if( pxTCB == pxCurrentTCB )
    26bc:	80 91 ea 03 	lds	r24, 0x03EA
    26c0:	90 91 eb 03 	lds	r25, 0x03EB
    26c4:	c8 17       	cp	r28, r24
    26c6:	d9 07       	cpc	r29, r25
    26c8:	59 f4       	brne	.+22     	; 0x26e0 <vTaskDelete+0x68>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    26ca:	88 e4       	ldi	r24, 0x48	; 72
    26cc:	94 e0       	ldi	r25, 0x04	; 4
    26ce:	b8 01       	movw	r22, r16
    26d0:	0e 94 c8 03 	call	0x790	; 0x790 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    26d4:	80 91 fa 03 	lds	r24, 0x03FA
    26d8:	8f 5f       	subi	r24, 0xFF	; 255
    26da:	80 93 fa 03 	sts	0x03FA, r24
    26de:	1c c0       	rjmp	.+56     	; 0x2718 <vTaskDelete+0xa0>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    26e0:	80 91 f6 03 	lds	r24, 0x03F6
    26e4:	81 50       	subi	r24, 0x01	; 1
    26e6:	80 93 f6 03 	sts	0x03F6, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    26ea:	e0 91 3b 04 	lds	r30, 0x043B
    26ee:	f0 91 3c 04 	lds	r31, 0x043C
    26f2:	80 81       	ld	r24, Z
    26f4:	88 23       	and	r24, r24
    26f6:	19 f4       	brne	.+6      	; 0x26fe <vTaskDelete+0x86>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    26f8:	8f ef       	ldi	r24, 0xFF	; 255
    26fa:	9f ef       	ldi	r25, 0xFF	; 255
    26fc:	09 c0       	rjmp	.+18     	; 0x2710 <vTaskDelete+0x98>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    26fe:	e0 91 3b 04 	lds	r30, 0x043B
    2702:	f0 91 3c 04 	lds	r31, 0x043C
    2706:	05 80       	ldd	r0, Z+5	; 0x05
    2708:	f6 81       	ldd	r31, Z+6	; 0x06
    270a:	e0 2d       	mov	r30, r0
    270c:	80 81       	ld	r24, Z
    270e:	91 81       	ldd	r25, Z+1	; 0x01
    2710:	90 93 f2 03 	sts	0x03F2, r25
    2714:	80 93 f1 03 	sts	0x03F1, r24
                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
            }
        }
        taskEXIT_CRITICAL();
    2718:	0f 90       	pop	r0
    271a:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    271c:	80 91 ea 03 	lds	r24, 0x03EA
    2720:	90 91 eb 03 	lds	r25, 0x03EB
    2724:	c8 17       	cp	r28, r24
    2726:	d9 07       	cpc	r29, r25
    2728:	39 f0       	breq	.+14     	; 0x2738 <vTaskDelete+0xc0>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    272a:	8f 89       	ldd	r24, Y+23	; 0x17
    272c:	98 8d       	ldd	r25, Y+24	; 0x18
    272e:	0e 94 9f 02 	call	0x53e	; 0x53e <vPortFree>
            vPortFree( pxTCB );
    2732:	ce 01       	movw	r24, r28
    2734:	0e 94 9f 02 	call	0x53e	; 0x53e <vPortFree>
            prvDeleteTCB( pxTCB );
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    2738:	80 91 f7 03 	lds	r24, 0x03F7
    273c:	88 23       	and	r24, r24
    273e:	49 f0       	breq	.+18     	; 0x2752 <vTaskDelete+0xda>
        {
            if( pxTCB == pxCurrentTCB )
    2740:	80 91 ea 03 	lds	r24, 0x03EA
    2744:	90 91 eb 03 	lds	r25, 0x03EB
    2748:	c8 17       	cp	r28, r24
    274a:	d9 07       	cpc	r29, r25
    274c:	11 f4       	brne	.+4      	; 0x2752 <vTaskDelete+0xda>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    274e:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    2752:	df 91       	pop	r29
    2754:	cf 91       	pop	r28
    2756:	1f 91       	pop	r17
    2758:	0f 91       	pop	r16
    275a:	08 95       	ret

0000275c <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    275c:	4f 92       	push	r4
    275e:	5f 92       	push	r5
    2760:	6f 92       	push	r6
    2762:	7f 92       	push	r7
    2764:	8f 92       	push	r8
    2766:	9f 92       	push	r9
    2768:	af 92       	push	r10
    276a:	bf 92       	push	r11
    276c:	cf 92       	push	r12
    276e:	df 92       	push	r13
    2770:	ef 92       	push	r14
    2772:	ff 92       	push	r15
    2774:	0f 93       	push	r16
    2776:	1f 93       	push	r17
    2778:	cf 93       	push	r28
    277a:	df 93       	push	r29
    277c:	2c 01       	movw	r4, r24
    277e:	4b 01       	movw	r8, r22
    2780:	5a 01       	movw	r10, r20
    2782:	39 01       	movw	r6, r18
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2784:	ca 01       	movw	r24, r20
    2786:	0e 94 cf 02 	call	0x59e	; 0x59e <pvPortMalloc>
    278a:	ec 01       	movw	r28, r24

            if( pxStack != NULL )
    278c:	00 97       	sbiw	r24, 0x00	; 0
    278e:	b1 f0       	breq	.+44     	; 0x27bc <xTaskCreate+0x60>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2790:	86 e2       	ldi	r24, 0x26	; 38
    2792:	90 e0       	ldi	r25, 0x00	; 0
    2794:	0e 94 cf 02 	call	0x59e	; 0x59e <pvPortMalloc>
    2798:	6c 01       	movw	r12, r24

                if( pxNewTCB != NULL )
    279a:	00 97       	sbiw	r24, 0x00	; 0
    279c:	61 f0       	breq	.+24     	; 0x27b6 <xTaskCreate+0x5a>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    279e:	86 e2       	ldi	r24, 0x26	; 38
    27a0:	d6 01       	movw	r26, r12
    27a2:	1d 92       	st	X+, r1
    27a4:	8a 95       	dec	r24
    27a6:	e9 f7       	brne	.-6      	; 0x27a2 <xTaskCreate+0x46>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    27a8:	f6 01       	movw	r30, r12
    27aa:	d0 8f       	std	Z+24, r29	; 0x18
    27ac:	c7 8b       	std	Z+23, r28	; 0x17
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    27ae:	81 14       	cp	r8, r1
    27b0:	91 04       	cpc	r9, r1
    27b2:	31 f4       	brne	.+12     	; 0x27c0 <xTaskCreate+0x64>
    27b4:	17 c0       	rjmp	.+46     	; 0x27e4 <xTaskCreate+0x88>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    27b6:	ce 01       	movw	r24, r28
    27b8:	0e 94 9f 02 	call	0x53e	; 0x53e <vPortFree>
    27bc:	8f ef       	ldi	r24, 0xFF	; 255
    27be:	e7 c0       	rjmp	.+462    	; 0x298e <xTaskCreate+0x232>
    27c0:	f4 01       	movw	r30, r8
    27c2:	d6 01       	movw	r26, r12
    27c4:	90 e0       	ldi	r25, 0x00	; 0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    27c6:	80 81       	ld	r24, Z
    27c8:	59 96       	adiw	r26, 0x19	; 25
    27ca:	8c 93       	st	X, r24
    27cc:	59 97       	sbiw	r26, 0x19	; 25

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    27ce:	80 81       	ld	r24, Z
    27d0:	88 23       	and	r24, r24
    27d2:	29 f0       	breq	.+10     	; 0x27de <xTaskCreate+0x82>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    27d4:	9f 5f       	subi	r25, 0xFF	; 255
    27d6:	31 96       	adiw	r30, 0x01	; 1
    27d8:	11 96       	adiw	r26, 0x01	; 1
    27da:	98 30       	cpi	r25, 0x08	; 8
    27dc:	a1 f7       	brne	.-24     	; 0x27c6 <xTaskCreate+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    27de:	d6 01       	movw	r26, r12
    27e0:	90 96       	adiw	r26, 0x20	; 32
    27e2:	1c 92       	st	X, r1
    27e4:	05 30       	cpi	r16, 0x05	; 5
    27e6:	08 f0       	brcs	.+2      	; 0x27ea <xTaskCreate+0x8e>
    27e8:	04 e0       	ldi	r16, 0x04	; 4
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    27ea:	f6 01       	movw	r30, r12
    27ec:	06 8b       	std	Z+22, r16	; 0x16
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    27ee:	52 e0       	ldi	r21, 0x02	; 2
    27f0:	85 2e       	mov	r8, r21
    27f2:	91 2c       	mov	r9, r1
    27f4:	8c 0c       	add	r8, r12
    27f6:	9d 1c       	adc	r9, r13
    27f8:	c4 01       	movw	r24, r8
    27fa:	0e 94 c4 03 	call	0x788	; 0x788 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    27fe:	c6 01       	movw	r24, r12
    2800:	0c 96       	adiw	r24, 0x0c	; 12
    2802:	0e 94 c4 03 	call	0x788	; 0x788 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2806:	d6 01       	movw	r26, r12
    2808:	19 96       	adiw	r26, 0x09	; 9
    280a:	dc 92       	st	X, r13
    280c:	ce 92       	st	-X, r12
    280e:	18 97       	sbiw	r26, 0x08	; 8

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2810:	85 e0       	ldi	r24, 0x05	; 5
    2812:	90 e0       	ldi	r25, 0x00	; 0
    2814:	80 1b       	sub	r24, r16
    2816:	91 09       	sbc	r25, r1
    2818:	1d 96       	adiw	r26, 0x0d	; 13
    281a:	9c 93       	st	X, r25
    281c:	8e 93       	st	-X, r24
    281e:	1c 97       	sbiw	r26, 0x0c	; 12
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2820:	53 96       	adiw	r26, 0x13	; 19
    2822:	dc 92       	st	X, r13
    2824:	ce 92       	st	-X, r12
    2826:	52 97       	sbiw	r26, 0x12	; 18
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2828:	08 94       	sec
    282a:	a1 08       	sbc	r10, r1
    282c:	b1 08       	sbc	r11, r1
    282e:	ce 01       	movw	r24, r28
    2830:	8a 0d       	add	r24, r10
    2832:	9b 1d       	adc	r25, r11
    2834:	b2 01       	movw	r22, r4
    2836:	a3 01       	movw	r20, r6
    2838:	0e 94 44 04 	call	0x888	; 0x888 <pxPortInitialiseStack>
    283c:	f6 01       	movw	r30, r12
    283e:	91 83       	std	Z+1, r25	; 0x01
    2840:	80 83       	st	Z, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    2842:	e1 14       	cp	r14, r1
    2844:	f1 04       	cpc	r15, r1
    2846:	19 f0       	breq	.+6      	; 0x284e <xTaskCreate+0xf2>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2848:	d7 01       	movw	r26, r14
    284a:	cd 92       	st	X+, r12
    284c:	dc 92       	st	X, r13

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    284e:	0f b6       	in	r0, 0x3f	; 63
    2850:	f8 94       	cli
    2852:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    2854:	80 91 f6 03 	lds	r24, 0x03F6
    2858:	8f 5f       	subi	r24, 0xFF	; 255
    285a:	80 93 f6 03 	sts	0x03F6, r24

        if( pxCurrentTCB == NULL )
    285e:	80 91 ea 03 	lds	r24, 0x03EA
    2862:	90 91 eb 03 	lds	r25, 0x03EB
    2866:	89 2b       	or	r24, r25
    2868:	79 f5       	brne	.+94     	; 0x28c8 <xTaskCreate+0x16c>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    286a:	d0 92 eb 03 	sts	0x03EB, r13
    286e:	c0 92 ea 03 	sts	0x03EA, r12

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2872:	80 91 f6 03 	lds	r24, 0x03F6
    2876:	81 30       	cpi	r24, 0x01	; 1
    2878:	c1 f5       	brne	.+112    	; 0x28ea <xTaskCreate+0x18e>
    287a:	cc ef       	ldi	r28, 0xFC	; 252
    287c:	d3 e0       	ldi	r29, 0x03	; 3
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    287e:	ce 01       	movw	r24, r28
    2880:	0e 94 b4 03 	call	0x768	; 0x768 <vListInitialise>
    2884:	29 96       	adiw	r28, 0x09	; 9

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2886:	b4 e0       	ldi	r27, 0x04	; 4
    2888:	c9 32       	cpi	r28, 0x29	; 41
    288a:	db 07       	cpc	r29, r27
    288c:	c1 f7       	brne	.-16     	; 0x287e <xTaskCreate+0x122>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    288e:	49 e2       	ldi	r20, 0x29	; 41
    2890:	e4 2e       	mov	r14, r20
    2892:	44 e0       	ldi	r20, 0x04	; 4
    2894:	f4 2e       	mov	r15, r20
    2896:	c7 01       	movw	r24, r14
    2898:	0e 94 b4 03 	call	0x768	; 0x768 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    289c:	02 e3       	ldi	r16, 0x32	; 50
    289e:	14 e0       	ldi	r17, 0x04	; 4
    28a0:	c8 01       	movw	r24, r16
    28a2:	0e 94 b4 03 	call	0x768	; 0x768 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    28a6:	8f e3       	ldi	r24, 0x3F	; 63
    28a8:	94 e0       	ldi	r25, 0x04	; 4
    28aa:	0e 94 b4 03 	call	0x768	; 0x768 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    28ae:	88 e4       	ldi	r24, 0x48	; 72
    28b0:	94 e0       	ldi	r25, 0x04	; 4
    28b2:	0e 94 b4 03 	call	0x768	; 0x768 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    28b6:	f0 92 3c 04 	sts	0x043C, r15
    28ba:	e0 92 3b 04 	sts	0x043B, r14
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    28be:	10 93 3e 04 	sts	0x043E, r17
    28c2:	00 93 3d 04 	sts	0x043D, r16
    28c6:	11 c0       	rjmp	.+34     	; 0x28ea <xTaskCreate+0x18e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    28c8:	80 91 f7 03 	lds	r24, 0x03F7
    28cc:	88 23       	and	r24, r24
    28ce:	69 f4       	brne	.+26     	; 0x28ea <xTaskCreate+0x18e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    28d0:	e0 91 ea 03 	lds	r30, 0x03EA
    28d4:	f0 91 eb 03 	lds	r31, 0x03EB
    28d8:	96 89       	ldd	r25, Z+22	; 0x16
    28da:	f6 01       	movw	r30, r12
    28dc:	86 89       	ldd	r24, Z+22	; 0x16
    28de:	89 17       	cp	r24, r25
    28e0:	20 f0       	brcs	.+8      	; 0x28ea <xTaskCreate+0x18e>
                {
                    pxCurrentTCB = pxNewTCB;
    28e2:	d0 92 eb 03 	sts	0x03EB, r13
    28e6:	c0 92 ea 03 	sts	0x03EA, r12
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    28ea:	80 91 fb 03 	lds	r24, 0x03FB
    28ee:	8f 5f       	subi	r24, 0xFF	; 255
    28f0:	80 93 fb 03 	sts	0x03FB, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    28f4:	d6 01       	movw	r26, r12
    28f6:	56 96       	adiw	r26, 0x16	; 22
    28f8:	9c 91       	ld	r25, X
    28fa:	80 91 ed 03 	lds	r24, 0x03ED
    28fe:	89 17       	cp	r24, r25
    2900:	10 f4       	brcc	.+4      	; 0x2906 <xTaskCreate+0x1aa>
    2902:	90 93 ed 03 	sts	0x03ED, r25
    2906:	89 2f       	mov	r24, r25
    2908:	90 e0       	ldi	r25, 0x00	; 0
    290a:	fc 01       	movw	r30, r24
    290c:	33 e0       	ldi	r19, 0x03	; 3
    290e:	ee 0f       	add	r30, r30
    2910:	ff 1f       	adc	r31, r31
    2912:	3a 95       	dec	r19
    2914:	e1 f7       	brne	.-8      	; 0x290e <xTaskCreate+0x1b2>
    2916:	e8 0f       	add	r30, r24
    2918:	f9 1f       	adc	r31, r25
    291a:	e4 50       	subi	r30, 0x04	; 4
    291c:	fc 4f       	sbci	r31, 0xFC	; 252
    291e:	a1 81       	ldd	r26, Z+1	; 0x01
    2920:	b2 81       	ldd	r27, Z+2	; 0x02
    2922:	f6 01       	movw	r30, r12
    2924:	b5 83       	std	Z+5, r27	; 0x05
    2926:	a4 83       	std	Z+4, r26	; 0x04
    2928:	14 96       	adiw	r26, 0x04	; 4
    292a:	8d 91       	ld	r24, X+
    292c:	9c 91       	ld	r25, X
    292e:	15 97       	sbiw	r26, 0x05	; 5
    2930:	97 83       	std	Z+7, r25	; 0x07
    2932:	86 83       	std	Z+6, r24	; 0x06
    2934:	14 96       	adiw	r26, 0x04	; 4
    2936:	ed 91       	ld	r30, X+
    2938:	fc 91       	ld	r31, X
    293a:	15 97       	sbiw	r26, 0x05	; 5
    293c:	93 82       	std	Z+3, r9	; 0x03
    293e:	82 82       	std	Z+2, r8	; 0x02
    2940:	15 96       	adiw	r26, 0x05	; 5
    2942:	9c 92       	st	X, r9
    2944:	8e 92       	st	-X, r8
    2946:	14 97       	sbiw	r26, 0x04	; 4
    2948:	d6 01       	movw	r26, r12
    294a:	56 96       	adiw	r26, 0x16	; 22
    294c:	ec 91       	ld	r30, X
    294e:	56 97       	sbiw	r26, 0x16	; 22
    2950:	89 e0       	ldi	r24, 0x09	; 9
    2952:	e8 9f       	mul	r30, r24
    2954:	f0 01       	movw	r30, r0
    2956:	11 24       	eor	r1, r1
    2958:	e4 50       	subi	r30, 0x04	; 4
    295a:	fc 4f       	sbci	r31, 0xFC	; 252
    295c:	1b 96       	adiw	r26, 0x0b	; 11
    295e:	fc 93       	st	X, r31
    2960:	ee 93       	st	-X, r30
    2962:	1a 97       	sbiw	r26, 0x0a	; 10
    2964:	80 81       	ld	r24, Z
    2966:	8f 5f       	subi	r24, 0xFF	; 255
    2968:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    296a:	0f 90       	pop	r0
    296c:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    296e:	80 91 f7 03 	lds	r24, 0x03F7
    2972:	88 23       	and	r24, r24
    2974:	59 f0       	breq	.+22     	; 0x298c <xTaskCreate+0x230>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    2976:	e0 91 ea 03 	lds	r30, 0x03EA
    297a:	f0 91 eb 03 	lds	r31, 0x03EB
    297e:	96 89       	ldd	r25, Z+22	; 0x16
    2980:	f6 01       	movw	r30, r12
    2982:	86 89       	ldd	r24, Z+22	; 0x16
    2984:	98 17       	cp	r25, r24
    2986:	10 f4       	brcc	.+4      	; 0x298c <xTaskCreate+0x230>
        {
            taskYIELD_IF_USING_PREEMPTION();
    2988:	0e 94 22 05 	call	0xa44	; 0xa44 <vPortYield>
    298c:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    298e:	df 91       	pop	r29
    2990:	cf 91       	pop	r28
    2992:	1f 91       	pop	r17
    2994:	0f 91       	pop	r16
    2996:	ff 90       	pop	r15
    2998:	ef 90       	pop	r14
    299a:	df 90       	pop	r13
    299c:	cf 90       	pop	r12
    299e:	bf 90       	pop	r11
    29a0:	af 90       	pop	r10
    29a2:	9f 90       	pop	r9
    29a4:	8f 90       	pop	r8
    29a6:	7f 90       	pop	r7
    29a8:	6f 90       	pop	r6
    29aa:	5f 90       	pop	r5
    29ac:	4f 90       	pop	r4
    29ae:	08 95       	ret

000029b0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    29b0:	ef 92       	push	r14
    29b2:	ff 92       	push	r15
    29b4:	0f 93       	push	r16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    29b6:	83 e1       	ldi	r24, 0x13	; 19
    29b8:	93 e1       	ldi	r25, 0x13	; 19
    29ba:	60 e6       	ldi	r22, 0x60	; 96
    29bc:	70 e0       	ldi	r23, 0x00	; 0
    29be:	45 e5       	ldi	r20, 0x55	; 85
    29c0:	50 e0       	ldi	r21, 0x00	; 0
    29c2:	20 e0       	ldi	r18, 0x00	; 0
    29c4:	30 e0       	ldi	r19, 0x00	; 0
    29c6:	00 e0       	ldi	r16, 0x00	; 0
    29c8:	e8 ef       	ldi	r30, 0xF8	; 248
    29ca:	ee 2e       	mov	r14, r30
    29cc:	e3 e0       	ldi	r30, 0x03	; 3
    29ce:	fe 2e       	mov	r15, r30
    29d0:	0e 94 ae 13 	call	0x275c	; 0x275c <xTaskCreate>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    29d4:	81 30       	cpi	r24, 0x01	; 1
    29d6:	81 f4       	brne	.+32     	; 0x29f8 <vTaskStartScheduler+0x48>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    29d8:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    29da:	8f ef       	ldi	r24, 0xFF	; 255
    29dc:	9f ef       	ldi	r25, 0xFF	; 255
    29de:	90 93 f2 03 	sts	0x03F2, r25
    29e2:	80 93 f1 03 	sts	0x03F1, r24
        xSchedulerRunning = pdTRUE;
    29e6:	81 e0       	ldi	r24, 0x01	; 1
    29e8:	80 93 f7 03 	sts	0x03F7, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    29ec:	10 92 f0 03 	sts	0x03F0, r1
    29f0:	10 92 ef 03 	sts	0x03EF, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    29f4:	0e 94 8c 04 	call	0x918	; 0x918 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    29f8:	80 91 e7 00 	lds	r24, 0x00E7
}
    29fc:	0f 91       	pop	r16
    29fe:	ff 90       	pop	r15
    2a00:	ef 90       	pop	r14
    2a02:	08 95       	ret

00002a04 <message>:
    message("No more tries"); // No more tries, access denied
    SET_BIT(PORTB , PIN0);
    return false;
}

void message(const u8* string) {
    2a04:	0f 93       	push	r16
    2a06:	1f 93       	push	r17
    2a08:	8c 01       	movw	r16, r24
    LCD_WRITE_CMD(CLEAR_DISPLAY);
    2a0a:	81 e0       	ldi	r24, 0x01	; 1
    2a0c:	90 e0       	ldi	r25, 0x00	; 0
    2a0e:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
    2a12:	84 ed       	ldi	r24, 0xD4	; 212
    2a14:	90 e3       	ldi	r25, 0x30	; 48
    2a16:	01 97       	sbiw	r24, 0x01	; 1
    2a18:	f1 f7       	brne	.-4      	; 0x2a16 <message+0x12>
    _delay_ms(50);
    LCD_WRITE_CENTER_STRING(string, 1);
    2a1a:	c8 01       	movw	r24, r16
    2a1c:	61 e0       	ldi	r22, 0x01	; 1
    2a1e:	70 e0       	ldi	r23, 0x00	; 0
    2a20:	0e 94 4f 01 	call	0x29e	; 0x29e <LCD_WRITE_CENTER_STRING>
    2a24:	80 e2       	ldi	r24, 0x20	; 32
    2a26:	9e e4       	ldi	r25, 0x4E	; 78
    2a28:	29 e1       	ldi	r18, 0x19	; 25
    2a2a:	30 e0       	ldi	r19, 0x00	; 0
    2a2c:	f9 01       	movw	r30, r18
    2a2e:	31 97       	sbiw	r30, 0x01	; 1
    2a30:	f1 f7       	brne	.-4      	; 0x2a2e <message+0x2a>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a32:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a34:	d9 f7       	brne	.-10     	; 0x2a2c <message+0x28>
    _delay_ms(2000);
    LCD_WRITE_CMD(CLEAR_DISPLAY);
    2a36:	81 e0       	ldi	r24, 0x01	; 1
    2a38:	90 e0       	ldi	r25, 0x00	; 0
    2a3a:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
}
    2a3e:	1f 91       	pop	r17
    2a40:	0f 91       	pop	r16
    2a42:	08 95       	ret

00002a44 <greetingText>:
    	}
    }
}

void greetingText() {
    LCD_WRITE_CENTER_STRING("Welcome", 1);
    2a44:	85 e6       	ldi	r24, 0x65	; 101
    2a46:	90 e0       	ldi	r25, 0x00	; 0
    2a48:	61 e0       	ldi	r22, 0x01	; 1
    2a4a:	70 e0       	ldi	r23, 0x00	; 0
    2a4c:	0e 94 4f 01 	call	0x29e	; 0x29e <LCD_WRITE_CENTER_STRING>
    LCD_WRITE_CENTER_STRING("to Smart Home!", 2);
    2a50:	8d e6       	ldi	r24, 0x6D	; 109
    2a52:	90 e0       	ldi	r25, 0x00	; 0
    2a54:	62 e0       	ldi	r22, 0x02	; 2
    2a56:	70 e0       	ldi	r23, 0x00	; 0
    2a58:	0e 94 4f 01 	call	0x29e	; 0x29e <LCD_WRITE_CENTER_STRING>
    2a5c:	88 e8       	ldi	r24, 0x88	; 136
    2a5e:	93 e1       	ldi	r25, 0x13	; 19
    2a60:	29 e1       	ldi	r18, 0x19	; 25
    2a62:	30 e0       	ldi	r19, 0x00	; 0
    2a64:	f9 01       	movw	r30, r18
    2a66:	31 97       	sbiw	r30, 0x01	; 1
    2a68:	f1 f7       	brne	.-4      	; 0x2a66 <greetingText+0x22>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a6a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a6c:	d9 f7       	brne	.-10     	; 0x2a64 <greetingText+0x20>
    _delay_ms(500);
    LCD_WRITE_CMD(CLEAR_DISPLAY);
    2a6e:	81 e0       	ldi	r24, 0x01	; 1
    2a70:	90 e0       	ldi	r25, 0x00	; 0
    2a72:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
}
    2a76:	08 95       	ret

00002a78 <getUserId>:
    }

    return true;
}

u8 getUserId(void) {
    2a78:	1f 93       	push	r17
    // Prompt user to enter ID
    LCD_SET_CURSOR_POSITION(1, 1);
    2a7a:	81 e0       	ldi	r24, 0x01	; 1
    2a7c:	90 e0       	ldi	r25, 0x00	; 0
    2a7e:	61 e0       	ldi	r22, 0x01	; 1
    2a80:	70 e0       	ldi	r23, 0x00	; 0
    2a82:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SET_CURSOR_POSITION>
    LCD_WRITE_STRING("user: ");
    2a86:	8c e7       	ldi	r24, 0x7C	; 124
    2a88:	90 e0       	ldi	r25, 0x00	; 0
    2a8a:	0e 94 cf 00 	call	0x19e	; 0x19e <LCD_WRITE_STRING>

    // Read user ID
    u8 inputedId = -1;
    while (1) {
        inputedId = KEYPAD_INPUT();
    2a8e:	0e 94 9d 01 	call	0x33a	; 0x33a <KEYPAD_INPUT>

        if (inputedId >= '0' && inputedId <= '9') {
    2a92:	18 2f       	mov	r17, r24
    2a94:	10 53       	subi	r17, 0x30	; 48
    2a96:	1a 30       	cpi	r17, 0x0A	; 10
    2a98:	d0 f7       	brcc	.-12     	; 0x2a8e <getUserId+0x16>
            inputedId -= '0'; // Convert the ASCII character to an integer
            LCD_SET_CURSOR_POSITION(1, 7);
    2a9a:	81 e0       	ldi	r24, 0x01	; 1
    2a9c:	90 e0       	ldi	r25, 0x00	; 0
    2a9e:	67 e0       	ldi	r22, 0x07	; 7
    2aa0:	70 e0       	ldi	r23, 0x00	; 0
    2aa2:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SET_CURSOR_POSITION>
            LCD_WRITE_STRING(users[inputedId].username);
    2aa6:	8d e0       	ldi	r24, 0x0D	; 13
    2aa8:	18 9f       	mul	r17, r24
    2aaa:	c0 01       	movw	r24, r0
    2aac:	11 24       	eor	r1, r1
    2aae:	86 51       	subi	r24, 0x16	; 22
    2ab0:	9f 4f       	sbci	r25, 0xFF	; 255
    2ab2:	0e 94 cf 00 	call	0x19e	; 0x19e <LCD_WRITE_STRING>
            break;
        }
    }

    return inputedId;
}
    2ab6:	81 2f       	mov	r24, r17
    2ab8:	1f 91       	pop	r17
    2aba:	08 95       	ret

00002abc <isPasswordValid>:

bool isPasswordValid(u8 userId) {
    2abc:	7f 92       	push	r7
    2abe:	8f 92       	push	r8
    2ac0:	9f 92       	push	r9
    2ac2:	af 92       	push	r10
    2ac4:	bf 92       	push	r11
    2ac6:	cf 92       	push	r12
    2ac8:	df 92       	push	r13
    2aca:	ef 92       	push	r14
    2acc:	ff 92       	push	r15
    2ace:	0f 93       	push	r16
    2ad0:	1f 93       	push	r17
    2ad2:	df 93       	push	r29
    2ad4:	cf 93       	push	r28
    2ad6:	00 d0       	rcall	.+0      	; 0x2ad8 <isPasswordValid+0x1c>
    2ad8:	0f 92       	push	r0
    2ada:	cd b7       	in	r28, 0x3d	; 61
    2adc:	de b7       	in	r29, 0x3e	; 62
            }
        }
        _delay_ms(500);

        // Compare entered password with correct password
        if (strncmp(enteredPassword, users[userId].password, PASSWORD_DIGITS) == 0)
    2ade:	90 e0       	ldi	r25, 0x00	; 0
    2ae0:	2d e0       	ldi	r18, 0x0D	; 13
    2ae2:	30 e0       	ldi	r19, 0x00	; 0
    2ae4:	ac 01       	movw	r20, r24
    2ae6:	42 9f       	mul	r20, r18
    2ae8:	c0 01       	movw	r24, r0
    2aea:	43 9f       	mul	r20, r19
    2aec:	90 0d       	add	r25, r0
    2aee:	52 9f       	mul	r21, r18
    2af0:	90 0d       	add	r25, r0
    2af2:	11 24       	eor	r1, r1
    2af4:	34 ef       	ldi	r19, 0xF4	; 244
    2af6:	a3 2e       	mov	r10, r19
    2af8:	30 e0       	ldi	r19, 0x00	; 0
    2afa:	b3 2e       	mov	r11, r19
    2afc:	a8 0e       	add	r10, r24
    2afe:	b9 1e       	adc	r11, r25

        // Prompt user to enter ID
        LCD_SET_CURSOR_POSITION(1, 1);
        LCD_WRITE_STRING("user: ");
        LCD_SET_CURSOR_POSITION(1, 7);
        LCD_WRITE_STRING(users[userId].username);
    2b00:	2a ee       	ldi	r18, 0xEA	; 234
    2b02:	c2 2e       	mov	r12, r18
    2b04:	20 e0       	ldi	r18, 0x00	; 0
    2b06:	d2 2e       	mov	r13, r18
    2b08:	c8 0e       	add	r12, r24
    2b0a:	d9 1e       	adc	r13, r25
    2b0c:	03 e0       	ldi	r16, 0x03	; 3

bool isPasswordValid(u8 userId) {
    u8 triesLeft = MAX_PASSWORD_TRIES;

    while (triesLeft--) {
    	u8 enteredPassword[PASSWORD_DIGITS] = {0};
    2b0e:	93 e0       	ldi	r25, 0x03	; 3
    2b10:	79 2e       	mov	r7, r25
    2b12:	7e 01       	movw	r14, r28
    2b14:	08 94       	sec
    2b16:	e1 1c       	adc	r14, r1
    2b18:	f1 1c       	adc	r15, r1
    2b1a:	89 e1       	ldi	r24, 0x19	; 25
    2b1c:	88 2e       	mov	r8, r24
    2b1e:	91 2c       	mov	r9, r1
    2b20:	f7 01       	movw	r30, r14
    2b22:	47 2d       	mov	r20, r7
    2b24:	11 92       	st	Z+, r1
    2b26:	4a 95       	dec	r20
    2b28:	e9 f7       	brne	.-6      	; 0x2b24 <isPasswordValid+0x68>

        LCD_SET_CURSOR_POSITION(2, 1);
    2b2a:	82 e0       	ldi	r24, 0x02	; 2
    2b2c:	90 e0       	ldi	r25, 0x00	; 0
    2b2e:	61 e0       	ldi	r22, 0x01	; 1
    2b30:	70 e0       	ldi	r23, 0x00	; 0
    2b32:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SET_CURSOR_POSITION>
        LCD_WRITE_STRING("pass: ");
    2b36:	83 e8       	ldi	r24, 0x83	; 131
    2b38:	90 e0       	ldi	r25, 0x00	; 0
    2b3a:	0e 94 cf 00 	call	0x19e	; 0x19e <LCD_WRITE_STRING>
    2b3e:	10 e0       	ldi	r17, 0x00	; 0


        u8 i = 0;
        while (i < PASSWORD_DIGITS) {
            u8 keyValue = KEYPAD_INPUT();
    2b40:	0e 94 9d 01 	call	0x33a	; 0x33a <KEYPAD_INPUT>
    2b44:	98 2f       	mov	r25, r24

            if (keyValue >= '0' && keyValue <= '9') {
    2b46:	80 53       	subi	r24, 0x30	; 48
    2b48:	8a 30       	cpi	r24, 0x0A	; 10
    2b4a:	d0 f7       	brcc	.-12     	; 0x2b40 <isPasswordValid+0x84>
            	enteredPassword[i] = keyValue;
    2b4c:	f7 01       	movw	r30, r14
    2b4e:	e1 0f       	add	r30, r17
    2b50:	f1 1d       	adc	r31, r1
    2b52:	90 83       	st	Z, r25
                LCD_WRITE_DATA('*');
    2b54:	8a e2       	ldi	r24, 0x2A	; 42
    2b56:	90 e0       	ldi	r25, 0x00	; 0
    2b58:	0e 94 76 00 	call	0xec	; 0xec <LCD_WRITE_DATA>
                i++;
    2b5c:	1f 5f       	subi	r17, 0xFF	; 255
        LCD_SET_CURSOR_POSITION(2, 1);
        LCD_WRITE_STRING("pass: ");


        u8 i = 0;
        while (i < PASSWORD_DIGITS) {
    2b5e:	13 30       	cpi	r17, 0x03	; 3
    2b60:	78 f3       	brcs	.-34     	; 0x2b40 <isPasswordValid+0x84>
    2b62:	88 e8       	ldi	r24, 0x88	; 136
    2b64:	93 e1       	ldi	r25, 0x13	; 19
    2b66:	f4 01       	movw	r30, r8
    2b68:	31 97       	sbiw	r30, 0x01	; 1
    2b6a:	f1 f7       	brne	.-4      	; 0x2b68 <isPasswordValid+0xac>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2b6c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2b6e:	d9 f7       	brne	.-10     	; 0x2b66 <isPasswordValid+0xaa>
            }
        }
        _delay_ms(500);

        // Compare entered password with correct password
        if (strncmp(enteredPassword, users[userId].password, PASSWORD_DIGITS) == 0)
    2b70:	c7 01       	movw	r24, r14
    2b72:	b5 01       	movw	r22, r10
    2b74:	43 e0       	ldi	r20, 0x03	; 3
    2b76:	50 e0       	ldi	r21, 0x00	; 0
    2b78:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <strncmp>
    2b7c:	00 97       	sbiw	r24, 0x00	; 0
    2b7e:	11 f4       	brne	.+4      	; 0x2b84 <isPasswordValid+0xc8>
    2b80:	81 e0       	ldi	r24, 0x01	; 1
    2b82:	41 c0       	rjmp	.+130    	; 0x2c06 <isPasswordValid+0x14a>
}

bool isPasswordValid(u8 userId) {
    u8 triesLeft = MAX_PASSWORD_TRIES;

    while (triesLeft--) {
    2b84:	01 50       	subi	r16, 0x01	; 1
        if (strncmp(enteredPassword, users[userId].password, PASSWORD_DIGITS) == 0)
            return true;


        // Access denied, decrement the number of tries left
        LCD_WRITE_CMD(CLEAR_DISPLAY);
    2b86:	81 e0       	ldi	r24, 0x01	; 1
    2b88:	90 e0       	ldi	r25, 0x00	; 0
    2b8a:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
        LCD_WRITE_CENTER_STRING("Access Denied", 1);
    2b8e:	8a e8       	ldi	r24, 0x8A	; 138
    2b90:	90 e0       	ldi	r25, 0x00	; 0
    2b92:	61 e0       	ldi	r22, 0x01	; 1
    2b94:	70 e0       	ldi	r23, 0x00	; 0
    2b96:	0e 94 4f 01 	call	0x29e	; 0x29e <LCD_WRITE_CENTER_STRING>
        LCD_SET_CURSOR_POSITION(2, 2);
    2b9a:	82 e0       	ldi	r24, 0x02	; 2
    2b9c:	90 e0       	ldi	r25, 0x00	; 0
    2b9e:	62 e0       	ldi	r22, 0x02	; 2
    2ba0:	70 e0       	ldi	r23, 0x00	; 0
    2ba2:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SET_CURSOR_POSITION>
        LCD_WRITE_STRING("tries left: ");
    2ba6:	88 e9       	ldi	r24, 0x98	; 152
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	0e 94 cf 00 	call	0x19e	; 0x19e <LCD_WRITE_STRING>
        LCD_WRITE_DATA(triesLeft + '0');
    2bae:	80 2f       	mov	r24, r16
    2bb0:	90 e0       	ldi	r25, 0x00	; 0
    2bb2:	c0 96       	adiw	r24, 0x30	; 48
    2bb4:	0e 94 76 00 	call	0xec	; 0xec <LCD_WRITE_DATA>
    2bb8:	80 e1       	ldi	r24, 0x10	; 16
    2bba:	97 e2       	ldi	r25, 0x27	; 39
    2bbc:	f4 01       	movw	r30, r8
    2bbe:	31 97       	sbiw	r30, 0x01	; 1
    2bc0:	f1 f7       	brne	.-4      	; 0x2bbe <isPasswordValid+0x102>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2bc2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2bc4:	d9 f7       	brne	.-10     	; 0x2bbc <isPasswordValid+0x100>
        _delay_ms(1000);

        LCD_WRITE_CMD(CLEAR_DISPLAY);
    2bc6:	81 e0       	ldi	r24, 0x01	; 1
    2bc8:	90 e0       	ldi	r25, 0x00	; 0
    2bca:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>

        // Prompt user to enter ID
        LCD_SET_CURSOR_POSITION(1, 1);
    2bce:	81 e0       	ldi	r24, 0x01	; 1
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	61 e0       	ldi	r22, 0x01	; 1
    2bd4:	70 e0       	ldi	r23, 0x00	; 0
    2bd6:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SET_CURSOR_POSITION>
        LCD_WRITE_STRING("user: ");
    2bda:	8c e7       	ldi	r24, 0x7C	; 124
    2bdc:	90 e0       	ldi	r25, 0x00	; 0
    2bde:	0e 94 cf 00 	call	0x19e	; 0x19e <LCD_WRITE_STRING>
        LCD_SET_CURSOR_POSITION(1, 7);
    2be2:	81 e0       	ldi	r24, 0x01	; 1
    2be4:	90 e0       	ldi	r25, 0x00	; 0
    2be6:	67 e0       	ldi	r22, 0x07	; 7
    2be8:	70 e0       	ldi	r23, 0x00	; 0
    2bea:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SET_CURSOR_POSITION>
        LCD_WRITE_STRING(users[userId].username);
    2bee:	c6 01       	movw	r24, r12
    2bf0:	0e 94 cf 00 	call	0x19e	; 0x19e <LCD_WRITE_STRING>
}

bool isPasswordValid(u8 userId) {
    u8 triesLeft = MAX_PASSWORD_TRIES;

    while (triesLeft--) {
    2bf4:	00 23       	and	r16, r16
    2bf6:	09 f0       	breq	.+2      	; 0x2bfa <isPasswordValid+0x13e>
    2bf8:	93 cf       	rjmp	.-218    	; 0x2b20 <isPasswordValid+0x64>
        LCD_WRITE_STRING("user: ");
        LCD_SET_CURSOR_POSITION(1, 7);
        LCD_WRITE_STRING(users[userId].username);
    }

    message("No more tries"); // No more tries, access denied
    2bfa:	85 ea       	ldi	r24, 0xA5	; 165
    2bfc:	90 e0       	ldi	r25, 0x00	; 0
    2bfe:	0e 94 02 15 	call	0x2a04	; 0x2a04 <message>
    SET_BIT(PORTB , PIN0);
    2c02:	c0 9a       	sbi	0x18, 0	; 24
    2c04:	80 e0       	ldi	r24, 0x00	; 0
    return false;
}
    2c06:	0f 90       	pop	r0
    2c08:	0f 90       	pop	r0
    2c0a:	0f 90       	pop	r0
    2c0c:	cf 91       	pop	r28
    2c0e:	df 91       	pop	r29
    2c10:	1f 91       	pop	r17
    2c12:	0f 91       	pop	r16
    2c14:	ff 90       	pop	r15
    2c16:	ef 90       	pop	r14
    2c18:	df 90       	pop	r13
    2c1a:	cf 90       	pop	r12
    2c1c:	bf 90       	pop	r11
    2c1e:	af 90       	pop	r10
    2c20:	9f 90       	pop	r9
    2c22:	8f 90       	pop	r8
    2c24:	7f 90       	pop	r7
    2c26:	08 95       	ret

00002c28 <isValidUser>:
    _delay_ms(500);
    LCD_WRITE_CMD(CLEAR_DISPLAY);
}

bool isValidUser(void) {
    u8 userId = getUserId();
    2c28:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <getUserId>

    if (userId < 0 || userId >= ACCOUNT_LENGTH) {
    2c2c:	8a 30       	cpi	r24, 0x0A	; 10
    2c2e:	30 f0       	brcs	.+12     	; 0x2c3c <isValidUser+0x14>
        message("Invalid ID");
    2c30:	83 eb       	ldi	r24, 0xB3	; 179
    2c32:	90 e0       	ldi	r25, 0x00	; 0
    2c34:	0e 94 02 15 	call	0x2a04	; 0x2a04 <message>
    2c38:	80 e0       	ldi	r24, 0x00	; 0
    2c3a:	08 95       	ret
        return false;
    }

    bool accessGranted = isPasswordValid(userId);
    2c3c:	0e 94 5e 15 	call	0x2abc	; 0x2abc <isPasswordValid>

    if (!accessGranted) {
    2c40:	88 23       	and	r24, r24
    2c42:	11 f0       	breq	.+4      	; 0x2c48 <isValidUser+0x20>
    2c44:	81 e0       	ldi	r24, 0x01	; 1
    2c46:	08 95       	ret
        message("Invalid Password");
    2c48:	8e eb       	ldi	r24, 0xBE	; 190
    2c4a:	90 e0       	ldi	r25, 0x00	; 0
    2c4c:	0e 94 02 15 	call	0x2a04	; 0x2a04 <message>
    2c50:	80 e0       	ldi	r24, 0x00	; 0
        return false;
    }

    return true;
}
    2c52:	08 95       	ret

00002c54 <vDoorTaskCode>:

    configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

    for( ;; )
    {
    	vTaskDelay(50);
    2c54:	82 e3       	ldi	r24, 0x32	; 50
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	0e 94 b5 12 	call	0x256a	; 0x256a <vTaskDelay>
    	if(Door_counter != 0){
    2c5c:	80 91 e8 00 	lds	r24, 0x00E8
    2c60:	88 23       	and	r24, r24
    2c62:	c1 f3       	breq	.-16     	; 0x2c54 <vDoorTaskCode>
    		SET_BIT(PORTB,PIN1);
    2c64:	c1 9a       	sbi	0x18, 1	; 24
    		vTaskDelay(3000);
    2c66:	88 eb       	ldi	r24, 0xB8	; 184
    2c68:	9b e0       	ldi	r25, 0x0B	; 11
    2c6a:	0e 94 b5 12 	call	0x256a	; 0x256a <vTaskDelay>
    		CLR_BIT(PORTB,PIN1);
    2c6e:	c1 98       	cbi	0x18, 1	; 24

    		vTaskDelay(5000);
    2c70:	88 e8       	ldi	r24, 0x88	; 136
    2c72:	93 e1       	ldi	r25, 0x13	; 19
    2c74:	0e 94 b5 12 	call	0x256a	; 0x256a <vTaskDelay>

    		SET_BIT(PORTB,PIN2);
    2c78:	c2 9a       	sbi	0x18, 2	; 24
    		vTaskDelay(3000);
    2c7a:	88 eb       	ldi	r24, 0xB8	; 184
    2c7c:	9b e0       	ldi	r25, 0x0B	; 11
    2c7e:	0e 94 b5 12 	call	0x256a	; 0x256a <vTaskDelay>
    		CLR_BIT(PORTB,PIN2);
    2c82:	c2 98       	cbi	0x18, 2	; 24
    		Door_counter--;
    2c84:	80 91 e8 00 	lds	r24, 0x00E8
    2c88:	81 50       	subi	r24, 0x01	; 1
    2c8a:	80 93 e8 00 	sts	0x00E8, r24
    2c8e:	e2 cf       	rjmp	.-60     	; 0x2c54 <vDoorTaskCode>

00002c90 <main>:
   { "Ahmed"	, "777" },
   { "Ali"		, "888" },
   { "Mona"		, "999" },
};

void main(){
    2c90:	ef 92       	push	r14
    2c92:	ff 92       	push	r15
    2c94:	0f 93       	push	r16
	// Initializations
	SPI_voidInit(Master);
    2c96:	80 e0       	ldi	r24, 0x00	; 0
    2c98:	90 e0       	ldi	r25, 0x00	; 0
    2c9a:	0e 94 49 00 	call	0x92	; 0x92 <SPI_voidInit>
	LCD_INIT();
    2c9e:	0e 94 92 00 	call	0x124	; 0x124 <LCD_INIT>
	KEYPAD_INIT();
    2ca2:	0e 94 76 01 	call	0x2ec	; 0x2ec <KEYPAD_INIT>

	SET_BIT(DDRB,PIN0); // BUZZER 2 " Thief "
    2ca6:	b8 9a       	sbi	0x17, 0	; 23
	SET_BIT(DDRB,PIN1); // DOOR
    2ca8:	b9 9a       	sbi	0x17, 1	; 23
	SET_BIT(DDRB,PIN2); // DOOR
    2caa:	ba 9a       	sbi	0x17, 2	; 23

    greetingText();
    2cac:	0e 94 22 15 	call	0x2a44	; 0x2a44 <greetingText>

    if(!isValidUser()) {
    2cb0:	0e 94 14 16 	call	0x2c28	; 0x2c28 <isValidUser>
    2cb4:	88 23       	and	r24, r24
    2cb6:	29 f4       	brne	.+10     	; 0x2cc2 <main+0x32>
    	while(1){
    		message("Access Denied");
    2cb8:	8a e8       	ldi	r24, 0x8A	; 138
    2cba:	90 e0       	ldi	r25, 0x00	; 0
    2cbc:	0e 94 02 15 	call	0x2a04	; 0x2a04 <message>
    2cc0:	fb cf       	rjmp	.-10     	; 0x2cb8 <main+0x28>
    	}
    }

    LCD_WRITE_CMD(CLEAR_DISPLAY);
    2cc2:	81 e0       	ldi	r24, 0x01	; 1
    2cc4:	90 e0       	ldi	r25, 0x00	; 0
    2cc6:	0e 94 84 00 	call	0x108	; 0x108 <LCD_WRITE_CMD>
   	LCD_WRITE_CENTER_STRING("Access Granted", 1);
    2cca:	8f ec       	ldi	r24, 0xCF	; 207
    2ccc:	90 e0       	ldi	r25, 0x00	; 0
    2cce:	61 e0       	ldi	r22, 0x01	; 1
    2cd0:	70 e0       	ldi	r23, 0x00	; 0
    2cd2:	0e 94 4f 01 	call	0x29e	; 0x29e <LCD_WRITE_CENTER_STRING>

	Data = SPI_u8transcieve(1);
    2cd6:	81 e0       	ldi	r24, 0x01	; 1
    2cd8:	90 e0       	ldi	r25, 0x00	; 0
    2cda:	0e 94 5d 00 	call	0xba	; 0xba <SPI_u8transcieve>
    2cde:	80 93 52 04 	sts	0x0452, r24
    2ce2:	80 e1       	ldi	r24, 0x10	; 16
    2ce4:	97 e2       	ldi	r25, 0x27	; 39
    2ce6:	29 e1       	ldi	r18, 0x19	; 25
    2ce8:	30 e0       	ldi	r19, 0x00	; 0
    2cea:	f9 01       	movw	r30, r18
    2cec:	31 97       	sbiw	r30, 0x01	; 1
    2cee:	f1 f7       	brne	.-4      	; 0x2cec <main+0x5c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2cf0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2cf2:	d9 f7       	brne	.-10     	; 0x2cea <main+0x5a>
   	_delay_ms(1000);

	xOpenDoorTask = xTaskCreate(vDoorTaskCode,"OpenDoor",configMINIMAL_STACK_SIZE,NULL,1,NULL);
    2cf4:	8a e2       	ldi	r24, 0x2A	; 42
    2cf6:	96 e1       	ldi	r25, 0x16	; 22
    2cf8:	6e ed       	ldi	r22, 0xDE	; 222
    2cfa:	70 e0       	ldi	r23, 0x00	; 0
    2cfc:	45 e5       	ldi	r20, 0x55	; 85
    2cfe:	50 e0       	ldi	r21, 0x00	; 0
    2d00:	20 e0       	ldi	r18, 0x00	; 0
    2d02:	30 e0       	ldi	r19, 0x00	; 0
    2d04:	01 e0       	ldi	r16, 0x01	; 1
    2d06:	ee 24       	eor	r14, r14
    2d08:	ff 24       	eor	r15, r15
    2d0a:	0e 94 ae 13 	call	0x275c	; 0x275c <xTaskCreate>
    2d0e:	80 93 55 04 	sts	0x0455, r24
	vTaskStartScheduler();
    2d12:	0e 94 d8 14 	call	0x29b0	; 0x29b0 <vTaskStartScheduler>
    2d16:	ff cf       	rjmp	.-2      	; 0x2d16 <main+0x86>

00002d18 <__udivmodhi4>:
    2d18:	aa 1b       	sub	r26, r26
    2d1a:	bb 1b       	sub	r27, r27
    2d1c:	51 e1       	ldi	r21, 0x11	; 17
    2d1e:	07 c0       	rjmp	.+14     	; 0x2d2e <__udivmodhi4_ep>

00002d20 <__udivmodhi4_loop>:
    2d20:	aa 1f       	adc	r26, r26
    2d22:	bb 1f       	adc	r27, r27
    2d24:	a6 17       	cp	r26, r22
    2d26:	b7 07       	cpc	r27, r23
    2d28:	10 f0       	brcs	.+4      	; 0x2d2e <__udivmodhi4_ep>
    2d2a:	a6 1b       	sub	r26, r22
    2d2c:	b7 0b       	sbc	r27, r23

00002d2e <__udivmodhi4_ep>:
    2d2e:	88 1f       	adc	r24, r24
    2d30:	99 1f       	adc	r25, r25
    2d32:	5a 95       	dec	r21
    2d34:	a9 f7       	brne	.-22     	; 0x2d20 <__udivmodhi4_loop>
    2d36:	80 95       	com	r24
    2d38:	90 95       	com	r25
    2d3a:	bc 01       	movw	r22, r24
    2d3c:	cd 01       	movw	r24, r26
    2d3e:	08 95       	ret

00002d40 <memcpy>:
    2d40:	fb 01       	movw	r30, r22
    2d42:	dc 01       	movw	r26, r24
    2d44:	02 c0       	rjmp	.+4      	; 0x2d4a <memcpy+0xa>
    2d46:	01 90       	ld	r0, Z+
    2d48:	0d 92       	st	X+, r0
    2d4a:	41 50       	subi	r20, 0x01	; 1
    2d4c:	50 40       	sbci	r21, 0x00	; 0
    2d4e:	d8 f7       	brcc	.-10     	; 0x2d46 <memcpy+0x6>
    2d50:	08 95       	ret

00002d52 <memset>:
    2d52:	dc 01       	movw	r26, r24
    2d54:	01 c0       	rjmp	.+2      	; 0x2d58 <memset+0x6>
    2d56:	6d 93       	st	X+, r22
    2d58:	41 50       	subi	r20, 0x01	; 1
    2d5a:	50 40       	sbci	r21, 0x00	; 0
    2d5c:	e0 f7       	brcc	.-8      	; 0x2d56 <memset+0x4>
    2d5e:	08 95       	ret

00002d60 <strncmp>:
    2d60:	fb 01       	movw	r30, r22
    2d62:	dc 01       	movw	r26, r24
    2d64:	41 50       	subi	r20, 0x01	; 1
    2d66:	50 40       	sbci	r21, 0x00	; 0
    2d68:	30 f0       	brcs	.+12     	; 0x2d76 <strncmp+0x16>
    2d6a:	8d 91       	ld	r24, X+
    2d6c:	01 90       	ld	r0, Z+
    2d6e:	80 19       	sub	r24, r0
    2d70:	19 f4       	brne	.+6      	; 0x2d78 <strncmp+0x18>
    2d72:	00 20       	and	r0, r0
    2d74:	b9 f7       	brne	.-18     	; 0x2d64 <strncmp+0x4>
    2d76:	88 1b       	sub	r24, r24
    2d78:	99 0b       	sbc	r25, r25
    2d7a:	08 95       	ret

00002d7c <_exit>:
    2d7c:	f8 94       	cli

00002d7e <__stop_program>:
    2d7e:	ff cf       	rjmp	.-2      	; 0x2d7e <__stop_program>
