
SLAVE.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000034d4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000124  00800060  000034d4  00003568  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e5  00800184  00800184  0000368c  2**0
                  ALLOC
  3 .stab         00005ef8  00000000  00000000  0000368c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004beb  00000000  00000000  00009584  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000e16f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000195  00000000  00000000  0000e2af  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001b12  00000000  00000000  0000e444  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000ead  00000000  00000000  0000ff56  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000e5d  00000000  00000000  00010e03  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00011c60  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002ae  00000000  00000000  00011dc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000896  00000000  00000000  0001206e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00012904  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 4f 09 	jmp	0x129e	; 0x129e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 ed       	ldi	r30, 0xD4	; 212
      68:	f4 e3       	ldi	r31, 0x34	; 52
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 38       	cpi	r26, 0x84	; 132
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a4 e8       	ldi	r26, 0x84	; 132
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 36       	cpi	r26, 0x69	; 105
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 b1 19 	call	0x3362	; 0x3362 <main>
      8a:	0c 94 68 1a 	jmp	0x34d0	; 0x34d0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 19 03 	call	0x632	; 0x632 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a7 03 	call	0x74e	; 0x74e <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a7 03 	call	0x74e	; 0x74e <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 21 1a 	jmp	0x3442	; 0x3442 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e7       	ldi	r26, 0x75	; 117
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 3d 1a 	jmp	0x347a	; 0x347a <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 2d 1a 	jmp	0x345a	; 0x345a <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 1f 05 	call	0xa3e	; 0xa3e <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 1f 05 	call	0xa3e	; 0xa3e <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 4a 04 	call	0x894	; 0x894 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 49 1a 	jmp	0x3492	; 0x3492 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 2d 1a 	jmp	0x345a	; 0x345a <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 1f 05 	call	0xa3e	; 0xa3e <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 1f 05 	call	0xa3e	; 0xa3e <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 4a 04 	call	0x894	; 0x894 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 49 1a 	jmp	0x3492	; 0x3492 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 21 1a 	jmp	0x3442	; 0x3442 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 1f 05 	call	0xa3e	; 0xa3e <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 1f 05 	call	0xa3e	; 0xa3e <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e7       	ldi	r24, 0x75	; 117
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 4a 04 	call	0x894	; 0x894 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 3d 1a 	jmp	0x347a	; 0x347a <__epilogue_restores__>

00000632 <__gesf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 2d 1a 	jmp	0x345a	; 0x345a <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 1f 05 	call	0xa3e	; 0xa3e <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 1f 05 	call	0xa3e	; 0xa3e <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gesf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gesf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 97 05 	call	0xb2e	; 0xb2e <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gesf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 49 1a 	jmp	0x3492	; 0x3492 <__epilogue_restores__+0x18>

00000692 <__floatsisf>:
     692:	a8 e0       	ldi	r26, 0x08	; 8
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 2a 1a 	jmp	0x3454	; 0x3454 <__prologue_saves__+0x12>
     69e:	9b 01       	movw	r18, r22
     6a0:	ac 01       	movw	r20, r24
     6a2:	83 e0       	ldi	r24, 0x03	; 3
     6a4:	89 83       	std	Y+1, r24	; 0x01
     6a6:	da 01       	movw	r26, r20
     6a8:	c9 01       	movw	r24, r18
     6aa:	88 27       	eor	r24, r24
     6ac:	b7 fd       	sbrc	r27, 7
     6ae:	83 95       	inc	r24
     6b0:	99 27       	eor	r25, r25
     6b2:	aa 27       	eor	r26, r26
     6b4:	bb 27       	eor	r27, r27
     6b6:	b8 2e       	mov	r11, r24
     6b8:	21 15       	cp	r18, r1
     6ba:	31 05       	cpc	r19, r1
     6bc:	41 05       	cpc	r20, r1
     6be:	51 05       	cpc	r21, r1
     6c0:	19 f4       	brne	.+6      	; 0x6c8 <__floatsisf+0x36>
     6c2:	82 e0       	ldi	r24, 0x02	; 2
     6c4:	89 83       	std	Y+1, r24	; 0x01
     6c6:	3a c0       	rjmp	.+116    	; 0x73c <__floatsisf+0xaa>
     6c8:	88 23       	and	r24, r24
     6ca:	a9 f0       	breq	.+42     	; 0x6f6 <__floatsisf+0x64>
     6cc:	20 30       	cpi	r18, 0x00	; 0
     6ce:	80 e0       	ldi	r24, 0x00	; 0
     6d0:	38 07       	cpc	r19, r24
     6d2:	80 e0       	ldi	r24, 0x00	; 0
     6d4:	48 07       	cpc	r20, r24
     6d6:	80 e8       	ldi	r24, 0x80	; 128
     6d8:	58 07       	cpc	r21, r24
     6da:	29 f4       	brne	.+10     	; 0x6e6 <__floatsisf+0x54>
     6dc:	60 e0       	ldi	r22, 0x00	; 0
     6de:	70 e0       	ldi	r23, 0x00	; 0
     6e0:	80 e0       	ldi	r24, 0x00	; 0
     6e2:	9f ec       	ldi	r25, 0xCF	; 207
     6e4:	30 c0       	rjmp	.+96     	; 0x746 <__floatsisf+0xb4>
     6e6:	ee 24       	eor	r14, r14
     6e8:	ff 24       	eor	r15, r15
     6ea:	87 01       	movw	r16, r14
     6ec:	e2 1a       	sub	r14, r18
     6ee:	f3 0a       	sbc	r15, r19
     6f0:	04 0b       	sbc	r16, r20
     6f2:	15 0b       	sbc	r17, r21
     6f4:	02 c0       	rjmp	.+4      	; 0x6fa <__floatsisf+0x68>
     6f6:	79 01       	movw	r14, r18
     6f8:	8a 01       	movw	r16, r20
     6fa:	8e e1       	ldi	r24, 0x1E	; 30
     6fc:	c8 2e       	mov	r12, r24
     6fe:	d1 2c       	mov	r13, r1
     700:	dc 82       	std	Y+4, r13	; 0x04
     702:	cb 82       	std	Y+3, r12	; 0x03
     704:	ed 82       	std	Y+5, r14	; 0x05
     706:	fe 82       	std	Y+6, r15	; 0x06
     708:	0f 83       	std	Y+7, r16	; 0x07
     70a:	18 87       	std	Y+8, r17	; 0x08
     70c:	c8 01       	movw	r24, r16
     70e:	b7 01       	movw	r22, r14
     710:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <__clzsi2>
     714:	01 97       	sbiw	r24, 0x01	; 1
     716:	18 16       	cp	r1, r24
     718:	19 06       	cpc	r1, r25
     71a:	84 f4       	brge	.+32     	; 0x73c <__floatsisf+0xaa>
     71c:	08 2e       	mov	r0, r24
     71e:	04 c0       	rjmp	.+8      	; 0x728 <__floatsisf+0x96>
     720:	ee 0c       	add	r14, r14
     722:	ff 1c       	adc	r15, r15
     724:	00 1f       	adc	r16, r16
     726:	11 1f       	adc	r17, r17
     728:	0a 94       	dec	r0
     72a:	d2 f7       	brpl	.-12     	; 0x720 <__floatsisf+0x8e>
     72c:	ed 82       	std	Y+5, r14	; 0x05
     72e:	fe 82       	std	Y+6, r15	; 0x06
     730:	0f 83       	std	Y+7, r16	; 0x07
     732:	18 87       	std	Y+8, r17	; 0x08
     734:	c8 1a       	sub	r12, r24
     736:	d9 0a       	sbc	r13, r25
     738:	dc 82       	std	Y+4, r13	; 0x04
     73a:	cb 82       	std	Y+3, r12	; 0x03
     73c:	ba 82       	std	Y+2, r11	; 0x02
     73e:	ce 01       	movw	r24, r28
     740:	01 96       	adiw	r24, 0x01	; 1
     742:	0e 94 4a 04 	call	0x894	; 0x894 <__pack_f>
     746:	28 96       	adiw	r28, 0x08	; 8
     748:	e9 e0       	ldi	r30, 0x09	; 9
     74a:	0c 94 46 1a 	jmp	0x348c	; 0x348c <__epilogue_restores__+0x12>

0000074e <__fixsfsi>:
     74e:	ac e0       	ldi	r26, 0x0C	; 12
     750:	b0 e0       	ldi	r27, 0x00	; 0
     752:	ed ea       	ldi	r30, 0xAD	; 173
     754:	f3 e0       	ldi	r31, 0x03	; 3
     756:	0c 94 31 1a 	jmp	0x3462	; 0x3462 <__prologue_saves__+0x20>
     75a:	69 83       	std	Y+1, r22	; 0x01
     75c:	7a 83       	std	Y+2, r23	; 0x02
     75e:	8b 83       	std	Y+3, r24	; 0x03
     760:	9c 83       	std	Y+4, r25	; 0x04
     762:	ce 01       	movw	r24, r28
     764:	01 96       	adiw	r24, 0x01	; 1
     766:	be 01       	movw	r22, r28
     768:	6b 5f       	subi	r22, 0xFB	; 251
     76a:	7f 4f       	sbci	r23, 0xFF	; 255
     76c:	0e 94 1f 05 	call	0xa3e	; 0xa3e <__unpack_f>
     770:	8d 81       	ldd	r24, Y+5	; 0x05
     772:	82 30       	cpi	r24, 0x02	; 2
     774:	61 f1       	breq	.+88     	; 0x7ce <__fixsfsi+0x80>
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	50 f1       	brcs	.+84     	; 0x7ce <__fixsfsi+0x80>
     77a:	84 30       	cpi	r24, 0x04	; 4
     77c:	21 f4       	brne	.+8      	; 0x786 <__fixsfsi+0x38>
     77e:	8e 81       	ldd	r24, Y+6	; 0x06
     780:	88 23       	and	r24, r24
     782:	51 f1       	breq	.+84     	; 0x7d8 <__fixsfsi+0x8a>
     784:	2e c0       	rjmp	.+92     	; 0x7e2 <__fixsfsi+0x94>
     786:	2f 81       	ldd	r18, Y+7	; 0x07
     788:	38 85       	ldd	r19, Y+8	; 0x08
     78a:	37 fd       	sbrc	r19, 7
     78c:	20 c0       	rjmp	.+64     	; 0x7ce <__fixsfsi+0x80>
     78e:	6e 81       	ldd	r22, Y+6	; 0x06
     790:	2f 31       	cpi	r18, 0x1F	; 31
     792:	31 05       	cpc	r19, r1
     794:	1c f0       	brlt	.+6      	; 0x79c <__fixsfsi+0x4e>
     796:	66 23       	and	r22, r22
     798:	f9 f0       	breq	.+62     	; 0x7d8 <__fixsfsi+0x8a>
     79a:	23 c0       	rjmp	.+70     	; 0x7e2 <__fixsfsi+0x94>
     79c:	8e e1       	ldi	r24, 0x1E	; 30
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	82 1b       	sub	r24, r18
     7a2:	93 0b       	sbc	r25, r19
     7a4:	29 85       	ldd	r18, Y+9	; 0x09
     7a6:	3a 85       	ldd	r19, Y+10	; 0x0a
     7a8:	4b 85       	ldd	r20, Y+11	; 0x0b
     7aa:	5c 85       	ldd	r21, Y+12	; 0x0c
     7ac:	04 c0       	rjmp	.+8      	; 0x7b6 <__fixsfsi+0x68>
     7ae:	56 95       	lsr	r21
     7b0:	47 95       	ror	r20
     7b2:	37 95       	ror	r19
     7b4:	27 95       	ror	r18
     7b6:	8a 95       	dec	r24
     7b8:	d2 f7       	brpl	.-12     	; 0x7ae <__fixsfsi+0x60>
     7ba:	66 23       	and	r22, r22
     7bc:	b1 f0       	breq	.+44     	; 0x7ea <__fixsfsi+0x9c>
     7be:	50 95       	com	r21
     7c0:	40 95       	com	r20
     7c2:	30 95       	com	r19
     7c4:	21 95       	neg	r18
     7c6:	3f 4f       	sbci	r19, 0xFF	; 255
     7c8:	4f 4f       	sbci	r20, 0xFF	; 255
     7ca:	5f 4f       	sbci	r21, 0xFF	; 255
     7cc:	0e c0       	rjmp	.+28     	; 0x7ea <__fixsfsi+0x9c>
     7ce:	20 e0       	ldi	r18, 0x00	; 0
     7d0:	30 e0       	ldi	r19, 0x00	; 0
     7d2:	40 e0       	ldi	r20, 0x00	; 0
     7d4:	50 e0       	ldi	r21, 0x00	; 0
     7d6:	09 c0       	rjmp	.+18     	; 0x7ea <__fixsfsi+0x9c>
     7d8:	2f ef       	ldi	r18, 0xFF	; 255
     7da:	3f ef       	ldi	r19, 0xFF	; 255
     7dc:	4f ef       	ldi	r20, 0xFF	; 255
     7de:	5f e7       	ldi	r21, 0x7F	; 127
     7e0:	04 c0       	rjmp	.+8      	; 0x7ea <__fixsfsi+0x9c>
     7e2:	20 e0       	ldi	r18, 0x00	; 0
     7e4:	30 e0       	ldi	r19, 0x00	; 0
     7e6:	40 e0       	ldi	r20, 0x00	; 0
     7e8:	50 e8       	ldi	r21, 0x80	; 128
     7ea:	b9 01       	movw	r22, r18
     7ec:	ca 01       	movw	r24, r20
     7ee:	2c 96       	adiw	r28, 0x0c	; 12
     7f0:	e2 e0       	ldi	r30, 0x02	; 2
     7f2:	0c 94 4d 1a 	jmp	0x349a	; 0x349a <__epilogue_restores__+0x20>

000007f6 <__clzsi2>:
     7f6:	ef 92       	push	r14
     7f8:	ff 92       	push	r15
     7fa:	0f 93       	push	r16
     7fc:	1f 93       	push	r17
     7fe:	7b 01       	movw	r14, r22
     800:	8c 01       	movw	r16, r24
     802:	80 e0       	ldi	r24, 0x00	; 0
     804:	e8 16       	cp	r14, r24
     806:	80 e0       	ldi	r24, 0x00	; 0
     808:	f8 06       	cpc	r15, r24
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	08 07       	cpc	r16, r24
     80e:	80 e0       	ldi	r24, 0x00	; 0
     810:	18 07       	cpc	r17, r24
     812:	88 f4       	brcc	.+34     	; 0x836 <__clzsi2+0x40>
     814:	8f ef       	ldi	r24, 0xFF	; 255
     816:	e8 16       	cp	r14, r24
     818:	f1 04       	cpc	r15, r1
     81a:	01 05       	cpc	r16, r1
     81c:	11 05       	cpc	r17, r1
     81e:	31 f0       	breq	.+12     	; 0x82c <__clzsi2+0x36>
     820:	28 f0       	brcs	.+10     	; 0x82c <__clzsi2+0x36>
     822:	88 e0       	ldi	r24, 0x08	; 8
     824:	90 e0       	ldi	r25, 0x00	; 0
     826:	a0 e0       	ldi	r26, 0x00	; 0
     828:	b0 e0       	ldi	r27, 0x00	; 0
     82a:	17 c0       	rjmp	.+46     	; 0x85a <__clzsi2+0x64>
     82c:	80 e0       	ldi	r24, 0x00	; 0
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	a0 e0       	ldi	r26, 0x00	; 0
     832:	b0 e0       	ldi	r27, 0x00	; 0
     834:	12 c0       	rjmp	.+36     	; 0x85a <__clzsi2+0x64>
     836:	80 e0       	ldi	r24, 0x00	; 0
     838:	e8 16       	cp	r14, r24
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	f8 06       	cpc	r15, r24
     83e:	80 e0       	ldi	r24, 0x00	; 0
     840:	08 07       	cpc	r16, r24
     842:	81 e0       	ldi	r24, 0x01	; 1
     844:	18 07       	cpc	r17, r24
     846:	28 f0       	brcs	.+10     	; 0x852 <__clzsi2+0x5c>
     848:	88 e1       	ldi	r24, 0x18	; 24
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	a0 e0       	ldi	r26, 0x00	; 0
     84e:	b0 e0       	ldi	r27, 0x00	; 0
     850:	04 c0       	rjmp	.+8      	; 0x85a <__clzsi2+0x64>
     852:	80 e1       	ldi	r24, 0x10	; 16
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	a0 e0       	ldi	r26, 0x00	; 0
     858:	b0 e0       	ldi	r27, 0x00	; 0
     85a:	20 e2       	ldi	r18, 0x20	; 32
     85c:	30 e0       	ldi	r19, 0x00	; 0
     85e:	40 e0       	ldi	r20, 0x00	; 0
     860:	50 e0       	ldi	r21, 0x00	; 0
     862:	28 1b       	sub	r18, r24
     864:	39 0b       	sbc	r19, r25
     866:	4a 0b       	sbc	r20, r26
     868:	5b 0b       	sbc	r21, r27
     86a:	04 c0       	rjmp	.+8      	; 0x874 <__stack+0x15>
     86c:	16 95       	lsr	r17
     86e:	07 95       	ror	r16
     870:	f7 94       	ror	r15
     872:	e7 94       	ror	r14
     874:	8a 95       	dec	r24
     876:	d2 f7       	brpl	.-12     	; 0x86c <__stack+0xd>
     878:	f7 01       	movw	r30, r14
     87a:	e3 58       	subi	r30, 0x83	; 131
     87c:	ff 4f       	sbci	r31, 0xFF	; 255
     87e:	80 81       	ld	r24, Z
     880:	28 1b       	sub	r18, r24
     882:	31 09       	sbc	r19, r1
     884:	41 09       	sbc	r20, r1
     886:	51 09       	sbc	r21, r1
     888:	c9 01       	movw	r24, r18
     88a:	1f 91       	pop	r17
     88c:	0f 91       	pop	r16
     88e:	ff 90       	pop	r15
     890:	ef 90       	pop	r14
     892:	08 95       	ret

00000894 <__pack_f>:
     894:	df 92       	push	r13
     896:	ef 92       	push	r14
     898:	ff 92       	push	r15
     89a:	0f 93       	push	r16
     89c:	1f 93       	push	r17
     89e:	fc 01       	movw	r30, r24
     8a0:	e4 80       	ldd	r14, Z+4	; 0x04
     8a2:	f5 80       	ldd	r15, Z+5	; 0x05
     8a4:	06 81       	ldd	r16, Z+6	; 0x06
     8a6:	17 81       	ldd	r17, Z+7	; 0x07
     8a8:	d1 80       	ldd	r13, Z+1	; 0x01
     8aa:	80 81       	ld	r24, Z
     8ac:	82 30       	cpi	r24, 0x02	; 2
     8ae:	48 f4       	brcc	.+18     	; 0x8c2 <__pack_f+0x2e>
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e1       	ldi	r26, 0x10	; 16
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	e8 2a       	or	r14, r24
     8ba:	f9 2a       	or	r15, r25
     8bc:	0a 2b       	or	r16, r26
     8be:	1b 2b       	or	r17, r27
     8c0:	a5 c0       	rjmp	.+330    	; 0xa0c <__pack_f+0x178>
     8c2:	84 30       	cpi	r24, 0x04	; 4
     8c4:	09 f4       	brne	.+2      	; 0x8c8 <__pack_f+0x34>
     8c6:	9f c0       	rjmp	.+318    	; 0xa06 <__pack_f+0x172>
     8c8:	82 30       	cpi	r24, 0x02	; 2
     8ca:	21 f4       	brne	.+8      	; 0x8d4 <__pack_f+0x40>
     8cc:	ee 24       	eor	r14, r14
     8ce:	ff 24       	eor	r15, r15
     8d0:	87 01       	movw	r16, r14
     8d2:	05 c0       	rjmp	.+10     	; 0x8de <__pack_f+0x4a>
     8d4:	e1 14       	cp	r14, r1
     8d6:	f1 04       	cpc	r15, r1
     8d8:	01 05       	cpc	r16, r1
     8da:	11 05       	cpc	r17, r1
     8dc:	19 f4       	brne	.+6      	; 0x8e4 <__pack_f+0x50>
     8de:	e0 e0       	ldi	r30, 0x00	; 0
     8e0:	f0 e0       	ldi	r31, 0x00	; 0
     8e2:	96 c0       	rjmp	.+300    	; 0xa10 <__pack_f+0x17c>
     8e4:	62 81       	ldd	r22, Z+2	; 0x02
     8e6:	73 81       	ldd	r23, Z+3	; 0x03
     8e8:	9f ef       	ldi	r25, 0xFF	; 255
     8ea:	62 38       	cpi	r22, 0x82	; 130
     8ec:	79 07       	cpc	r23, r25
     8ee:	0c f0       	brlt	.+2      	; 0x8f2 <__pack_f+0x5e>
     8f0:	5b c0       	rjmp	.+182    	; 0x9a8 <__pack_f+0x114>
     8f2:	22 e8       	ldi	r18, 0x82	; 130
     8f4:	3f ef       	ldi	r19, 0xFF	; 255
     8f6:	26 1b       	sub	r18, r22
     8f8:	37 0b       	sbc	r19, r23
     8fa:	2a 31       	cpi	r18, 0x1A	; 26
     8fc:	31 05       	cpc	r19, r1
     8fe:	2c f0       	brlt	.+10     	; 0x90a <__pack_f+0x76>
     900:	20 e0       	ldi	r18, 0x00	; 0
     902:	30 e0       	ldi	r19, 0x00	; 0
     904:	40 e0       	ldi	r20, 0x00	; 0
     906:	50 e0       	ldi	r21, 0x00	; 0
     908:	2a c0       	rjmp	.+84     	; 0x95e <__pack_f+0xca>
     90a:	b8 01       	movw	r22, r16
     90c:	a7 01       	movw	r20, r14
     90e:	02 2e       	mov	r0, r18
     910:	04 c0       	rjmp	.+8      	; 0x91a <__pack_f+0x86>
     912:	76 95       	lsr	r23
     914:	67 95       	ror	r22
     916:	57 95       	ror	r21
     918:	47 95       	ror	r20
     91a:	0a 94       	dec	r0
     91c:	d2 f7       	brpl	.-12     	; 0x912 <__pack_f+0x7e>
     91e:	81 e0       	ldi	r24, 0x01	; 1
     920:	90 e0       	ldi	r25, 0x00	; 0
     922:	a0 e0       	ldi	r26, 0x00	; 0
     924:	b0 e0       	ldi	r27, 0x00	; 0
     926:	04 c0       	rjmp	.+8      	; 0x930 <__pack_f+0x9c>
     928:	88 0f       	add	r24, r24
     92a:	99 1f       	adc	r25, r25
     92c:	aa 1f       	adc	r26, r26
     92e:	bb 1f       	adc	r27, r27
     930:	2a 95       	dec	r18
     932:	d2 f7       	brpl	.-12     	; 0x928 <__pack_f+0x94>
     934:	01 97       	sbiw	r24, 0x01	; 1
     936:	a1 09       	sbc	r26, r1
     938:	b1 09       	sbc	r27, r1
     93a:	8e 21       	and	r24, r14
     93c:	9f 21       	and	r25, r15
     93e:	a0 23       	and	r26, r16
     940:	b1 23       	and	r27, r17
     942:	00 97       	sbiw	r24, 0x00	; 0
     944:	a1 05       	cpc	r26, r1
     946:	b1 05       	cpc	r27, r1
     948:	21 f0       	breq	.+8      	; 0x952 <__pack_f+0xbe>
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	90 e0       	ldi	r25, 0x00	; 0
     94e:	a0 e0       	ldi	r26, 0x00	; 0
     950:	b0 e0       	ldi	r27, 0x00	; 0
     952:	9a 01       	movw	r18, r20
     954:	ab 01       	movw	r20, r22
     956:	28 2b       	or	r18, r24
     958:	39 2b       	or	r19, r25
     95a:	4a 2b       	or	r20, r26
     95c:	5b 2b       	or	r21, r27
     95e:	da 01       	movw	r26, r20
     960:	c9 01       	movw	r24, r18
     962:	8f 77       	andi	r24, 0x7F	; 127
     964:	90 70       	andi	r25, 0x00	; 0
     966:	a0 70       	andi	r26, 0x00	; 0
     968:	b0 70       	andi	r27, 0x00	; 0
     96a:	80 34       	cpi	r24, 0x40	; 64
     96c:	91 05       	cpc	r25, r1
     96e:	a1 05       	cpc	r26, r1
     970:	b1 05       	cpc	r27, r1
     972:	39 f4       	brne	.+14     	; 0x982 <__pack_f+0xee>
     974:	27 ff       	sbrs	r18, 7
     976:	09 c0       	rjmp	.+18     	; 0x98a <__pack_f+0xf6>
     978:	20 5c       	subi	r18, 0xC0	; 192
     97a:	3f 4f       	sbci	r19, 0xFF	; 255
     97c:	4f 4f       	sbci	r20, 0xFF	; 255
     97e:	5f 4f       	sbci	r21, 0xFF	; 255
     980:	04 c0       	rjmp	.+8      	; 0x98a <__pack_f+0xf6>
     982:	21 5c       	subi	r18, 0xC1	; 193
     984:	3f 4f       	sbci	r19, 0xFF	; 255
     986:	4f 4f       	sbci	r20, 0xFF	; 255
     988:	5f 4f       	sbci	r21, 0xFF	; 255
     98a:	e0 e0       	ldi	r30, 0x00	; 0
     98c:	f0 e0       	ldi	r31, 0x00	; 0
     98e:	20 30       	cpi	r18, 0x00	; 0
     990:	a0 e0       	ldi	r26, 0x00	; 0
     992:	3a 07       	cpc	r19, r26
     994:	a0 e0       	ldi	r26, 0x00	; 0
     996:	4a 07       	cpc	r20, r26
     998:	a0 e4       	ldi	r26, 0x40	; 64
     99a:	5a 07       	cpc	r21, r26
     99c:	10 f0       	brcs	.+4      	; 0x9a2 <__pack_f+0x10e>
     99e:	e1 e0       	ldi	r30, 0x01	; 1
     9a0:	f0 e0       	ldi	r31, 0x00	; 0
     9a2:	79 01       	movw	r14, r18
     9a4:	8a 01       	movw	r16, r20
     9a6:	27 c0       	rjmp	.+78     	; 0x9f6 <__pack_f+0x162>
     9a8:	60 38       	cpi	r22, 0x80	; 128
     9aa:	71 05       	cpc	r23, r1
     9ac:	64 f5       	brge	.+88     	; 0xa06 <__pack_f+0x172>
     9ae:	fb 01       	movw	r30, r22
     9b0:	e1 58       	subi	r30, 0x81	; 129
     9b2:	ff 4f       	sbci	r31, 0xFF	; 255
     9b4:	d8 01       	movw	r26, r16
     9b6:	c7 01       	movw	r24, r14
     9b8:	8f 77       	andi	r24, 0x7F	; 127
     9ba:	90 70       	andi	r25, 0x00	; 0
     9bc:	a0 70       	andi	r26, 0x00	; 0
     9be:	b0 70       	andi	r27, 0x00	; 0
     9c0:	80 34       	cpi	r24, 0x40	; 64
     9c2:	91 05       	cpc	r25, r1
     9c4:	a1 05       	cpc	r26, r1
     9c6:	b1 05       	cpc	r27, r1
     9c8:	39 f4       	brne	.+14     	; 0x9d8 <__pack_f+0x144>
     9ca:	e7 fe       	sbrs	r14, 7
     9cc:	0d c0       	rjmp	.+26     	; 0x9e8 <__pack_f+0x154>
     9ce:	80 e4       	ldi	r24, 0x40	; 64
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	a0 e0       	ldi	r26, 0x00	; 0
     9d4:	b0 e0       	ldi	r27, 0x00	; 0
     9d6:	04 c0       	rjmp	.+8      	; 0x9e0 <__pack_f+0x14c>
     9d8:	8f e3       	ldi	r24, 0x3F	; 63
     9da:	90 e0       	ldi	r25, 0x00	; 0
     9dc:	a0 e0       	ldi	r26, 0x00	; 0
     9de:	b0 e0       	ldi	r27, 0x00	; 0
     9e0:	e8 0e       	add	r14, r24
     9e2:	f9 1e       	adc	r15, r25
     9e4:	0a 1f       	adc	r16, r26
     9e6:	1b 1f       	adc	r17, r27
     9e8:	17 ff       	sbrs	r17, 7
     9ea:	05 c0       	rjmp	.+10     	; 0x9f6 <__pack_f+0x162>
     9ec:	16 95       	lsr	r17
     9ee:	07 95       	ror	r16
     9f0:	f7 94       	ror	r15
     9f2:	e7 94       	ror	r14
     9f4:	31 96       	adiw	r30, 0x01	; 1
     9f6:	87 e0       	ldi	r24, 0x07	; 7
     9f8:	16 95       	lsr	r17
     9fa:	07 95       	ror	r16
     9fc:	f7 94       	ror	r15
     9fe:	e7 94       	ror	r14
     a00:	8a 95       	dec	r24
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__pack_f+0x164>
     a04:	05 c0       	rjmp	.+10     	; 0xa10 <__pack_f+0x17c>
     a06:	ee 24       	eor	r14, r14
     a08:	ff 24       	eor	r15, r15
     a0a:	87 01       	movw	r16, r14
     a0c:	ef ef       	ldi	r30, 0xFF	; 255
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	6e 2f       	mov	r22, r30
     a12:	67 95       	ror	r22
     a14:	66 27       	eor	r22, r22
     a16:	67 95       	ror	r22
     a18:	90 2f       	mov	r25, r16
     a1a:	9f 77       	andi	r25, 0x7F	; 127
     a1c:	d7 94       	ror	r13
     a1e:	dd 24       	eor	r13, r13
     a20:	d7 94       	ror	r13
     a22:	8e 2f       	mov	r24, r30
     a24:	86 95       	lsr	r24
     a26:	49 2f       	mov	r20, r25
     a28:	46 2b       	or	r20, r22
     a2a:	58 2f       	mov	r21, r24
     a2c:	5d 29       	or	r21, r13
     a2e:	b7 01       	movw	r22, r14
     a30:	ca 01       	movw	r24, r20
     a32:	1f 91       	pop	r17
     a34:	0f 91       	pop	r16
     a36:	ff 90       	pop	r15
     a38:	ef 90       	pop	r14
     a3a:	df 90       	pop	r13
     a3c:	08 95       	ret

00000a3e <__unpack_f>:
     a3e:	fc 01       	movw	r30, r24
     a40:	db 01       	movw	r26, r22
     a42:	40 81       	ld	r20, Z
     a44:	51 81       	ldd	r21, Z+1	; 0x01
     a46:	22 81       	ldd	r18, Z+2	; 0x02
     a48:	62 2f       	mov	r22, r18
     a4a:	6f 77       	andi	r22, 0x7F	; 127
     a4c:	70 e0       	ldi	r23, 0x00	; 0
     a4e:	22 1f       	adc	r18, r18
     a50:	22 27       	eor	r18, r18
     a52:	22 1f       	adc	r18, r18
     a54:	93 81       	ldd	r25, Z+3	; 0x03
     a56:	89 2f       	mov	r24, r25
     a58:	88 0f       	add	r24, r24
     a5a:	82 2b       	or	r24, r18
     a5c:	28 2f       	mov	r18, r24
     a5e:	30 e0       	ldi	r19, 0x00	; 0
     a60:	99 1f       	adc	r25, r25
     a62:	99 27       	eor	r25, r25
     a64:	99 1f       	adc	r25, r25
     a66:	11 96       	adiw	r26, 0x01	; 1
     a68:	9c 93       	st	X, r25
     a6a:	11 97       	sbiw	r26, 0x01	; 1
     a6c:	21 15       	cp	r18, r1
     a6e:	31 05       	cpc	r19, r1
     a70:	a9 f5       	brne	.+106    	; 0xadc <__unpack_f+0x9e>
     a72:	41 15       	cp	r20, r1
     a74:	51 05       	cpc	r21, r1
     a76:	61 05       	cpc	r22, r1
     a78:	71 05       	cpc	r23, r1
     a7a:	11 f4       	brne	.+4      	; 0xa80 <__unpack_f+0x42>
     a7c:	82 e0       	ldi	r24, 0x02	; 2
     a7e:	37 c0       	rjmp	.+110    	; 0xaee <__unpack_f+0xb0>
     a80:	82 e8       	ldi	r24, 0x82	; 130
     a82:	9f ef       	ldi	r25, 0xFF	; 255
     a84:	13 96       	adiw	r26, 0x03	; 3
     a86:	9c 93       	st	X, r25
     a88:	8e 93       	st	-X, r24
     a8a:	12 97       	sbiw	r26, 0x02	; 2
     a8c:	9a 01       	movw	r18, r20
     a8e:	ab 01       	movw	r20, r22
     a90:	67 e0       	ldi	r22, 0x07	; 7
     a92:	22 0f       	add	r18, r18
     a94:	33 1f       	adc	r19, r19
     a96:	44 1f       	adc	r20, r20
     a98:	55 1f       	adc	r21, r21
     a9a:	6a 95       	dec	r22
     a9c:	d1 f7       	brne	.-12     	; 0xa92 <__unpack_f+0x54>
     a9e:	83 e0       	ldi	r24, 0x03	; 3
     aa0:	8c 93       	st	X, r24
     aa2:	0d c0       	rjmp	.+26     	; 0xabe <__unpack_f+0x80>
     aa4:	22 0f       	add	r18, r18
     aa6:	33 1f       	adc	r19, r19
     aa8:	44 1f       	adc	r20, r20
     aaa:	55 1f       	adc	r21, r21
     aac:	12 96       	adiw	r26, 0x02	; 2
     aae:	8d 91       	ld	r24, X+
     ab0:	9c 91       	ld	r25, X
     ab2:	13 97       	sbiw	r26, 0x03	; 3
     ab4:	01 97       	sbiw	r24, 0x01	; 1
     ab6:	13 96       	adiw	r26, 0x03	; 3
     ab8:	9c 93       	st	X, r25
     aba:	8e 93       	st	-X, r24
     abc:	12 97       	sbiw	r26, 0x02	; 2
     abe:	20 30       	cpi	r18, 0x00	; 0
     ac0:	80 e0       	ldi	r24, 0x00	; 0
     ac2:	38 07       	cpc	r19, r24
     ac4:	80 e0       	ldi	r24, 0x00	; 0
     ac6:	48 07       	cpc	r20, r24
     ac8:	80 e4       	ldi	r24, 0x40	; 64
     aca:	58 07       	cpc	r21, r24
     acc:	58 f3       	brcs	.-42     	; 0xaa4 <__unpack_f+0x66>
     ace:	14 96       	adiw	r26, 0x04	; 4
     ad0:	2d 93       	st	X+, r18
     ad2:	3d 93       	st	X+, r19
     ad4:	4d 93       	st	X+, r20
     ad6:	5c 93       	st	X, r21
     ad8:	17 97       	sbiw	r26, 0x07	; 7
     ada:	08 95       	ret
     adc:	2f 3f       	cpi	r18, 0xFF	; 255
     ade:	31 05       	cpc	r19, r1
     ae0:	79 f4       	brne	.+30     	; 0xb00 <__unpack_f+0xc2>
     ae2:	41 15       	cp	r20, r1
     ae4:	51 05       	cpc	r21, r1
     ae6:	61 05       	cpc	r22, r1
     ae8:	71 05       	cpc	r23, r1
     aea:	19 f4       	brne	.+6      	; 0xaf2 <__unpack_f+0xb4>
     aec:	84 e0       	ldi	r24, 0x04	; 4
     aee:	8c 93       	st	X, r24
     af0:	08 95       	ret
     af2:	64 ff       	sbrs	r22, 4
     af4:	03 c0       	rjmp	.+6      	; 0xafc <__unpack_f+0xbe>
     af6:	81 e0       	ldi	r24, 0x01	; 1
     af8:	8c 93       	st	X, r24
     afa:	12 c0       	rjmp	.+36     	; 0xb20 <__unpack_f+0xe2>
     afc:	1c 92       	st	X, r1
     afe:	10 c0       	rjmp	.+32     	; 0xb20 <__unpack_f+0xe2>
     b00:	2f 57       	subi	r18, 0x7F	; 127
     b02:	30 40       	sbci	r19, 0x00	; 0
     b04:	13 96       	adiw	r26, 0x03	; 3
     b06:	3c 93       	st	X, r19
     b08:	2e 93       	st	-X, r18
     b0a:	12 97       	sbiw	r26, 0x02	; 2
     b0c:	83 e0       	ldi	r24, 0x03	; 3
     b0e:	8c 93       	st	X, r24
     b10:	87 e0       	ldi	r24, 0x07	; 7
     b12:	44 0f       	add	r20, r20
     b14:	55 1f       	adc	r21, r21
     b16:	66 1f       	adc	r22, r22
     b18:	77 1f       	adc	r23, r23
     b1a:	8a 95       	dec	r24
     b1c:	d1 f7       	brne	.-12     	; 0xb12 <__unpack_f+0xd4>
     b1e:	70 64       	ori	r23, 0x40	; 64
     b20:	14 96       	adiw	r26, 0x04	; 4
     b22:	4d 93       	st	X+, r20
     b24:	5d 93       	st	X+, r21
     b26:	6d 93       	st	X+, r22
     b28:	7c 93       	st	X, r23
     b2a:	17 97       	sbiw	r26, 0x07	; 7
     b2c:	08 95       	ret

00000b2e <__fpcmp_parts_f>:
     b2e:	1f 93       	push	r17
     b30:	dc 01       	movw	r26, r24
     b32:	fb 01       	movw	r30, r22
     b34:	9c 91       	ld	r25, X
     b36:	92 30       	cpi	r25, 0x02	; 2
     b38:	08 f4       	brcc	.+2      	; 0xb3c <__fpcmp_parts_f+0xe>
     b3a:	47 c0       	rjmp	.+142    	; 0xbca <__fpcmp_parts_f+0x9c>
     b3c:	80 81       	ld	r24, Z
     b3e:	82 30       	cpi	r24, 0x02	; 2
     b40:	08 f4       	brcc	.+2      	; 0xb44 <__fpcmp_parts_f+0x16>
     b42:	43 c0       	rjmp	.+134    	; 0xbca <__fpcmp_parts_f+0x9c>
     b44:	94 30       	cpi	r25, 0x04	; 4
     b46:	51 f4       	brne	.+20     	; 0xb5c <__fpcmp_parts_f+0x2e>
     b48:	11 96       	adiw	r26, 0x01	; 1
     b4a:	1c 91       	ld	r17, X
     b4c:	84 30       	cpi	r24, 0x04	; 4
     b4e:	99 f5       	brne	.+102    	; 0xbb6 <__fpcmp_parts_f+0x88>
     b50:	81 81       	ldd	r24, Z+1	; 0x01
     b52:	68 2f       	mov	r22, r24
     b54:	70 e0       	ldi	r23, 0x00	; 0
     b56:	61 1b       	sub	r22, r17
     b58:	71 09       	sbc	r23, r1
     b5a:	3f c0       	rjmp	.+126    	; 0xbda <__fpcmp_parts_f+0xac>
     b5c:	84 30       	cpi	r24, 0x04	; 4
     b5e:	21 f0       	breq	.+8      	; 0xb68 <__fpcmp_parts_f+0x3a>
     b60:	92 30       	cpi	r25, 0x02	; 2
     b62:	31 f4       	brne	.+12     	; 0xb70 <__fpcmp_parts_f+0x42>
     b64:	82 30       	cpi	r24, 0x02	; 2
     b66:	b9 f1       	breq	.+110    	; 0xbd6 <__fpcmp_parts_f+0xa8>
     b68:	81 81       	ldd	r24, Z+1	; 0x01
     b6a:	88 23       	and	r24, r24
     b6c:	89 f1       	breq	.+98     	; 0xbd0 <__fpcmp_parts_f+0xa2>
     b6e:	2d c0       	rjmp	.+90     	; 0xbca <__fpcmp_parts_f+0x9c>
     b70:	11 96       	adiw	r26, 0x01	; 1
     b72:	1c 91       	ld	r17, X
     b74:	11 97       	sbiw	r26, 0x01	; 1
     b76:	82 30       	cpi	r24, 0x02	; 2
     b78:	f1 f0       	breq	.+60     	; 0xbb6 <__fpcmp_parts_f+0x88>
     b7a:	81 81       	ldd	r24, Z+1	; 0x01
     b7c:	18 17       	cp	r17, r24
     b7e:	d9 f4       	brne	.+54     	; 0xbb6 <__fpcmp_parts_f+0x88>
     b80:	12 96       	adiw	r26, 0x02	; 2
     b82:	2d 91       	ld	r18, X+
     b84:	3c 91       	ld	r19, X
     b86:	13 97       	sbiw	r26, 0x03	; 3
     b88:	82 81       	ldd	r24, Z+2	; 0x02
     b8a:	93 81       	ldd	r25, Z+3	; 0x03
     b8c:	82 17       	cp	r24, r18
     b8e:	93 07       	cpc	r25, r19
     b90:	94 f0       	brlt	.+36     	; 0xbb6 <__fpcmp_parts_f+0x88>
     b92:	28 17       	cp	r18, r24
     b94:	39 07       	cpc	r19, r25
     b96:	bc f0       	brlt	.+46     	; 0xbc6 <__fpcmp_parts_f+0x98>
     b98:	14 96       	adiw	r26, 0x04	; 4
     b9a:	8d 91       	ld	r24, X+
     b9c:	9d 91       	ld	r25, X+
     b9e:	0d 90       	ld	r0, X+
     ba0:	bc 91       	ld	r27, X
     ba2:	a0 2d       	mov	r26, r0
     ba4:	24 81       	ldd	r18, Z+4	; 0x04
     ba6:	35 81       	ldd	r19, Z+5	; 0x05
     ba8:	46 81       	ldd	r20, Z+6	; 0x06
     baa:	57 81       	ldd	r21, Z+7	; 0x07
     bac:	28 17       	cp	r18, r24
     bae:	39 07       	cpc	r19, r25
     bb0:	4a 07       	cpc	r20, r26
     bb2:	5b 07       	cpc	r21, r27
     bb4:	18 f4       	brcc	.+6      	; 0xbbc <__fpcmp_parts_f+0x8e>
     bb6:	11 23       	and	r17, r17
     bb8:	41 f0       	breq	.+16     	; 0xbca <__fpcmp_parts_f+0x9c>
     bba:	0a c0       	rjmp	.+20     	; 0xbd0 <__fpcmp_parts_f+0xa2>
     bbc:	82 17       	cp	r24, r18
     bbe:	93 07       	cpc	r25, r19
     bc0:	a4 07       	cpc	r26, r20
     bc2:	b5 07       	cpc	r27, r21
     bc4:	40 f4       	brcc	.+16     	; 0xbd6 <__fpcmp_parts_f+0xa8>
     bc6:	11 23       	and	r17, r17
     bc8:	19 f0       	breq	.+6      	; 0xbd0 <__fpcmp_parts_f+0xa2>
     bca:	61 e0       	ldi	r22, 0x01	; 1
     bcc:	70 e0       	ldi	r23, 0x00	; 0
     bce:	05 c0       	rjmp	.+10     	; 0xbda <__fpcmp_parts_f+0xac>
     bd0:	6f ef       	ldi	r22, 0xFF	; 255
     bd2:	7f ef       	ldi	r23, 0xFF	; 255
     bd4:	02 c0       	rjmp	.+4      	; 0xbda <__fpcmp_parts_f+0xac>
     bd6:	60 e0       	ldi	r22, 0x00	; 0
     bd8:	70 e0       	ldi	r23, 0x00	; 0
     bda:	cb 01       	movw	r24, r22
     bdc:	1f 91       	pop	r17
     bde:	08 95       	ret

00000be0 <SPI_voidInit>:



void SPI_voidInit(u8 Copy_u8SPIType){
	//switch on Mode
	switch(Copy_u8SPIType){
     be0:	88 23       	and	r24, r24
     be2:	19 f0       	breq	.+6      	; 0xbea <SPI_voidInit+0xa>
     be4:	81 30       	cpi	r24, 0x01	; 1
     be6:	59 f4       	brne	.+22     	; 0xbfe <SPI_voidInit+0x1e>
     be8:	08 c0       	rjmp	.+16     	; 0xbfa <SPI_voidInit+0x1a>
	case Master:
		//select master
		SET_BIT(SPCR,MSTR);
     bea:	6c 9a       	sbi	0x0d, 4	; 13
		//select speed
		SPCR &= (0b11111100)|(fosc_8%4);
     bec:	69 98       	cbi	0x0d, 1	; 13
		#if Clock_Rate_mode < 3
			CLR_BIT(SPSR,SPI2X);
		#else
			SET_BIT(SPSR,SPI2X);
     bee:	70 9a       	sbi	0x0e, 0	; 14
		#endif
		SET_BIT(DDRB,PIN5);// set MOSI as Out
     bf0:	bd 9a       	sbi	0x17, 5	; 23
		CLR_BIT(DDRB,PIN6);// set MISO as In
     bf2:	be 98       	cbi	0x17, 6	; 23
		SET_BIT(DDRB,PIN7);// set SCLK as Out
     bf4:	bf 9a       	sbi	0x17, 7	; 23
		SET_BIT(DDRB,PIN4);// set ss as Out
     bf6:	bc 9a       	sbi	0x17, 4	; 23
     bf8:	02 c0       	rjmp	.+4      	; 0xbfe <SPI_voidInit+0x1e>
		break;
	case Slave :
		//select slave
		CLR_BIT(SPCR,MSTR);
     bfa:	6c 98       	cbi	0x0d, 4	; 13
		SET_BIT(DDRB,PIN6);// set MISO as Out
     bfc:	be 9a       	sbi	0x17, 6	; 23
		break;
	default:
		break;
	}
	//select Data Order (MSB frist)
	CLR_BIT(SPCR,DORD);
     bfe:	6d 98       	cbi	0x0d, 5	; 13
	//select clock polarity active
	CLR_BIT(SPCR,CPOL);
     c00:	6b 98       	cbi	0x0d, 3	; 13
	//select clock phase  1-setup 2-sample
	SET_BIT(SPCR,CPHA);
     c02:	6a 9a       	sbi	0x0d, 2	; 13
	//enable SPI Periphral
	SET_BIT(SPCR,SPE);
     c04:	6e 9a       	sbi	0x0d, 6	; 13
}
     c06:	08 95       	ret

00000c08 <SPI_u8transcieve>:

u8   SPI_u8transcieve	(u8 Copy_u8TransmitByte){
	//put Data to begin transmition
	SPDR = Copy_u8TransmitByte ;
     c08:	8f b9       	out	0x0f, r24	; 15
	//wait until transmition ends
	while(GET_BIT(SPSR,SPIF) == 0);
     c0a:	77 9b       	sbis	0x0e, 7	; 14
     c0c:	fe cf       	rjmp	.-4      	; 0xc0a <SPI_u8transcieve+0x2>
	//return the data
	return SPDR ;
     c0e:	8f b1       	in	r24, 0x0f	; 15
}
     c10:	08 95       	ret

00000c12 <ADC_init>:
#include "../../LIB/STD_TYPES.h"
#include "../../LIB/BIT_MATH.h"
#include "ADC.h"

void ADC_init(){
	ADMUX = 0;
     c12:	17 b8       	out	0x07, r1	; 7
	SET_BIT(ADCSRA, ADEN);
     c14:	37 9a       	sbi	0x06, 7	; 6
}
     c16:	08 95       	ret

00000c18 <ADC_read>:

u16 ADC_read(u8 bit_num){
	ADMUX = (ADMUX & 0xF8) | (bit_num & 0x07);
     c18:	97 b1       	in	r25, 0x07	; 7
     c1a:	87 70       	andi	r24, 0x07	; 7
     c1c:	98 7f       	andi	r25, 0xF8	; 248
     c1e:	89 2b       	or	r24, r25
     c20:	87 b9       	out	0x07, r24	; 7
	SET_BIT(ADCSRA,ADSC);
     c22:	36 9a       	sbi	0x06, 6	; 6
	while(GET_BIT(ADCSRA,ADIF)==0);
     c24:	34 9b       	sbis	0x06, 4	; 6
     c26:	fe cf       	rjmp	.-4      	; 0xc24 <ADC_read+0xc>
	return ADCL | (ADCH << 8);
     c28:	24 b1       	in	r18, 0x04	; 4
     c2a:	45 b1       	in	r20, 0x05	; 5
     c2c:	94 2f       	mov	r25, r20
     c2e:	80 e0       	ldi	r24, 0x00	; 0
     c30:	30 e0       	ldi	r19, 0x00	; 0
     c32:	28 2b       	or	r18, r24
     c34:	39 2b       	or	r19, r25
}
     c36:	c9 01       	movw	r24, r18
     c38:	08 95       	ret

00000c3a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    return xFreeBytesRemaining;
}
     c3a:	80 91 86 01 	lds	r24, 0x0186
     c3e:	90 91 87 01 	lds	r25, 0x0187
     c42:	08 95       	ret

00000c44 <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
    return xMinimumEverFreeBytesRemaining;
}
     c44:	80 91 8c 01 	lds	r24, 0x018C
     c48:	90 91 8d 01 	lds	r25, 0x018D
     c4c:	08 95       	ret

00000c4e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    /* This just exists to keep the linker quiet. */
}
     c4e:	08 95       	ret

00000c50 <prvInsertBlockIntoFreeList>:
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	fc 01       	movw	r30, r24
     c56:	c6 ee       	ldi	r28, 0xE6	; 230
     c58:	d3 e0       	ldi	r29, 0x03	; 3
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     c5a:	88 81       	ld	r24, Y
     c5c:	99 81       	ldd	r25, Y+1	; 0x01
     c5e:	8e 17       	cp	r24, r30
     c60:	9f 07       	cpc	r25, r31
     c62:	10 f4       	brcc	.+4      	; 0xc68 <prvInsertBlockIntoFreeList+0x18>
     c64:	ec 01       	movw	r28, r24
     c66:	f9 cf       	rjmp	.-14     	; 0xc5a <prvInsertBlockIntoFreeList+0xa>

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     c68:	2a 81       	ldd	r18, Y+2	; 0x02
     c6a:	3b 81       	ldd	r19, Y+3	; 0x03
     c6c:	ce 01       	movw	r24, r28
     c6e:	82 0f       	add	r24, r18
     c70:	93 1f       	adc	r25, r19
     c72:	e8 17       	cp	r30, r24
     c74:	f9 07       	cpc	r31, r25
     c76:	39 f4       	brne	.+14     	; 0xc86 <prvInsertBlockIntoFreeList+0x36>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     c78:	82 81       	ldd	r24, Z+2	; 0x02
     c7a:	93 81       	ldd	r25, Z+3	; 0x03
     c7c:	82 0f       	add	r24, r18
     c7e:	93 1f       	adc	r25, r19
     c80:	9b 83       	std	Y+3, r25	; 0x03
     c82:	8a 83       	std	Y+2, r24	; 0x02
     c84:	fe 01       	movw	r30, r28

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     c86:	22 81       	ldd	r18, Z+2	; 0x02
     c88:	33 81       	ldd	r19, Z+3	; 0x03
     c8a:	a8 81       	ld	r26, Y
     c8c:	b9 81       	ldd	r27, Y+1	; 0x01
     c8e:	cf 01       	movw	r24, r30
     c90:	82 0f       	add	r24, r18
     c92:	93 1f       	adc	r25, r19
     c94:	a8 17       	cp	r26, r24
     c96:	b9 07       	cpc	r27, r25
     c98:	a1 f4       	brne	.+40     	; 0xcc2 <prvInsertBlockIntoFreeList+0x72>
    {
        if( pxIterator->pxNextFreeBlock != pxEnd )
     c9a:	80 91 84 01 	lds	r24, 0x0184
     c9e:	90 91 85 01 	lds	r25, 0x0185
     ca2:	a8 17       	cp	r26, r24
     ca4:	b9 07       	cpc	r27, r25
     ca6:	69 f0       	breq	.+26     	; 0xcc2 <prvInsertBlockIntoFreeList+0x72>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     ca8:	12 96       	adiw	r26, 0x02	; 2
     caa:	8d 91       	ld	r24, X+
     cac:	9c 91       	ld	r25, X
     cae:	13 97       	sbiw	r26, 0x03	; 3
     cb0:	82 0f       	add	r24, r18
     cb2:	93 1f       	adc	r25, r19
     cb4:	93 83       	std	Z+3, r25	; 0x03
     cb6:	82 83       	std	Z+2, r24	; 0x02
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     cb8:	8d 91       	ld	r24, X+
     cba:	9c 91       	ld	r25, X
     cbc:	91 83       	std	Z+1, r25	; 0x01
     cbe:	80 83       	st	Z, r24
     cc0:	02 c0       	rjmp	.+4      	; 0xcc6 <prvInsertBlockIntoFreeList+0x76>
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     cc2:	b1 83       	std	Z+1, r27	; 0x01
     cc4:	a0 83       	st	Z, r26

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
     cc6:	ce 17       	cp	r28, r30
     cc8:	df 07       	cpc	r29, r31
     cca:	11 f0       	breq	.+4      	; 0xcd0 <prvInsertBlockIntoFreeList+0x80>
    {
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
     ccc:	f9 83       	std	Y+1, r31	; 0x01
     cce:	e8 83       	st	Y, r30
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
     cd0:	df 91       	pop	r29
     cd2:	cf 91       	pop	r28
     cd4:	08 95       	ret

00000cd6 <vPortGetHeapStats>:
/*-----------------------------------------------------------*/

void vPortGetHeapStats( HeapStats_t * pxHeapStats )
{
     cd6:	cf 92       	push	r12
     cd8:	df 92       	push	r13
     cda:	ef 92       	push	r14
     cdc:	ff 92       	push	r15
     cde:	0f 93       	push	r16
     ce0:	1f 93       	push	r17
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
     ce6:	ec 01       	movw	r28, r24
    BlockLink_t * pxBlock;
    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */

    vTaskSuspendAll();
     ce8:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vTaskSuspendAll>
    {
        pxBlock = xStart.pxNextFreeBlock;
     cec:	e0 91 e6 03 	lds	r30, 0x03E6
     cf0:	f0 91 e7 03 	lds	r31, 0x03E7

        /* pxBlock will be NULL if the heap has not been initialised.  The heap
         * is initialised automatically when the first allocation is made. */
        if( pxBlock != NULL )
     cf4:	30 97       	sbiw	r30, 0x00	; 0
     cf6:	39 f4       	brne	.+14     	; 0xd06 <vPortGetHeapStats+0x30>
     cf8:	cc 24       	eor	r12, r12
     cfa:	dd 24       	eor	r13, r13
     cfc:	ee 24       	eor	r14, r14
     cfe:	ff 24       	eor	r15, r15
     d00:	0f ef       	ldi	r16, 0xFF	; 255
     d02:	1f ef       	ldi	r17, 0xFF	; 255
     d04:	1e c0       	rjmp	.+60     	; 0xd42 <vPortGetHeapStats+0x6c>
        {
            while( pxBlock != pxEnd )
     d06:	20 91 84 01 	lds	r18, 0x0184
     d0a:	30 91 85 01 	lds	r19, 0x0185
     d0e:	cc 24       	eor	r12, r12
     d10:	dd 24       	eor	r13, r13
     d12:	ee 24       	eor	r14, r14
     d14:	ff 24       	eor	r15, r15
     d16:	0f ef       	ldi	r16, 0xFF	; 255
     d18:	1f ef       	ldi	r17, 0xFF	; 255
     d1a:	10 c0       	rjmp	.+32     	; 0xd3c <vPortGetHeapStats+0x66>
            {
                /* Increment the number of blocks and record the largest block seen
                 * so far. */
                xBlocks++;
     d1c:	08 94       	sec
     d1e:	c1 1c       	adc	r12, r1
     d20:	d1 1c       	adc	r13, r1

                if( pxBlock->xBlockSize > xMaxSize )
     d22:	82 81       	ldd	r24, Z+2	; 0x02
     d24:	93 81       	ldd	r25, Z+3	; 0x03
     d26:	e8 16       	cp	r14, r24
     d28:	f9 06       	cpc	r15, r25
     d2a:	08 f4       	brcc	.+2      	; 0xd2e <vPortGetHeapStats+0x58>
     d2c:	7c 01       	movw	r14, r24
     d2e:	80 17       	cp	r24, r16
     d30:	91 07       	cpc	r25, r17
     d32:	08 f4       	brcc	.+2      	; 0xd36 <vPortGetHeapStats+0x60>
     d34:	8c 01       	movw	r16, r24
                    xMinSize = pxBlock->xBlockSize;
                }

                /* Move to the next block in the chain until the last block is
                 * reached. */
                pxBlock = pxBlock->pxNextFreeBlock;
     d36:	01 90       	ld	r0, Z+
     d38:	f0 81       	ld	r31, Z
     d3a:	e0 2d       	mov	r30, r0

        /* pxBlock will be NULL if the heap has not been initialised.  The heap
         * is initialised automatically when the first allocation is made. */
        if( pxBlock != NULL )
        {
            while( pxBlock != pxEnd )
     d3c:	e2 17       	cp	r30, r18
     d3e:	f3 07       	cpc	r31, r19
     d40:	69 f7       	brne	.-38     	; 0xd1c <vPortGetHeapStats+0x46>
                 * reached. */
                pxBlock = pxBlock->pxNextFreeBlock;
            }
        }
    }
    ( void ) xTaskResumeAll();
     d42:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>

    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
     d46:	fb 82       	std	Y+3, r15	; 0x03
     d48:	ea 82       	std	Y+2, r14	; 0x02
    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
     d4a:	1d 83       	std	Y+5, r17	; 0x05
     d4c:	0c 83       	std	Y+4, r16	; 0x04
    pxHeapStats->xNumberOfFreeBlocks = xBlocks;
     d4e:	df 82       	std	Y+7, r13	; 0x07
     d50:	ce 82       	std	Y+6, r12	; 0x06

    taskENTER_CRITICAL();
     d52:	0f b6       	in	r0, 0x3f	; 63
     d54:	f8 94       	cli
     d56:	0f 92       	push	r0
    {
        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
     d58:	80 91 86 01 	lds	r24, 0x0186
     d5c:	90 91 87 01 	lds	r25, 0x0187
     d60:	99 83       	std	Y+1, r25	; 0x01
     d62:	88 83       	st	Y, r24
        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
     d64:	80 91 88 01 	lds	r24, 0x0188
     d68:	90 91 89 01 	lds	r25, 0x0189
     d6c:	9b 87       	std	Y+11, r25	; 0x0b
     d6e:	8a 87       	std	Y+10, r24	; 0x0a
        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
     d70:	80 91 8a 01 	lds	r24, 0x018A
     d74:	90 91 8b 01 	lds	r25, 0x018B
     d78:	9d 87       	std	Y+13, r25	; 0x0d
     d7a:	8c 87       	std	Y+12, r24	; 0x0c
        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
     d7c:	80 91 8c 01 	lds	r24, 0x018C
     d80:	90 91 8d 01 	lds	r25, 0x018D
     d84:	99 87       	std	Y+9, r25	; 0x09
     d86:	88 87       	std	Y+8, r24	; 0x08
    }
    taskEXIT_CRITICAL();
     d88:	0f 90       	pop	r0
     d8a:	0f be       	out	0x3f, r0	; 63
}
     d8c:	df 91       	pop	r29
     d8e:	cf 91       	pop	r28
     d90:	1f 91       	pop	r17
     d92:	0f 91       	pop	r16
     d94:	ff 90       	pop	r15
     d96:	ef 90       	pop	r14
     d98:	df 90       	pop	r13
     d9a:	cf 90       	pop	r12
     d9c:	08 95       	ret

00000d9e <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
    uint8_t * puc = ( uint8_t * ) pv;
    BlockLink_t * pxLink;

    if( pv != NULL )
     da2:	00 97       	sbiw	r24, 0x00	; 0
     da4:	49 f1       	breq	.+82     	; 0xdf8 <vPortFree+0x5a>
        /* The memory being freed will have an BlockLink_t structure immediately
         * before it. */
        puc -= xHeapStructSize;

        /* This casting is to keep the compiler from issuing warnings. */
        pxLink = ( void * ) puc;
     da6:	ec 01       	movw	r28, r24
     da8:	24 97       	sbiw	r28, 0x04	; 4

        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
        configASSERT( pxLink->pxNextFreeBlock == NULL );

        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
     daa:	2a 81       	ldd	r18, Y+2	; 0x02
     dac:	3b 81       	ldd	r19, Y+3	; 0x03
     dae:	37 ff       	sbrs	r19, 7
     db0:	23 c0       	rjmp	.+70     	; 0xdf8 <vPortFree+0x5a>
        {
            if( pxLink->pxNextFreeBlock == NULL )
     db2:	88 81       	ld	r24, Y
     db4:	99 81       	ldd	r25, Y+1	; 0x01
     db6:	89 2b       	or	r24, r25
     db8:	f9 f4       	brne	.+62     	; 0xdf8 <vPortFree+0x5a>
            {
                /* The block is being returned to the heap - it is no longer
                 * allocated. */
                heapFREE_BLOCK( pxLink );
     dba:	3f 77       	andi	r19, 0x7F	; 127
     dbc:	3b 83       	std	Y+3, r19	; 0x03
     dbe:	2a 83       	std	Y+2, r18	; 0x02
                {
                    ( void ) memset( puc + xHeapStructSize, 0, pxLink->xBlockSize - xHeapStructSize );
                }
                #endif

                vTaskSuspendAll();
     dc0:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vTaskSuspendAll>
                {
                    /* Add this block to the list of free blocks. */
                    xFreeBytesRemaining += pxLink->xBlockSize;
     dc4:	80 91 86 01 	lds	r24, 0x0186
     dc8:	90 91 87 01 	lds	r25, 0x0187
     dcc:	2a 81       	ldd	r18, Y+2	; 0x02
     dce:	3b 81       	ldd	r19, Y+3	; 0x03
     dd0:	82 0f       	add	r24, r18
     dd2:	93 1f       	adc	r25, r19
     dd4:	90 93 87 01 	sts	0x0187, r25
     dd8:	80 93 86 01 	sts	0x0186, r24
                    traceFREE( pv, pxLink->xBlockSize );
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     ddc:	ce 01       	movw	r24, r28
     dde:	0e 94 28 06 	call	0xc50	; 0xc50 <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
     de2:	80 91 8a 01 	lds	r24, 0x018A
     de6:	90 91 8b 01 	lds	r25, 0x018B
     dea:	01 96       	adiw	r24, 0x01	; 1
     dec:	90 93 8b 01 	sts	0x018B, r25
     df0:	80 93 8a 01 	sts	0x018A, r24
                }
                ( void ) xTaskResumeAll();
     df4:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
}
     df8:	df 91       	pop	r29
     dfa:	cf 91       	pop	r28
     dfc:	08 95       	ret

00000dfe <pvPortMalloc>:
PRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     dfe:	cf 92       	push	r12
     e00:	df 92       	push	r13
     e02:	ef 92       	push	r14
     e04:	ff 92       	push	r15
     e06:	0f 93       	push	r16
     e08:	1f 93       	push	r17
     e0a:	cf 93       	push	r28
     e0c:	df 93       	push	r29
     e0e:	8c 01       	movw	r16, r24
    BlockLink_t * pxPreviousBlock;
    BlockLink_t * pxNewBlockLink;
    void * pvReturn = NULL;
    size_t xAdditionalRequiredSize;

    vTaskSuspendAll();
     e10:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
     e14:	80 91 84 01 	lds	r24, 0x0184
     e18:	90 91 85 01 	lds	r25, 0x0185
     e1c:	89 2b       	or	r24, r25
     e1e:	51 f5       	brne	.+84     	; 0xe74 <pvPortMalloc+0x76>

    pucAlignedHeap = ( uint8_t * ) uxAddress;

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     e20:	8e e8       	ldi	r24, 0x8E	; 142
     e22:	91 e0       	ldi	r25, 0x01	; 1
     e24:	90 93 e7 03 	sts	0x03E7, r25
     e28:	80 93 e6 03 	sts	0x03E6, r24
    xStart.xBlockSize = ( size_t ) 0;
     e2c:	10 92 e9 03 	sts	0x03E9, r1
     e30:	10 92 e8 03 	sts	0x03E8, r1
    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxAddress = ( ( portPOINTER_SIZE_TYPE ) pucAlignedHeap ) + xTotalHeapSize;
    uxAddress -= xHeapStructSize;
    uxAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    pxEnd = ( BlockLink_t * ) uxAddress;
     e34:	22 ee       	ldi	r18, 0xE2	; 226
     e36:	33 e0       	ldi	r19, 0x03	; 3
     e38:	30 93 85 01 	sts	0x0185, r19
     e3c:	20 93 84 01 	sts	0x0184, r18
    pxEnd->xBlockSize = 0;
     e40:	10 92 e5 03 	sts	0x03E5, r1
     e44:	10 92 e4 03 	sts	0x03E4, r1
    pxEnd->pxNextFreeBlock = NULL;
     e48:	10 92 e3 03 	sts	0x03E3, r1
     e4c:	10 92 e2 03 	sts	0x03E2, r1

    /* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. */
    pxFirstFreeBlock = ( BlockLink_t * ) pucAlignedHeap;
    pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
     e50:	84 e5       	ldi	r24, 0x54	; 84
     e52:	92 e0       	ldi	r25, 0x02	; 2
     e54:	90 93 91 01 	sts	0x0191, r25
     e58:	80 93 90 01 	sts	0x0190, r24
    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     e5c:	30 93 8f 01 	sts	0x018F, r19
     e60:	20 93 8e 01 	sts	0x018E, r18

    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     e64:	90 93 8d 01 	sts	0x018D, r25
     e68:	80 93 8c 01 	sts	0x018C, r24
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     e6c:	90 93 87 01 	sts	0x0187, r25
     e70:	80 93 86 01 	sts	0x0186, r24
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xWantedSize > 0 )
     e74:	01 15       	cp	r16, r1
     e76:	11 05       	cpc	r17, r1
     e78:	39 f0       	breq	.+14     	; 0xe88 <pvPortMalloc+0x8a>
            /* The wanted size must be increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. Some
             * additional increment may also be needed for alignment. */
            xAdditionalRequiredSize = xHeapStructSize + portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );

            if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
     e7a:	8f ef       	ldi	r24, 0xFF	; 255
     e7c:	0b 3f       	cpi	r16, 0xFB	; 251
     e7e:	18 07       	cpc	r17, r24
     e80:	08 f0       	brcs	.+2      	; 0xe84 <pvPortMalloc+0x86>
     e82:	67 c0       	rjmp	.+206    	; 0xf52 <pvPortMalloc+0x154>
            {
                xWantedSize += xAdditionalRequiredSize;
     e84:	0b 5f       	subi	r16, 0xFB	; 251
     e86:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Check the block size we are trying to allocate is not so large that the
         * top bit is set.  The top bit of the block size member of the BlockLink_t
         * structure is used to determine who owns the block - the application or
         * the kernel, so it must be free. */
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
     e88:	17 fd       	sbrc	r17, 7
     e8a:	63 c0       	rjmp	.+198    	; 0xf52 <pvPortMalloc+0x154>
        {
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     e8c:	01 15       	cp	r16, r1
     e8e:	11 05       	cpc	r17, r1
     e90:	09 f4       	brne	.+2      	; 0xe94 <pvPortMalloc+0x96>
     e92:	5f c0       	rjmp	.+190    	; 0xf52 <pvPortMalloc+0x154>
     e94:	c0 90 86 01 	lds	r12, 0x0186
     e98:	d0 90 87 01 	lds	r13, 0x0187
     e9c:	c0 16       	cp	r12, r16
     e9e:	d1 06       	cpc	r13, r17
     ea0:	08 f4       	brcc	.+2      	; 0xea4 <pvPortMalloc+0xa6>
     ea2:	57 c0       	rjmp	.+174    	; 0xf52 <pvPortMalloc+0x154>
            {
                /* Traverse the list from the start (lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;
     ea4:	c0 91 e6 03 	lds	r28, 0x03E6
     ea8:	d0 91 e7 03 	lds	r29, 0x03E7
     eac:	e6 ee       	ldi	r30, 0xE6	; 230
     eae:	f3 e0       	ldi	r31, 0x03	; 3

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     eb0:	8a 81       	ldd	r24, Y+2	; 0x02
     eb2:	9b 81       	ldd	r25, Y+3	; 0x03
     eb4:	80 17       	cp	r24, r16
     eb6:	91 07       	cpc	r25, r17
     eb8:	40 f4       	brcc	.+16     	; 0xeca <pvPortMalloc+0xcc>
     eba:	88 81       	ld	r24, Y
     ebc:	99 81       	ldd	r25, Y+1	; 0x01
     ebe:	9e 01       	movw	r18, r28
     ec0:	00 97       	sbiw	r24, 0x00	; 0
     ec2:	19 f0       	breq	.+6      	; 0xeca <pvPortMalloc+0xcc>
     ec4:	ec 01       	movw	r28, r24
     ec6:	f9 01       	movw	r30, r18
     ec8:	f3 cf       	rjmp	.-26     	; 0xeb0 <pvPortMalloc+0xb2>
                    pxBlock = pxBlock->pxNextFreeBlock;
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
     eca:	80 91 84 01 	lds	r24, 0x0184
     ece:	90 91 85 01 	lds	r25, 0x0185
     ed2:	c8 17       	cp	r28, r24
     ed4:	d9 07       	cpc	r29, r25
     ed6:	e9 f1       	breq	.+122    	; 0xf52 <pvPortMalloc+0x154>
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     ed8:	e0 80       	ld	r14, Z
     eda:	f1 80       	ldd	r15, Z+1	; 0x01

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     edc:	88 81       	ld	r24, Y
     ede:	99 81       	ldd	r25, Y+1	; 0x01
     ee0:	91 83       	std	Z+1, r25	; 0x01
     ee2:	80 83       	st	Z, r24

                    /* If the block is larger than required it can be split into
                     * two. */
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     ee4:	8a 81       	ldd	r24, Y+2	; 0x02
     ee6:	9b 81       	ldd	r25, Y+3	; 0x03
     ee8:	80 1b       	sub	r24, r16
     eea:	91 0b       	sbc	r25, r17
     eec:	89 30       	cpi	r24, 0x09	; 9
     eee:	91 05       	cpc	r25, r1
     ef0:	50 f0       	brcs	.+20     	; 0xf06 <pvPortMalloc+0x108>
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     ef2:	fe 01       	movw	r30, r28
     ef4:	e0 0f       	add	r30, r16
     ef6:	f1 1f       	adc	r31, r17
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     ef8:	93 83       	std	Z+3, r25	; 0x03
     efa:	82 83       	std	Z+2, r24	; 0x02
                        pxBlock->xBlockSize = xWantedSize;
     efc:	1b 83       	std	Y+3, r17	; 0x03
     efe:	0a 83       	std	Y+2, r16	; 0x02

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
     f00:	cf 01       	movw	r24, r30
     f02:	0e 94 28 06 	call	0xc50	; 0xc50 <prvInsertBlockIntoFreeList>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
     f06:	4a 81       	ldd	r20, Y+2	; 0x02
     f08:	5b 81       	ldd	r21, Y+3	; 0x03
     f0a:	96 01       	movw	r18, r12
     f0c:	24 1b       	sub	r18, r20
     f0e:	35 0b       	sbc	r19, r21
     f10:	30 93 87 01 	sts	0x0187, r19
     f14:	20 93 86 01 	sts	0x0186, r18

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     f18:	80 91 8c 01 	lds	r24, 0x018C
     f1c:	90 91 8d 01 	lds	r25, 0x018D
     f20:	28 17       	cp	r18, r24
     f22:	39 07       	cpc	r19, r25
     f24:	20 f4       	brcc	.+8      	; 0xf2e <pvPortMalloc+0x130>
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     f26:	30 93 8d 01 	sts	0x018D, r19
     f2a:	20 93 8c 01 	sts	0x018C, r18
                 * was not found. */
                if( pxBlock != pxEnd )
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     f2e:	87 01       	movw	r16, r14
     f30:	0c 5f       	subi	r16, 0xFC	; 252
     f32:	1f 4f       	sbci	r17, 0xFF	; 255
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    heapALLOCATE_BLOCK( pxBlock );
     f34:	50 68       	ori	r21, 0x80	; 128
     f36:	5b 83       	std	Y+3, r21	; 0x03
     f38:	4a 83       	std	Y+2, r20	; 0x02
                    pxBlock->pxNextFreeBlock = NULL;
     f3a:	19 82       	std	Y+1, r1	; 0x01
     f3c:	18 82       	st	Y, r1
                    xNumberOfSuccessfulAllocations++;
     f3e:	80 91 88 01 	lds	r24, 0x0188
     f42:	90 91 89 01 	lds	r25, 0x0189
     f46:	01 96       	adiw	r24, 0x01	; 1
     f48:	90 93 89 01 	sts	0x0189, r25
     f4c:	80 93 88 01 	sts	0x0188, r24
     f50:	02 c0       	rjmp	.+4      	; 0xf56 <pvPortMalloc+0x158>
     f52:	00 e0       	ldi	r16, 0x00	; 0
     f54:	10 e0       	ldi	r17, 0x00	; 0
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     f56:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    return pvReturn;
}
     f5a:	c8 01       	movw	r24, r16
     f5c:	df 91       	pop	r29
     f5e:	cf 91       	pop	r28
     f60:	1f 91       	pop	r17
     f62:	0f 91       	pop	r16
     f64:	ff 90       	pop	r15
     f66:	ef 90       	pop	r14
     f68:	df 90       	pop	r13
     f6a:	cf 90       	pop	r12
     f6c:	08 95       	ret

00000f6e <pvPortCalloc>:
}
/*-----------------------------------------------------------*/

void * pvPortCalloc( size_t xNum,
                     size_t xSize )
{
     f6e:	0f 93       	push	r16
     f70:	1f 93       	push	r17
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
     f76:	9c 01       	movw	r18, r24
     f78:	fb 01       	movw	r30, r22
    void * pv = NULL;

    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
     f7a:	00 97       	sbiw	r24, 0x00	; 0
     f7c:	b9 f0       	breq	.+46     	; 0xfac <pvPortCalloc+0x3e>
     f7e:	8f ef       	ldi	r24, 0xFF	; 255
     f80:	9f ef       	ldi	r25, 0xFF	; 255
     f82:	b9 01       	movw	r22, r18
     f84:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <__udivmodhi4>
     f88:	6e 17       	cp	r22, r30
     f8a:	7f 07       	cpc	r23, r31
     f8c:	78 f4       	brcc	.+30     	; 0xfac <pvPortCalloc+0x3e>
     f8e:	c0 e0       	ldi	r28, 0x00	; 0
     f90:	d0 e0       	ldi	r29, 0x00	; 0
     f92:	06 c0       	rjmp	.+12     	; 0xfa0 <pvPortCalloc+0x32>
    {
        pv = pvPortMalloc( xNum * xSize );

        if( pv != NULL )
        {
            ( void ) memset( pv, 0, xNum * xSize );
     f94:	ce 01       	movw	r24, r28
     f96:	60 e0       	ldi	r22, 0x00	; 0
     f98:	70 e0       	ldi	r23, 0x00	; 0
     f9a:	a8 01       	movw	r20, r16
     f9c:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <memset>
        }
    }

    return pv;
}
     fa0:	ce 01       	movw	r24, r28
     fa2:	df 91       	pop	r29
     fa4:	cf 91       	pop	r28
     fa6:	1f 91       	pop	r17
     fa8:	0f 91       	pop	r16
     faa:	08 95       	ret
{
    void * pv = NULL;

    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
    {
        pv = pvPortMalloc( xNum * xSize );
     fac:	e2 9f       	mul	r30, r18
     fae:	80 01       	movw	r16, r0
     fb0:	e3 9f       	mul	r30, r19
     fb2:	10 0d       	add	r17, r0
     fb4:	f2 9f       	mul	r31, r18
     fb6:	10 0d       	add	r17, r0
     fb8:	11 24       	eor	r1, r1
     fba:	c8 01       	movw	r24, r16
     fbc:	0e 94 ff 06 	call	0xdfe	; 0xdfe <pvPortMalloc>
     fc0:	ec 01       	movw	r28, r24

        if( pv != NULL )
     fc2:	00 97       	sbiw	r24, 0x00	; 0
     fc4:	39 f7       	brne	.-50     	; 0xf94 <pvPortCalloc+0x26>
     fc6:	ec cf       	rjmp	.-40     	; 0xfa0 <pvPortCalloc+0x32>

00000fc8 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     fc8:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     fca:	9c 01       	movw	r18, r24
     fcc:	2d 5f       	subi	r18, 0xFD	; 253
     fce:	3f 4f       	sbci	r19, 0xFF	; 255
     fd0:	32 83       	std	Z+2, r19	; 0x02
     fd2:	21 83       	std	Z+1, r18	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     fd4:	8f ef       	ldi	r24, 0xFF	; 255
     fd6:	9f ef       	ldi	r25, 0xFF	; 255
     fd8:	94 83       	std	Z+4, r25	; 0x04
     fda:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     fdc:	36 83       	std	Z+6, r19	; 0x06
     fde:	25 83       	std	Z+5, r18	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     fe0:	30 87       	std	Z+8, r19	; 0x08
     fe2:	27 83       	std	Z+7, r18	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     fe4:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     fe6:	08 95       	ret

00000fe8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     fe8:	fc 01       	movw	r30, r24
     fea:	11 86       	std	Z+9, r1	; 0x09
     fec:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     fee:	08 95       	ret

00000ff0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
     ff0:	ac 01       	movw	r20, r24
    ListItem_t * const pxIndex = pxList->pxIndex;
     ff2:	fc 01       	movw	r30, r24
     ff4:	a1 81       	ldd	r26, Z+1	; 0x01
     ff6:	b2 81       	ldd	r27, Z+2	; 0x02
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     ff8:	fb 01       	movw	r30, r22
     ffa:	b3 83       	std	Z+3, r27	; 0x03
     ffc:	a2 83       	std	Z+2, r26	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     ffe:	14 96       	adiw	r26, 0x04	; 4
    1000:	8d 91       	ld	r24, X+
    1002:	9c 91       	ld	r25, X
    1004:	15 97       	sbiw	r26, 0x05	; 5
    1006:	95 83       	std	Z+5, r25	; 0x05
    1008:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    100a:	14 96       	adiw	r26, 0x04	; 4
    100c:	ed 91       	ld	r30, X+
    100e:	fc 91       	ld	r31, X
    1010:	15 97       	sbiw	r26, 0x05	; 5
    1012:	73 83       	std	Z+3, r23	; 0x03
    1014:	62 83       	std	Z+2, r22	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1016:	15 96       	adiw	r26, 0x05	; 5
    1018:	7c 93       	st	X, r23
    101a:	6e 93       	st	-X, r22
    101c:	14 97       	sbiw	r26, 0x04	; 4

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    101e:	fb 01       	movw	r30, r22
    1020:	51 87       	std	Z+9, r21	; 0x09
    1022:	40 87       	std	Z+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
    1024:	fa 01       	movw	r30, r20
    1026:	80 81       	ld	r24, Z
    1028:	8f 5f       	subi	r24, 0xFF	; 255
    102a:	80 83       	st	Z, r24
}
    102c:	08 95       	ret

0000102e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    102e:	cf 93       	push	r28
    1030:	df 93       	push	r29
    1032:	9c 01       	movw	r18, r24
    1034:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1036:	48 81       	ld	r20, Y
    1038:	59 81       	ldd	r21, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    103a:	8f ef       	ldi	r24, 0xFF	; 255
    103c:	4f 3f       	cpi	r20, 0xFF	; 255
    103e:	58 07       	cpc	r21, r24
    1040:	21 f4       	brne	.+8      	; 0x104a <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1042:	f9 01       	movw	r30, r18
    1044:	a7 81       	ldd	r26, Z+7	; 0x07
    1046:	b0 85       	ldd	r27, Z+8	; 0x08
    1048:	0d c0       	rjmp	.+26     	; 0x1064 <vListInsert+0x36>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    104a:	d9 01       	movw	r26, r18
    104c:	13 96       	adiw	r26, 0x03	; 3
    104e:	12 96       	adiw	r26, 0x02	; 2
    1050:	ed 91       	ld	r30, X+
    1052:	fc 91       	ld	r31, X
    1054:	13 97       	sbiw	r26, 0x03	; 3
    1056:	80 81       	ld	r24, Z
    1058:	91 81       	ldd	r25, Z+1	; 0x01
    105a:	48 17       	cp	r20, r24
    105c:	59 07       	cpc	r21, r25
    105e:	10 f0       	brcs	.+4      	; 0x1064 <vListInsert+0x36>
    1060:	df 01       	movw	r26, r30
    1062:	f5 cf       	rjmp	.-22     	; 0x104e <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1064:	12 96       	adiw	r26, 0x02	; 2
    1066:	ed 91       	ld	r30, X+
    1068:	fc 91       	ld	r31, X
    106a:	13 97       	sbiw	r26, 0x03	; 3
    106c:	fb 83       	std	Y+3, r31	; 0x03
    106e:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1070:	d5 83       	std	Z+5, r29	; 0x05
    1072:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1074:	bd 83       	std	Y+5, r27	; 0x05
    1076:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1078:	13 96       	adiw	r26, 0x03	; 3
    107a:	dc 93       	st	X, r29
    107c:	ce 93       	st	-X, r28
    107e:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1080:	39 87       	std	Y+9, r19	; 0x09
    1082:	28 87       	std	Y+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    1084:	f9 01       	movw	r30, r18
    1086:	80 81       	ld	r24, Z
    1088:	8f 5f       	subi	r24, 0xFF	; 255
    108a:	80 83       	st	Z, r24
}
    108c:	df 91       	pop	r29
    108e:	cf 91       	pop	r28
    1090:	08 95       	ret

00001092 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1092:	cf 93       	push	r28
    1094:	df 93       	push	r29
    1096:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1098:	18 96       	adiw	r26, 0x08	; 8
    109a:	cd 91       	ld	r28, X+
    109c:	dc 91       	ld	r29, X
    109e:	19 97       	sbiw	r26, 0x09	; 9

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    10a0:	12 96       	adiw	r26, 0x02	; 2
    10a2:	4d 91       	ld	r20, X+
    10a4:	5c 91       	ld	r21, X
    10a6:	13 97       	sbiw	r26, 0x03	; 3
    10a8:	14 96       	adiw	r26, 0x04	; 4
    10aa:	8d 91       	ld	r24, X+
    10ac:	9c 91       	ld	r25, X
    10ae:	15 97       	sbiw	r26, 0x05	; 5
    10b0:	fa 01       	movw	r30, r20
    10b2:	95 83       	std	Z+5, r25	; 0x05
    10b4:	84 83       	std	Z+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    10b6:	14 96       	adiw	r26, 0x04	; 4
    10b8:	2d 91       	ld	r18, X+
    10ba:	3c 91       	ld	r19, X
    10bc:	15 97       	sbiw	r26, 0x05	; 5
    10be:	f9 01       	movw	r30, r18
    10c0:	53 83       	std	Z+3, r21	; 0x03
    10c2:	42 83       	std	Z+2, r20	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    10c4:	89 81       	ldd	r24, Y+1	; 0x01
    10c6:	9a 81       	ldd	r25, Y+2	; 0x02
    10c8:	8a 17       	cp	r24, r26
    10ca:	9b 07       	cpc	r25, r27
    10cc:	11 f4       	brne	.+4      	; 0x10d2 <uxListRemove+0x40>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    10ce:	3a 83       	std	Y+2, r19	; 0x02
    10d0:	29 83       	std	Y+1, r18	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    10d2:	19 96       	adiw	r26, 0x09	; 9
    10d4:	1c 92       	st	X, r1
    10d6:	1e 92       	st	-X, r1
    10d8:	18 97       	sbiw	r26, 0x08	; 8
    ( pxList->uxNumberOfItems )--;
    10da:	88 81       	ld	r24, Y
    10dc:	81 50       	subi	r24, 0x01	; 1
    10de:	88 83       	st	Y, r24

    return pxList->uxNumberOfItems;
    10e0:	88 81       	ld	r24, Y
}
    10e2:	df 91       	pop	r29
    10e4:	cf 91       	pop	r28
    10e6:	08 95       	ret

000010e8 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    10e8:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    10ea:	91 e1       	ldi	r25, 0x11	; 17
    10ec:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    10ee:	22 e2       	ldi	r18, 0x22	; 34
    10f0:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    10f2:	83 e3       	ldi	r24, 0x33	; 51
    10f4:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    10f6:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    10f8:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    10fa:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    10fc:	80 e8       	ldi	r24, 0x80	; 128
    10fe:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1100:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1102:	82 e0       	ldi	r24, 0x02	; 2
    1104:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1106:	83 e0       	ldi	r24, 0x03	; 3
    1108:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    110a:	84 e0       	ldi	r24, 0x04	; 4
    110c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    110e:	85 e0       	ldi	r24, 0x05	; 5
    1110:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1112:	86 e0       	ldi	r24, 0x06	; 6
    1114:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1116:	87 e0       	ldi	r24, 0x07	; 7
    1118:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    111a:	88 e0       	ldi	r24, 0x08	; 8
    111c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    111e:	89 e0       	ldi	r24, 0x09	; 9
    1120:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1122:	80 e1       	ldi	r24, 0x10	; 16
    1124:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1126:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1128:	82 e1       	ldi	r24, 0x12	; 18
    112a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    112c:	83 e1       	ldi	r24, 0x13	; 19
    112e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1130:	84 e1       	ldi	r24, 0x14	; 20
    1132:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1134:	85 e1       	ldi	r24, 0x15	; 21
    1136:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1138:	86 e1       	ldi	r24, 0x16	; 22
    113a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    113c:	87 e1       	ldi	r24, 0x17	; 23
    113e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1140:	88 e1       	ldi	r24, 0x18	; 24
    1142:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1144:	89 e1       	ldi	r24, 0x19	; 25
    1146:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1148:	80 e2       	ldi	r24, 0x20	; 32
    114a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    114c:	81 e2       	ldi	r24, 0x21	; 33
    114e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1150:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1152:	83 e2       	ldi	r24, 0x23	; 35
    1154:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1156:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1158:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    115a:	86 e2       	ldi	r24, 0x26	; 38
    115c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    115e:	87 e2       	ldi	r24, 0x27	; 39
    1160:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1162:	88 e2       	ldi	r24, 0x28	; 40
    1164:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1166:	89 e2       	ldi	r24, 0x29	; 41
    1168:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    116a:	80 e3       	ldi	r24, 0x30	; 48
    116c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    116e:	81 e3       	ldi	r24, 0x31	; 49
    1170:	82 93       	st	-Z, r24
    1172:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1174:	cf 01       	movw	r24, r30
    1176:	08 95       	ret

00001178 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    1178:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    117a:	8e e0       	ldi	r24, 0x0E	; 14
    117c:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    117e:	8b e0       	ldi	r24, 0x0B	; 11
    1180:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1182:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1184:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    1186:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1188:	a0 91 ea 03 	lds	r26, 0x03EA
    118c:	b0 91 eb 03 	lds	r27, 0x03EB
    1190:	cd 91       	ld	r28, X+
    1192:	cd bf       	out	0x3d, r28	; 61
    1194:	dd 91       	ld	r29, X+
    1196:	de bf       	out	0x3e, r29	; 62
    1198:	ff 91       	pop	r31
    119a:	ef 91       	pop	r30
    119c:	df 91       	pop	r29
    119e:	cf 91       	pop	r28
    11a0:	bf 91       	pop	r27
    11a2:	af 91       	pop	r26
    11a4:	9f 91       	pop	r25
    11a6:	8f 91       	pop	r24
    11a8:	7f 91       	pop	r23
    11aa:	6f 91       	pop	r22
    11ac:	5f 91       	pop	r21
    11ae:	4f 91       	pop	r20
    11b0:	3f 91       	pop	r19
    11b2:	2f 91       	pop	r18
    11b4:	1f 91       	pop	r17
    11b6:	0f 91       	pop	r16
    11b8:	ff 90       	pop	r15
    11ba:	ef 90       	pop	r14
    11bc:	df 90       	pop	r13
    11be:	cf 90       	pop	r12
    11c0:	bf 90       	pop	r11
    11c2:	af 90       	pop	r10
    11c4:	9f 90       	pop	r9
    11c6:	8f 90       	pop	r8
    11c8:	7f 90       	pop	r7
    11ca:	6f 90       	pop	r6
    11cc:	5f 90       	pop	r5
    11ce:	4f 90       	pop	r4
    11d0:	3f 90       	pop	r3
    11d2:	2f 90       	pop	r2
    11d4:	1f 90       	pop	r1
    11d6:	0f 90       	pop	r0
    11d8:	0f be       	out	0x3f, r0	; 63
    11da:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    11dc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	08 95       	ret

000011e2 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    11e2:	08 95       	ret

000011e4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    11e4:	0f 92       	push	r0
    11e6:	0f b6       	in	r0, 0x3f	; 63
    11e8:	f8 94       	cli
    11ea:	0f 92       	push	r0
    11ec:	1f 92       	push	r1
    11ee:	11 24       	eor	r1, r1
    11f0:	2f 92       	push	r2
    11f2:	3f 92       	push	r3
    11f4:	4f 92       	push	r4
    11f6:	5f 92       	push	r5
    11f8:	6f 92       	push	r6
    11fa:	7f 92       	push	r7
    11fc:	8f 92       	push	r8
    11fe:	9f 92       	push	r9
    1200:	af 92       	push	r10
    1202:	bf 92       	push	r11
    1204:	cf 92       	push	r12
    1206:	df 92       	push	r13
    1208:	ef 92       	push	r14
    120a:	ff 92       	push	r15
    120c:	0f 93       	push	r16
    120e:	1f 93       	push	r17
    1210:	2f 93       	push	r18
    1212:	3f 93       	push	r19
    1214:	4f 93       	push	r20
    1216:	5f 93       	push	r21
    1218:	6f 93       	push	r22
    121a:	7f 93       	push	r23
    121c:	8f 93       	push	r24
    121e:	9f 93       	push	r25
    1220:	af 93       	push	r26
    1222:	bf 93       	push	r27
    1224:	cf 93       	push	r28
    1226:	df 93       	push	r29
    1228:	ef 93       	push	r30
    122a:	ff 93       	push	r31
    122c:	a0 91 ea 03 	lds	r26, 0x03EA
    1230:	b0 91 eb 03 	lds	r27, 0x03EB
    1234:	0d b6       	in	r0, 0x3d	; 61
    1236:	0d 92       	st	X+, r0
    1238:	0e b6       	in	r0, 0x3e	; 62
    123a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    123c:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <xTaskIncrementTick>
    1240:	88 23       	and	r24, r24
    1242:	11 f0       	breq	.+4      	; 0x1248 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1244:	0e 94 95 0f 	call	0x1f2a	; 0x1f2a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1248:	a0 91 ea 03 	lds	r26, 0x03EA
    124c:	b0 91 eb 03 	lds	r27, 0x03EB
    1250:	cd 91       	ld	r28, X+
    1252:	cd bf       	out	0x3d, r28	; 61
    1254:	dd 91       	ld	r29, X+
    1256:	de bf       	out	0x3e, r29	; 62
    1258:	ff 91       	pop	r31
    125a:	ef 91       	pop	r30
    125c:	df 91       	pop	r29
    125e:	cf 91       	pop	r28
    1260:	bf 91       	pop	r27
    1262:	af 91       	pop	r26
    1264:	9f 91       	pop	r25
    1266:	8f 91       	pop	r24
    1268:	7f 91       	pop	r23
    126a:	6f 91       	pop	r22
    126c:	5f 91       	pop	r21
    126e:	4f 91       	pop	r20
    1270:	3f 91       	pop	r19
    1272:	2f 91       	pop	r18
    1274:	1f 91       	pop	r17
    1276:	0f 91       	pop	r16
    1278:	ff 90       	pop	r15
    127a:	ef 90       	pop	r14
    127c:	df 90       	pop	r13
    127e:	cf 90       	pop	r12
    1280:	bf 90       	pop	r11
    1282:	af 90       	pop	r10
    1284:	9f 90       	pop	r9
    1286:	8f 90       	pop	r8
    1288:	7f 90       	pop	r7
    128a:	6f 90       	pop	r6
    128c:	5f 90       	pop	r5
    128e:	4f 90       	pop	r4
    1290:	3f 90       	pop	r3
    1292:	2f 90       	pop	r2
    1294:	1f 90       	pop	r1
    1296:	0f 90       	pop	r0
    1298:	0f be       	out	0x3f, r0	; 63
    129a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    129c:	08 95       	ret

0000129e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    129e:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    12a2:	18 95       	reti

000012a4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12a4:	0f 92       	push	r0
    12a6:	0f b6       	in	r0, 0x3f	; 63
    12a8:	f8 94       	cli
    12aa:	0f 92       	push	r0
    12ac:	1f 92       	push	r1
    12ae:	11 24       	eor	r1, r1
    12b0:	2f 92       	push	r2
    12b2:	3f 92       	push	r3
    12b4:	4f 92       	push	r4
    12b6:	5f 92       	push	r5
    12b8:	6f 92       	push	r6
    12ba:	7f 92       	push	r7
    12bc:	8f 92       	push	r8
    12be:	9f 92       	push	r9
    12c0:	af 92       	push	r10
    12c2:	bf 92       	push	r11
    12c4:	cf 92       	push	r12
    12c6:	df 92       	push	r13
    12c8:	ef 92       	push	r14
    12ca:	ff 92       	push	r15
    12cc:	0f 93       	push	r16
    12ce:	1f 93       	push	r17
    12d0:	2f 93       	push	r18
    12d2:	3f 93       	push	r19
    12d4:	4f 93       	push	r20
    12d6:	5f 93       	push	r21
    12d8:	6f 93       	push	r22
    12da:	7f 93       	push	r23
    12dc:	8f 93       	push	r24
    12de:	9f 93       	push	r25
    12e0:	af 93       	push	r26
    12e2:	bf 93       	push	r27
    12e4:	cf 93       	push	r28
    12e6:	df 93       	push	r29
    12e8:	ef 93       	push	r30
    12ea:	ff 93       	push	r31
    12ec:	a0 91 ea 03 	lds	r26, 0x03EA
    12f0:	b0 91 eb 03 	lds	r27, 0x03EB
    12f4:	0d b6       	in	r0, 0x3d	; 61
    12f6:	0d 92       	st	X+, r0
    12f8:	0e b6       	in	r0, 0x3e	; 62
    12fa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    12fc:	0e 94 95 0f 	call	0x1f2a	; 0x1f2a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1300:	a0 91 ea 03 	lds	r26, 0x03EA
    1304:	b0 91 eb 03 	lds	r27, 0x03EB
    1308:	cd 91       	ld	r28, X+
    130a:	cd bf       	out	0x3d, r28	; 61
    130c:	dd 91       	ld	r29, X+
    130e:	de bf       	out	0x3e, r29	; 62
    1310:	ff 91       	pop	r31
    1312:	ef 91       	pop	r30
    1314:	df 91       	pop	r29
    1316:	cf 91       	pop	r28
    1318:	bf 91       	pop	r27
    131a:	af 91       	pop	r26
    131c:	9f 91       	pop	r25
    131e:	8f 91       	pop	r24
    1320:	7f 91       	pop	r23
    1322:	6f 91       	pop	r22
    1324:	5f 91       	pop	r21
    1326:	4f 91       	pop	r20
    1328:	3f 91       	pop	r19
    132a:	2f 91       	pop	r18
    132c:	1f 91       	pop	r17
    132e:	0f 91       	pop	r16
    1330:	ff 90       	pop	r15
    1332:	ef 90       	pop	r14
    1334:	df 90       	pop	r13
    1336:	cf 90       	pop	r12
    1338:	bf 90       	pop	r11
    133a:	af 90       	pop	r10
    133c:	9f 90       	pop	r9
    133e:	8f 90       	pop	r8
    1340:	7f 90       	pop	r7
    1342:	6f 90       	pop	r6
    1344:	5f 90       	pop	r5
    1346:	4f 90       	pop	r4
    1348:	3f 90       	pop	r3
    134a:	2f 90       	pop	r2
    134c:	1f 90       	pop	r1
    134e:	0f 90       	pop	r0
    1350:	0f be       	out	0x3f, r0	; 63
    1352:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1354:	08 95       	ret

00001356 <uxQueueMessagesWaiting>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1356:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    1358:	0f b6       	in	r0, 0x3f	; 63
    135a:	f8 94       	cli
    135c:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    135e:	82 8d       	ldd	r24, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    1360:	0f 90       	pop	r0
    1362:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1364:	08 95       	ret

00001366 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1366:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    1368:	0f b6       	in	r0, 0x3f	; 63
    136a:	f8 94       	cli
    136c:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    136e:	92 8d       	ldd	r25, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    1370:	0f 90       	pop	r0
    1372:	0f be       	out	0x3f, r0	; 63
    1374:	83 8d       	ldd	r24, Z+27	; 0x1b

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1376:	89 1b       	sub	r24, r25
    1378:	08 95       	ret

0000137a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    137a:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    137c:	82 8d       	ldd	r24, Z+26	; 0x1a

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    137e:	08 95       	ret

00001380 <xQueueIsQueueEmptyFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1380:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1382:	82 8d       	ldd	r24, Z+26	; 0x1a
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	88 23       	and	r24, r24
    1388:	09 f4       	brne	.+2      	; 0x138c <xQueueIsQueueEmptyFromISR+0xc>
    138a:	91 e0       	ldi	r25, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    138c:	89 2f       	mov	r24, r25
    138e:	08 95       	ret

00001390 <xQueueIsQueueFullFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1390:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1392:	92 8d       	ldd	r25, Z+26	; 0x1a
    1394:	20 e0       	ldi	r18, 0x00	; 0
    1396:	83 8d       	ldd	r24, Z+27	; 0x1b
    1398:	98 17       	cp	r25, r24
    139a:	09 f4       	brne	.+2      	; 0x139e <xQueueIsQueueFullFromISR+0xe>
    139c:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    139e:	82 2f       	mov	r24, r18
    13a0:	08 95       	ret

000013a2 <vQueueDelete>:

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    13a2:	0e 94 cf 06 	call	0xd9e	; 0xd9e <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    13a6:	08 95       	ret

000013a8 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    13a8:	fc 01       	movw	r30, r24
    13aa:	56 2f       	mov	r21, r22
    13ac:	a7 2f       	mov	r26, r23
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    13ae:	24 8d       	ldd	r18, Z+28	; 0x1c
    13b0:	22 23       	and	r18, r18
    13b2:	b9 f0       	breq	.+46     	; 0x13e2 <prvCopyDataFromQueue+0x3a>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    13b4:	86 81       	ldd	r24, Z+6	; 0x06
    13b6:	97 81       	ldd	r25, Z+7	; 0x07
    13b8:	82 0f       	add	r24, r18
    13ba:	91 1d       	adc	r25, r1
    13bc:	97 83       	std	Z+7, r25	; 0x07
    13be:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    13c0:	24 81       	ldd	r18, Z+4	; 0x04
    13c2:	35 81       	ldd	r19, Z+5	; 0x05
    13c4:	82 17       	cp	r24, r18
    13c6:	93 07       	cpc	r25, r19
    13c8:	20 f0       	brcs	.+8      	; 0x13d2 <prvCopyDataFromQueue+0x2a>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    13ca:	80 81       	ld	r24, Z
    13cc:	91 81       	ldd	r25, Z+1	; 0x01
    13ce:	97 83       	std	Z+7, r25	; 0x07
    13d0:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    13d2:	44 8d       	ldd	r20, Z+28	; 0x1c
    13d4:	66 81       	ldd	r22, Z+6	; 0x06
    13d6:	77 81       	ldd	r23, Z+7	; 0x07
    13d8:	85 2f       	mov	r24, r21
    13da:	9a 2f       	mov	r25, r26
    13dc:	50 e0       	ldi	r21, 0x00	; 0
    13de:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <memcpy>
    13e2:	08 95       	ret

000013e4 <xQueuePeekFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29
    13ec:	ec 01       	movw	r28, r24
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    13ee:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13f0:	88 23       	and	r24, r24
    13f2:	41 f0       	breq	.+16     	; 0x1404 <xQueuePeekFromISR+0x20>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    13f4:	0e 81       	ldd	r16, Y+6	; 0x06
    13f6:	1f 81       	ldd	r17, Y+7	; 0x07
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    13f8:	ce 01       	movw	r24, r28
    13fa:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    13fe:	1f 83       	std	Y+7, r17	; 0x07
    1400:	0e 83       	std	Y+6, r16	; 0x06
    1402:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1404:	df 91       	pop	r29
    1406:	cf 91       	pop	r28
    1408:	1f 91       	pop	r17
    140a:	0f 91       	pop	r16
    140c:	08 95       	ret

0000140e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    140e:	0f 93       	push	r16
    1410:	1f 93       	push	r17
    1412:	cf 93       	push	r28
    1414:	df 93       	push	r29
    1416:	ec 01       	movw	r28, r24
    1418:	04 2f       	mov	r16, r20
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    141a:	1a 8d       	ldd	r17, Y+26	; 0x1a

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    141c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    141e:	44 23       	and	r20, r20
    1420:	c1 f1       	breq	.+112    	; 0x1492 <prvCopyDataToQueue+0x84>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    1422:	00 23       	and	r16, r16
    1424:	b1 f4       	brne	.+44     	; 0x1452 <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1426:	8a 81       	ldd	r24, Y+2	; 0x02
    1428:	9b 81       	ldd	r25, Y+3	; 0x03
    142a:	50 e0       	ldi	r21, 0x00	; 0
    142c:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1430:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1432:	2a 81       	ldd	r18, Y+2	; 0x02
    1434:	3b 81       	ldd	r19, Y+3	; 0x03
    1436:	28 0f       	add	r18, r24
    1438:	31 1d       	adc	r19, r1
    143a:	3b 83       	std	Y+3, r19	; 0x03
    143c:	2a 83       	std	Y+2, r18	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    143e:	8c 81       	ldd	r24, Y+4	; 0x04
    1440:	9d 81       	ldd	r25, Y+5	; 0x05
    1442:	28 17       	cp	r18, r24
    1444:	39 07       	cpc	r19, r25
    1446:	28 f1       	brcs	.+74     	; 0x1492 <prvCopyDataToQueue+0x84>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1448:	88 81       	ld	r24, Y
    144a:	99 81       	ldd	r25, Y+1	; 0x01
    144c:	9b 83       	std	Y+3, r25	; 0x03
    144e:	8a 83       	std	Y+2, r24	; 0x02
    1450:	20 c0       	rjmp	.+64     	; 0x1492 <prvCopyDataToQueue+0x84>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1452:	8e 81       	ldd	r24, Y+6	; 0x06
    1454:	9f 81       	ldd	r25, Y+7	; 0x07
    1456:	50 e0       	ldi	r21, 0x00	; 0
    1458:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    145c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	44 27       	eor	r20, r20
    1462:	55 27       	eor	r21, r21
    1464:	48 1b       	sub	r20, r24
    1466:	59 0b       	sbc	r21, r25
    1468:	8e 81       	ldd	r24, Y+6	; 0x06
    146a:	9f 81       	ldd	r25, Y+7	; 0x07
    146c:	84 0f       	add	r24, r20
    146e:	95 1f       	adc	r25, r21
    1470:	9f 83       	std	Y+7, r25	; 0x07
    1472:	8e 83       	std	Y+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1474:	28 81       	ld	r18, Y
    1476:	39 81       	ldd	r19, Y+1	; 0x01
    1478:	82 17       	cp	r24, r18
    147a:	93 07       	cpc	r25, r19
    147c:	30 f4       	brcc	.+12     	; 0x148a <prvCopyDataToQueue+0x7c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    147e:	8c 81       	ldd	r24, Y+4	; 0x04
    1480:	9d 81       	ldd	r25, Y+5	; 0x05
    1482:	84 0f       	add	r24, r20
    1484:	95 1f       	adc	r25, r21
    1486:	9f 83       	std	Y+7, r25	; 0x07
    1488:	8e 83       	std	Y+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    148a:	02 30       	cpi	r16, 0x02	; 2
    148c:	11 f4       	brne	.+4      	; 0x1492 <prvCopyDataToQueue+0x84>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    148e:	11 11       	cpse	r17, r1
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    1490:	11 50       	subi	r17, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1492:	1f 5f       	subi	r17, 0xFF	; 255
    1494:	1a 8f       	std	Y+26, r17	; 0x1a

    return xReturn;
}
    1496:	80 e0       	ldi	r24, 0x00	; 0
    1498:	df 91       	pop	r29
    149a:	cf 91       	pop	r28
    149c:	1f 91       	pop	r17
    149e:	0f 91       	pop	r16
    14a0:	08 95       	ret

000014a2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    14a2:	ef 92       	push	r14
    14a4:	ff 92       	push	r15
    14a6:	0f 93       	push	r16
    14a8:	1f 93       	push	r17
    14aa:	cf 93       	push	r28
    14ac:	df 93       	push	r29
    14ae:	ec 01       	movw	r28, r24
    14b0:	7a 01       	movw	r14, r20
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    14b2:	1a 8d       	ldd	r17, Y+26	; 0x1a

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    14b4:	11 23       	and	r17, r17
    14b6:	11 f4       	brne	.+4      	; 0x14bc <xQueueReceiveFromISR+0x1a>
    14b8:	80 e0       	ldi	r24, 0x00	; 0
    14ba:	1e c0       	rjmp	.+60     	; 0x14f8 <xQueueReceiveFromISR+0x56>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    14bc:	0d 8d       	ldd	r16, Y+29	; 0x1d

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    14be:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    14c2:	11 50       	subi	r17, 0x01	; 1
    14c4:	1a 8f       	std	Y+26, r17	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    14c6:	0f 3f       	cpi	r16, 0xFF	; 255
    14c8:	81 f4       	brne	.+32     	; 0x14ea <xQueueReceiveFromISR+0x48>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14ca:	88 85       	ldd	r24, Y+8	; 0x08
    14cc:	88 23       	and	r24, r24
    14ce:	99 f0       	breq	.+38     	; 0x14f6 <xQueueReceiveFromISR+0x54>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14d0:	ce 01       	movw	r24, r28
    14d2:	08 96       	adiw	r24, 0x08	; 8
    14d4:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    14d8:	88 23       	and	r24, r24
    14da:	69 f0       	breq	.+26     	; 0x14f6 <xQueueReceiveFromISR+0x54>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    14dc:	e1 14       	cp	r14, r1
    14de:	f1 04       	cpc	r15, r1
    14e0:	51 f0       	breq	.+20     	; 0x14f6 <xQueueReceiveFromISR+0x54>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    14e2:	81 e0       	ldi	r24, 0x01	; 1
    14e4:	f7 01       	movw	r30, r14
    14e6:	80 83       	st	Z, r24
    14e8:	07 c0       	rjmp	.+14     	; 0x14f8 <xQueueReceiveFromISR+0x56>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    14ea:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <uxTaskGetNumberOfTasks>
    14ee:	08 17       	cp	r16, r24
    14f0:	10 f4       	brcc	.+4      	; 0x14f6 <xQueueReceiveFromISR+0x54>
    14f2:	0f 5f       	subi	r16, 0xFF	; 255
    14f4:	0d 8f       	std	Y+29, r16	; 0x1d
    14f6:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    14f8:	df 91       	pop	r29
    14fa:	cf 91       	pop	r28
    14fc:	1f 91       	pop	r17
    14fe:	0f 91       	pop	r16
    1500:	ff 90       	pop	r15
    1502:	ef 90       	pop	r14
    1504:	08 95       	ret

00001506 <xQueueGiveFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    1506:	ef 92       	push	r14
    1508:	ff 92       	push	r15
    150a:	1f 93       	push	r17
    150c:	cf 93       	push	r28
    150e:	df 93       	push	r29
    1510:	ec 01       	movw	r28, r24
    1512:	7b 01       	movw	r14, r22
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1514:	9a 8d       	ldd	r25, Y+26	; 0x1a

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    1516:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1518:	98 17       	cp	r25, r24
    151a:	10 f0       	brcs	.+4      	; 0x1520 <xQueueGiveFromISR+0x1a>
    151c:	80 e0       	ldi	r24, 0x00	; 0
    151e:	1c c0       	rjmp	.+56     	; 0x1558 <xQueueGiveFromISR+0x52>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    1520:	1e 8d       	ldd	r17, Y+30	; 0x1e
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1522:	9f 5f       	subi	r25, 0xFF	; 255
    1524:	9a 8f       	std	Y+26, r25	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    1526:	1f 3f       	cpi	r17, 0xFF	; 255
    1528:	81 f4       	brne	.+32     	; 0x154a <xQueueGiveFromISR+0x44>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    152a:	89 89       	ldd	r24, Y+17	; 0x11
    152c:	88 23       	and	r24, r24
    152e:	99 f0       	breq	.+38     	; 0x1556 <xQueueGiveFromISR+0x50>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1530:	ce 01       	movw	r24, r28
    1532:	41 96       	adiw	r24, 0x11	; 17
    1534:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    1538:	88 23       	and	r24, r24
    153a:	69 f0       	breq	.+26     	; 0x1556 <xQueueGiveFromISR+0x50>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    153c:	e1 14       	cp	r14, r1
    153e:	f1 04       	cpc	r15, r1
    1540:	51 f0       	breq	.+20     	; 0x1556 <xQueueGiveFromISR+0x50>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    1542:	81 e0       	ldi	r24, 0x01	; 1
    1544:	f7 01       	movw	r30, r14
    1546:	80 83       	st	Z, r24
    1548:	07 c0       	rjmp	.+14     	; 0x1558 <xQueueGiveFromISR+0x52>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    154a:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <uxTaskGetNumberOfTasks>
    154e:	18 17       	cp	r17, r24
    1550:	10 f4       	brcc	.+4      	; 0x1556 <xQueueGiveFromISR+0x50>
    1552:	1f 5f       	subi	r17, 0xFF	; 255
    1554:	1e 8f       	std	Y+30, r17	; 0x1e
    1556:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1558:	df 91       	pop	r29
    155a:	cf 91       	pop	r28
    155c:	1f 91       	pop	r17
    155e:	ff 90       	pop	r15
    1560:	ef 90       	pop	r14
    1562:	08 95       	ret

00001564 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    1564:	ef 92       	push	r14
    1566:	ff 92       	push	r15
    1568:	1f 93       	push	r17
    156a:	cf 93       	push	r28
    156c:	df 93       	push	r29
    156e:	ec 01       	movw	r28, r24
    1570:	7a 01       	movw	r14, r20
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1572:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1574:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1576:	98 17       	cp	r25, r24
    1578:	20 f0       	brcs	.+8      	; 0x1582 <xQueueGenericSendFromISR+0x1e>
    157a:	22 30       	cpi	r18, 0x02	; 2
    157c:	11 f0       	breq	.+4      	; 0x1582 <xQueueGenericSendFromISR+0x1e>
    157e:	80 e0       	ldi	r24, 0x00	; 0
    1580:	1f c0       	rjmp	.+62     	; 0x15c0 <xQueueGenericSendFromISR+0x5c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    1582:	1e 8d       	ldd	r17, Y+30	; 0x1e
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1584:	8a 8d       	ldd	r24, Y+26	; 0x1a
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1586:	ce 01       	movw	r24, r28
    1588:	42 2f       	mov	r20, r18
    158a:	0e 94 07 0a 	call	0x140e	; 0x140e <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    158e:	1f 3f       	cpi	r17, 0xFF	; 255
    1590:	81 f4       	brne	.+32     	; 0x15b2 <xQueueGenericSendFromISR+0x4e>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1592:	89 89       	ldd	r24, Y+17	; 0x11
    1594:	88 23       	and	r24, r24
    1596:	99 f0       	breq	.+38     	; 0x15be <xQueueGenericSendFromISR+0x5a>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1598:	ce 01       	movw	r24, r28
    159a:	41 96       	adiw	r24, 0x11	; 17
    159c:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    15a0:	88 23       	and	r24, r24
    15a2:	69 f0       	breq	.+26     	; 0x15be <xQueueGenericSendFromISR+0x5a>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    15a4:	e1 14       	cp	r14, r1
    15a6:	f1 04       	cpc	r15, r1
    15a8:	51 f0       	breq	.+20     	; 0x15be <xQueueGenericSendFromISR+0x5a>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	f7 01       	movw	r30, r14
    15ae:	80 83       	st	Z, r24
    15b0:	07 c0       	rjmp	.+14     	; 0x15c0 <xQueueGenericSendFromISR+0x5c>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    15b2:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <uxTaskGetNumberOfTasks>
    15b6:	18 17       	cp	r17, r24
    15b8:	10 f4       	brcc	.+4      	; 0x15be <xQueueGenericSendFromISR+0x5a>
    15ba:	1f 5f       	subi	r17, 0xFF	; 255
    15bc:	1e 8f       	std	Y+30, r17	; 0x1e
    15be:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	1f 91       	pop	r17
    15c6:	ff 90       	pop	r15
    15c8:	ef 90       	pop	r14
    15ca:	08 95       	ret

000015cc <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    15cc:	ef 92       	push	r14
    15ce:	ff 92       	push	r15
    15d0:	1f 93       	push	r17
    15d2:	cf 93       	push	r28
    15d4:	df 93       	push	r29
    15d6:	ec 01       	movw	r28, r24

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    15d8:	0f b6       	in	r0, 0x3f	; 63
    15da:	f8 94       	cli
    15dc:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    15de:	1e 8d       	ldd	r17, Y+30	; 0x1e
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15e0:	91 e1       	ldi	r25, 0x11	; 17
    15e2:	e9 2e       	mov	r14, r25
    15e4:	f1 2c       	mov	r15, r1
    15e6:	ec 0e       	add	r14, r28
    15e8:	fd 1e       	adc	r15, r29
    15ea:	0b c0       	rjmp	.+22     	; 0x1602 <prvUnlockQueue+0x36>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15ec:	89 89       	ldd	r24, Y+17	; 0x11
    15ee:	88 23       	and	r24, r24
    15f0:	51 f0       	breq	.+20     	; 0x1606 <prvUnlockQueue+0x3a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15f2:	c7 01       	movw	r24, r14
    15f4:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    15f8:	88 23       	and	r24, r24
    15fa:	11 f0       	breq	.+4      	; 0x1600 <prvUnlockQueue+0x34>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    15fc:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    1600:	11 50       	subi	r17, 0x01	; 1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    1602:	11 16       	cp	r1, r17
    1604:	9c f3       	brlt	.-26     	; 0x15ec <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    1606:	8f ef       	ldi	r24, 0xFF	; 255
    1608:	8e 8f       	std	Y+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    160a:	0f 90       	pop	r0
    160c:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	f8 94       	cli
    1612:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    1614:	1d 8d       	ldd	r17, Y+29	; 0x1d

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1616:	88 e0       	ldi	r24, 0x08	; 8
    1618:	e8 2e       	mov	r14, r24
    161a:	f1 2c       	mov	r15, r1
    161c:	ec 0e       	add	r14, r28
    161e:	fd 1e       	adc	r15, r29
    1620:	0b c0       	rjmp	.+22     	; 0x1638 <prvUnlockQueue+0x6c>
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1622:	88 85       	ldd	r24, Y+8	; 0x08
    1624:	88 23       	and	r24, r24
    1626:	51 f0       	breq	.+20     	; 0x163c <prvUnlockQueue+0x70>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1628:	c7 01       	movw	r24, r14
    162a:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    162e:	88 23       	and	r24, r24
    1630:	11 f0       	breq	.+4      	; 0x1636 <prvUnlockQueue+0x6a>
                {
                    vTaskMissedYield();
    1632:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    1636:	11 50       	subi	r17, 0x01	; 1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    1638:	11 16       	cp	r1, r17
    163a:	9c f3       	brlt	.-26     	; 0x1622 <prvUnlockQueue+0x56>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    163c:	8f ef       	ldi	r24, 0xFF	; 255
    163e:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    1640:	0f 90       	pop	r0
    1642:	0f be       	out	0x3f, r0	; 63
}
    1644:	df 91       	pop	r29
    1646:	cf 91       	pop	r28
    1648:	1f 91       	pop	r17
    164a:	ff 90       	pop	r15
    164c:	ef 90       	pop	r14
    164e:	08 95       	ret

00001650 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    1650:	8f 92       	push	r8
    1652:	9f 92       	push	r9
    1654:	af 92       	push	r10
    1656:	bf 92       	push	r11
    1658:	cf 92       	push	r12
    165a:	df 92       	push	r13
    165c:	ef 92       	push	r14
    165e:	ff 92       	push	r15
    1660:	0f 93       	push	r16
    1662:	1f 93       	push	r17
    1664:	df 93       	push	r29
    1666:	cf 93       	push	r28
    1668:	00 d0       	rcall	.+0      	; 0x166a <xQueuePeek+0x1a>
    166a:	00 d0       	rcall	.+0      	; 0x166c <xQueuePeek+0x1c>
    166c:	0f 92       	push	r0
    166e:	cd b7       	in	r28, 0x3d	; 61
    1670:	de b7       	in	r29, 0x3e	; 62
    1672:	7c 01       	movw	r14, r24
    1674:	5b 01       	movw	r10, r22
    1676:	5d 83       	std	Y+5, r21	; 0x05
    1678:	4c 83       	std	Y+4, r20	; 0x04
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    167a:	41 e1       	ldi	r20, 0x11	; 17
    167c:	c4 2e       	mov	r12, r20
    167e:	d1 2c       	mov	r13, r1
    1680:	c8 0e       	add	r12, r24
    1682:	d9 1e       	adc	r13, r25
    1684:	20 e0       	ldi	r18, 0x00	; 0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1686:	8e 01       	movw	r16, r28
    1688:	0f 5f       	subi	r16, 0xFF	; 255
    168a:	1f 4f       	sbci	r17, 0xFF	; 255

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    168c:	34 e0       	ldi	r19, 0x04	; 4
    168e:	83 2e       	mov	r8, r19
    1690:	91 2c       	mov	r9, r1
    1692:	8c 0e       	add	r8, r28
    1694:	9d 1e       	adc	r9, r29
    1696:	01 c0       	rjmp	.+2      	; 0x169a <xQueuePeek+0x4a>
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1698:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    16a0:	f7 01       	movw	r30, r14
    16a2:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    16a4:	88 23       	and	r24, r24
    16a6:	b9 f0       	breq	.+46     	; 0x16d6 <xQueuePeek+0x86>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    16a8:	06 81       	ldd	r16, Z+6	; 0x06
    16aa:	17 81       	ldd	r17, Z+7	; 0x07

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    16ac:	c7 01       	movw	r24, r14
    16ae:	b5 01       	movw	r22, r10
    16b0:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    16b4:	f7 01       	movw	r30, r14
    16b6:	17 83       	std	Z+7, r17	; 0x07
    16b8:	06 83       	std	Z+6, r16	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16ba:	81 89       	ldd	r24, Z+17	; 0x11
    16bc:	88 23       	and	r24, r24
    16be:	39 f0       	breq	.+14     	; 0x16ce <xQueuePeek+0x7e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16c0:	c6 01       	movw	r24, r12
    16c2:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    16c6:	88 23       	and	r24, r24
    16c8:	11 f0       	breq	.+4      	; 0x16ce <xQueuePeek+0x7e>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    16ca:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    16ce:	0f 90       	pop	r0
    16d0:	0f be       	out	0x3f, r0	; 63
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	54 c0       	rjmp	.+168    	; 0x177e <xQueuePeek+0x12e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    16d6:	8c 81       	ldd	r24, Y+4	; 0x04
    16d8:	9d 81       	ldd	r25, Y+5	; 0x05
    16da:	89 2b       	or	r24, r25
    16dc:	21 f4       	brne	.+8      	; 0x16e6 <xQueuePeek+0x96>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
    16e2:	80 e0       	ldi	r24, 0x00	; 0
    16e4:	4c c0       	rjmp	.+152    	; 0x177e <xQueuePeek+0x12e>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    16e6:	22 23       	and	r18, r18
    16e8:	19 f4       	brne	.+6      	; 0x16f0 <xQueuePeek+0xa0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    16ea:	c8 01       	movw	r24, r16
    16ec:	0e 94 2c 11 	call	0x2258	; 0x2258 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    16f0:	0f 90       	pop	r0
    16f2:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    16f4:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    16f8:	0f b6       	in	r0, 0x3f	; 63
    16fa:	f8 94       	cli
    16fc:	0f 92       	push	r0
    16fe:	f7 01       	movw	r30, r14
    1700:	85 8d       	ldd	r24, Z+29	; 0x1d
    1702:	8f 3f       	cpi	r24, 0xFF	; 255
    1704:	09 f4       	brne	.+2      	; 0x1708 <xQueuePeek+0xb8>
    1706:	15 8e       	std	Z+29, r1	; 0x1d
    1708:	f7 01       	movw	r30, r14
    170a:	86 8d       	ldd	r24, Z+30	; 0x1e
    170c:	8f 3f       	cpi	r24, 0xFF	; 255
    170e:	09 f4       	brne	.+2      	; 0x1712 <xQueuePeek+0xc2>
    1710:	16 8e       	std	Z+30, r1	; 0x1e
    1712:	0f 90       	pop	r0
    1714:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1716:	c8 01       	movw	r24, r16
    1718:	b4 01       	movw	r22, r8
    171a:	0e 94 37 11 	call	0x226e	; 0x226e <xTaskCheckForTimeOut>
    171e:	88 23       	and	r24, r24
    1720:	f9 f4       	brne	.+62     	; 0x1760 <xQueuePeek+0x110>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1728:	f7 01       	movw	r30, r14
    172a:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    172c:	0f 90       	pop	r0
    172e:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1730:	88 23       	and	r24, r24
    1732:	81 f4       	brne	.+32     	; 0x1754 <xQueuePeek+0x104>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1734:	6c 81       	ldd	r22, Y+4	; 0x04
    1736:	7d 81       	ldd	r23, Y+5	; 0x05
    1738:	c6 01       	movw	r24, r12
    173a:	0e 94 2b 17 	call	0x2e56	; 0x2e56 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    173e:	c7 01       	movw	r24, r14
    1740:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1744:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    1748:	88 23       	and	r24, r24
    174a:	09 f0       	breq	.+2      	; 0x174e <xQueuePeek+0xfe>
    174c:	a5 cf       	rjmp	.-182    	; 0x1698 <xQueuePeek+0x48>
                {
                    portYIELD_WITHIN_API();
    174e:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    1752:	a2 cf       	rjmp	.-188    	; 0x1698 <xQueuePeek+0x48>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    1754:	c7 01       	movw	r24, r14
    1756:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    175a:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    175e:	9c cf       	rjmp	.-200    	; 0x1698 <xQueuePeek+0x48>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    1760:	c7 01       	movw	r24, r14
    1762:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1766:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    176a:	0f b6       	in	r0, 0x3f	; 63
    176c:	f8 94       	cli
    176e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1770:	f7 01       	movw	r30, r14
    1772:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1774:	0f 90       	pop	r0
    1776:	0f be       	out	0x3f, r0	; 63
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1778:	88 23       	and	r24, r24
    177a:	09 f0       	breq	.+2      	; 0x177e <xQueuePeek+0x12e>
    177c:	8d cf       	rjmp	.-230    	; 0x1698 <xQueuePeek+0x48>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    177e:	0f 90       	pop	r0
    1780:	0f 90       	pop	r0
    1782:	0f 90       	pop	r0
    1784:	0f 90       	pop	r0
    1786:	0f 90       	pop	r0
    1788:	cf 91       	pop	r28
    178a:	df 91       	pop	r29
    178c:	1f 91       	pop	r17
    178e:	0f 91       	pop	r16
    1790:	ff 90       	pop	r15
    1792:	ef 90       	pop	r14
    1794:	df 90       	pop	r13
    1796:	cf 90       	pop	r12
    1798:	bf 90       	pop	r11
    179a:	af 90       	pop	r10
    179c:	9f 90       	pop	r9
    179e:	8f 90       	pop	r8
    17a0:	08 95       	ret

000017a2 <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    17a2:	af 92       	push	r10
    17a4:	bf 92       	push	r11
    17a6:	cf 92       	push	r12
    17a8:	df 92       	push	r13
    17aa:	ef 92       	push	r14
    17ac:	ff 92       	push	r15
    17ae:	0f 93       	push	r16
    17b0:	1f 93       	push	r17
    17b2:	df 93       	push	r29
    17b4:	cf 93       	push	r28
    17b6:	00 d0       	rcall	.+0      	; 0x17b8 <xQueueSemaphoreTake+0x16>
    17b8:	00 d0       	rcall	.+0      	; 0x17ba <xQueueSemaphoreTake+0x18>
    17ba:	0f 92       	push	r0
    17bc:	cd b7       	in	r28, 0x3d	; 61
    17be:	de b7       	in	r29, 0x3e	; 62
    17c0:	8c 01       	movw	r16, r24
    17c2:	7d 83       	std	Y+5, r23	; 0x05
    17c4:	6c 83       	std	Y+4, r22	; 0x04
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17c6:	61 e1       	ldi	r22, 0x11	; 17
    17c8:	e6 2e       	mov	r14, r22
    17ca:	f1 2c       	mov	r15, r1
    17cc:	e8 0e       	add	r14, r24
    17ce:	f9 1e       	adc	r15, r25
    17d0:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    17d2:	6e 01       	movw	r12, r28
    17d4:	08 94       	sec
    17d6:	c1 1c       	adc	r12, r1
    17d8:	d1 1c       	adc	r13, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17da:	54 e0       	ldi	r21, 0x04	; 4
    17dc:	a5 2e       	mov	r10, r21
    17de:	b1 2c       	mov	r11, r1
    17e0:	ac 0e       	add	r10, r28
    17e2:	bd 1e       	adc	r11, r29
    17e4:	01 c0       	rjmp	.+2      	; 0x17e8 <xQueueSemaphoreTake+0x46>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17e6:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    17e8:	0f b6       	in	r0, 0x3f	; 63
    17ea:	f8 94       	cli
    17ec:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    17ee:	f8 01       	movw	r30, r16
    17f0:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    17f2:	88 23       	and	r24, r24
    17f4:	89 f0       	breq	.+34     	; 0x1818 <xQueueSemaphoreTake+0x76>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    17f6:	81 50       	subi	r24, 0x01	; 1
    17f8:	82 8f       	std	Z+26, r24	; 0x1a
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17fa:	80 85       	ldd	r24, Z+8	; 0x08
    17fc:	88 23       	and	r24, r24
    17fe:	41 f0       	breq	.+16     	; 0x1810 <xQueueSemaphoreTake+0x6e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1800:	c8 01       	movw	r24, r16
    1802:	08 96       	adiw	r24, 0x08	; 8
    1804:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    1808:	88 23       	and	r24, r24
    180a:	11 f0       	breq	.+4      	; 0x1810 <xQueueSemaphoreTake+0x6e>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    180c:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1810:	0f 90       	pop	r0
    1812:	0f be       	out	0x3f, r0	; 63
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	54 c0       	rjmp	.+168    	; 0x18c0 <xQueueSemaphoreTake+0x11e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1818:	8c 81       	ldd	r24, Y+4	; 0x04
    181a:	9d 81       	ldd	r25, Y+5	; 0x05
    181c:	89 2b       	or	r24, r25
    181e:	21 f4       	brne	.+8      	; 0x1828 <xQueueSemaphoreTake+0x86>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    1820:	0f 90       	pop	r0
    1822:	0f be       	out	0x3f, r0	; 63
    1824:	80 e0       	ldi	r24, 0x00	; 0
    1826:	4c c0       	rjmp	.+152    	; 0x18c0 <xQueueSemaphoreTake+0x11e>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    1828:	22 23       	and	r18, r18
    182a:	19 f4       	brne	.+6      	; 0x1832 <xQueueSemaphoreTake+0x90>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    182c:	c6 01       	movw	r24, r12
    182e:	0e 94 2c 11 	call	0x2258	; 0x2258 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1832:	0f 90       	pop	r0
    1834:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1836:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    183a:	0f b6       	in	r0, 0x3f	; 63
    183c:	f8 94       	cli
    183e:	0f 92       	push	r0
    1840:	f8 01       	movw	r30, r16
    1842:	85 8d       	ldd	r24, Z+29	; 0x1d
    1844:	8f 3f       	cpi	r24, 0xFF	; 255
    1846:	09 f4       	brne	.+2      	; 0x184a <xQueueSemaphoreTake+0xa8>
    1848:	15 8e       	std	Z+29, r1	; 0x1d
    184a:	f8 01       	movw	r30, r16
    184c:	86 8d       	ldd	r24, Z+30	; 0x1e
    184e:	8f 3f       	cpi	r24, 0xFF	; 255
    1850:	09 f4       	brne	.+2      	; 0x1854 <xQueueSemaphoreTake+0xb2>
    1852:	16 8e       	std	Z+30, r1	; 0x1e
    1854:	0f 90       	pop	r0
    1856:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1858:	c6 01       	movw	r24, r12
    185a:	b5 01       	movw	r22, r10
    185c:	0e 94 37 11 	call	0x226e	; 0x226e <xTaskCheckForTimeOut>
    1860:	88 23       	and	r24, r24
    1862:	f9 f4       	brne	.+62     	; 0x18a2 <xQueueSemaphoreTake+0x100>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1864:	0f b6       	in	r0, 0x3f	; 63
    1866:	f8 94       	cli
    1868:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    186a:	f8 01       	movw	r30, r16
    186c:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    186e:	0f 90       	pop	r0
    1870:	0f be       	out	0x3f, r0	; 63
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1872:	88 23       	and	r24, r24
    1874:	81 f4       	brne	.+32     	; 0x1896 <xQueueSemaphoreTake+0xf4>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1876:	6c 81       	ldd	r22, Y+4	; 0x04
    1878:	7d 81       	ldd	r23, Y+5	; 0x05
    187a:	c7 01       	movw	r24, r14
    187c:	0e 94 2b 17 	call	0x2e56	; 0x2e56 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1880:	c8 01       	movw	r24, r16
    1882:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1886:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    188a:	88 23       	and	r24, r24
    188c:	09 f0       	breq	.+2      	; 0x1890 <xQueueSemaphoreTake+0xee>
    188e:	ab cf       	rjmp	.-170    	; 0x17e6 <xQueueSemaphoreTake+0x44>
                {
                    portYIELD_WITHIN_API();
    1890:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    1894:	a8 cf       	rjmp	.-176    	; 0x17e6 <xQueueSemaphoreTake+0x44>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    1896:	c8 01       	movw	r24, r16
    1898:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    189c:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    18a0:	a2 cf       	rjmp	.-188    	; 0x17e6 <xQueueSemaphoreTake+0x44>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    18a2:	c8 01       	movw	r24, r16
    18a4:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    18a8:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    18ac:	0f b6       	in	r0, 0x3f	; 63
    18ae:	f8 94       	cli
    18b0:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    18b2:	f8 01       	movw	r30, r16
    18b4:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    18b6:	0f 90       	pop	r0
    18b8:	0f be       	out	0x3f, r0	; 63

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18ba:	88 23       	and	r24, r24
    18bc:	09 f0       	breq	.+2      	; 0x18c0 <xQueueSemaphoreTake+0x11e>
    18be:	93 cf       	rjmp	.-218    	; 0x17e6 <xQueueSemaphoreTake+0x44>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    18c0:	0f 90       	pop	r0
    18c2:	0f 90       	pop	r0
    18c4:	0f 90       	pop	r0
    18c6:	0f 90       	pop	r0
    18c8:	0f 90       	pop	r0
    18ca:	cf 91       	pop	r28
    18cc:	df 91       	pop	r29
    18ce:	1f 91       	pop	r17
    18d0:	0f 91       	pop	r16
    18d2:	ff 90       	pop	r15
    18d4:	ef 90       	pop	r14
    18d6:	df 90       	pop	r13
    18d8:	cf 90       	pop	r12
    18da:	bf 90       	pop	r11
    18dc:	af 90       	pop	r10
    18de:	08 95       	ret

000018e0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    18e0:	6f 92       	push	r6
    18e2:	7f 92       	push	r7
    18e4:	8f 92       	push	r8
    18e6:	9f 92       	push	r9
    18e8:	af 92       	push	r10
    18ea:	bf 92       	push	r11
    18ec:	cf 92       	push	r12
    18ee:	df 92       	push	r13
    18f0:	ff 92       	push	r15
    18f2:	0f 93       	push	r16
    18f4:	1f 93       	push	r17
    18f6:	df 93       	push	r29
    18f8:	cf 93       	push	r28
    18fa:	00 d0       	rcall	.+0      	; 0x18fc <xQueueReceive+0x1c>
    18fc:	00 d0       	rcall	.+0      	; 0x18fe <xQueueReceive+0x1e>
    18fe:	0f 92       	push	r0
    1900:	cd b7       	in	r28, 0x3d	; 61
    1902:	de b7       	in	r29, 0x3e	; 62
    1904:	8c 01       	movw	r16, r24
    1906:	5b 01       	movw	r10, r22
    1908:	5d 83       	std	Y+5, r21	; 0x05
    190a:	4c 83       	std	Y+4, r20	; 0x04
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    190c:	e1 e1       	ldi	r30, 0x11	; 17
    190e:	ce 2e       	mov	r12, r30
    1910:	d1 2c       	mov	r13, r1
    1912:	c8 0e       	add	r12, r24
    1914:	d9 1e       	adc	r13, r25
    1916:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1918:	4e 01       	movw	r8, r28
    191a:	08 94       	sec
    191c:	81 1c       	adc	r8, r1
    191e:	91 1c       	adc	r9, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1920:	74 e0       	ldi	r23, 0x04	; 4
    1922:	67 2e       	mov	r6, r23
    1924:	71 2c       	mov	r7, r1
    1926:	6c 0e       	add	r6, r28
    1928:	7d 1e       	adc	r7, r29
    192a:	01 c0       	rjmp	.+2      	; 0x192e <xQueueReceive+0x4e>
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    192c:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    192e:	0f b6       	in	r0, 0x3f	; 63
    1930:	f8 94       	cli
    1932:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1934:	f8 01       	movw	r30, r16
    1936:	f2 8c       	ldd	r15, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1938:	ff 20       	and	r15, r15
    193a:	b1 f0       	breq	.+44     	; 0x1968 <xQueueReceive+0x88>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    193c:	c8 01       	movw	r24, r16
    193e:	b5 01       	movw	r22, r10
    1940:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1944:	fa 94       	dec	r15
    1946:	f8 01       	movw	r30, r16
    1948:	f2 8e       	std	Z+26, r15	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    194a:	80 85       	ldd	r24, Z+8	; 0x08
    194c:	88 23       	and	r24, r24
    194e:	41 f0       	breq	.+16     	; 0x1960 <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1950:	c8 01       	movw	r24, r16
    1952:	08 96       	adiw	r24, 0x08	; 8
    1954:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    1958:	88 23       	and	r24, r24
    195a:	11 f0       	breq	.+4      	; 0x1960 <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    195c:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1960:	0f 90       	pop	r0
    1962:	0f be       	out	0x3f, r0	; 63
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	54 c0       	rjmp	.+168    	; 0x1a10 <xQueueReceive+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1968:	8c 81       	ldd	r24, Y+4	; 0x04
    196a:	9d 81       	ldd	r25, Y+5	; 0x05
    196c:	89 2b       	or	r24, r25
    196e:	21 f4       	brne	.+8      	; 0x1978 <xQueueReceive+0x98>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1970:	0f 90       	pop	r0
    1972:	0f be       	out	0x3f, r0	; 63
    1974:	80 e0       	ldi	r24, 0x00	; 0
    1976:	4c c0       	rjmp	.+152    	; 0x1a10 <xQueueReceive+0x130>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    1978:	22 23       	and	r18, r18
    197a:	19 f4       	brne	.+6      	; 0x1982 <xQueueReceive+0xa2>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    197c:	c4 01       	movw	r24, r8
    197e:	0e 94 2c 11 	call	0x2258	; 0x2258 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1982:	0f 90       	pop	r0
    1984:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1986:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    198a:	0f b6       	in	r0, 0x3f	; 63
    198c:	f8 94       	cli
    198e:	0f 92       	push	r0
    1990:	f8 01       	movw	r30, r16
    1992:	85 8d       	ldd	r24, Z+29	; 0x1d
    1994:	8f 3f       	cpi	r24, 0xFF	; 255
    1996:	09 f4       	brne	.+2      	; 0x199a <xQueueReceive+0xba>
    1998:	15 8e       	std	Z+29, r1	; 0x1d
    199a:	f8 01       	movw	r30, r16
    199c:	86 8d       	ldd	r24, Z+30	; 0x1e
    199e:	8f 3f       	cpi	r24, 0xFF	; 255
    19a0:	09 f4       	brne	.+2      	; 0x19a4 <xQueueReceive+0xc4>
    19a2:	16 8e       	std	Z+30, r1	; 0x1e
    19a4:	0f 90       	pop	r0
    19a6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    19a8:	c4 01       	movw	r24, r8
    19aa:	b3 01       	movw	r22, r6
    19ac:	0e 94 37 11 	call	0x226e	; 0x226e <xTaskCheckForTimeOut>
    19b0:	88 23       	and	r24, r24
    19b2:	f9 f4       	brne	.+62     	; 0x19f2 <xQueueReceive+0x112>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    19b4:	0f b6       	in	r0, 0x3f	; 63
    19b6:	f8 94       	cli
    19b8:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    19ba:	f8 01       	movw	r30, r16
    19bc:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    19be:	0f 90       	pop	r0
    19c0:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19c2:	88 23       	and	r24, r24
    19c4:	81 f4       	brne	.+32     	; 0x19e6 <xQueueReceive+0x106>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19c6:	6c 81       	ldd	r22, Y+4	; 0x04
    19c8:	7d 81       	ldd	r23, Y+5	; 0x05
    19ca:	c6 01       	movw	r24, r12
    19cc:	0e 94 2b 17 	call	0x2e56	; 0x2e56 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    19d0:	c8 01       	movw	r24, r16
    19d2:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    19d6:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    19da:	88 23       	and	r24, r24
    19dc:	09 f0       	breq	.+2      	; 0x19e0 <xQueueReceive+0x100>
    19de:	a6 cf       	rjmp	.-180    	; 0x192c <xQueueReceive+0x4c>
                {
                    portYIELD_WITHIN_API();
    19e0:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    19e4:	a3 cf       	rjmp	.-186    	; 0x192c <xQueueReceive+0x4c>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    19e6:	c8 01       	movw	r24, r16
    19e8:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    19ec:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    19f0:	9d cf       	rjmp	.-198    	; 0x192c <xQueueReceive+0x4c>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    19f2:	c8 01       	movw	r24, r16
    19f4:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    19f8:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    19fc:	0f b6       	in	r0, 0x3f	; 63
    19fe:	f8 94       	cli
    1a00:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a02:	f8 01       	movw	r30, r16
    1a04:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1a06:	0f 90       	pop	r0
    1a08:	0f be       	out	0x3f, r0	; 63
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1a0a:	88 23       	and	r24, r24
    1a0c:	09 f0       	breq	.+2      	; 0x1a10 <xQueueReceive+0x130>
    1a0e:	8e cf       	rjmp	.-228    	; 0x192c <xQueueReceive+0x4c>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    1a10:	0f 90       	pop	r0
    1a12:	0f 90       	pop	r0
    1a14:	0f 90       	pop	r0
    1a16:	0f 90       	pop	r0
    1a18:	0f 90       	pop	r0
    1a1a:	cf 91       	pop	r28
    1a1c:	df 91       	pop	r29
    1a1e:	1f 91       	pop	r17
    1a20:	0f 91       	pop	r16
    1a22:	ff 90       	pop	r15
    1a24:	df 90       	pop	r13
    1a26:	cf 90       	pop	r12
    1a28:	bf 90       	pop	r11
    1a2a:	af 90       	pop	r10
    1a2c:	9f 90       	pop	r9
    1a2e:	8f 90       	pop	r8
    1a30:	7f 90       	pop	r7
    1a32:	6f 90       	pop	r6
    1a34:	08 95       	ret

00001a36 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    1a36:	6f 92       	push	r6
    1a38:	7f 92       	push	r7
    1a3a:	9f 92       	push	r9
    1a3c:	af 92       	push	r10
    1a3e:	bf 92       	push	r11
    1a40:	cf 92       	push	r12
    1a42:	df 92       	push	r13
    1a44:	ef 92       	push	r14
    1a46:	ff 92       	push	r15
    1a48:	0f 93       	push	r16
    1a4a:	1f 93       	push	r17
    1a4c:	df 93       	push	r29
    1a4e:	cf 93       	push	r28
    1a50:	00 d0       	rcall	.+0      	; 0x1a52 <xQueueGenericSend+0x1c>
    1a52:	00 d0       	rcall	.+0      	; 0x1a54 <xQueueGenericSend+0x1e>
    1a54:	0f 92       	push	r0
    1a56:	cd b7       	in	r28, 0x3d	; 61
    1a58:	de b7       	in	r29, 0x3e	; 62
    1a5a:	8c 01       	movw	r16, r24
    1a5c:	6b 01       	movw	r12, r22
    1a5e:	5d 83       	std	Y+5, r21	; 0x05
    1a60:	4c 83       	std	Y+4, r20	; 0x04
    1a62:	92 2e       	mov	r9, r18
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a64:	a8 e0       	ldi	r26, 0x08	; 8
    1a66:	ea 2e       	mov	r14, r26
    1a68:	f1 2c       	mov	r15, r1
    1a6a:	e8 0e       	add	r14, r24
    1a6c:	f9 1e       	adc	r15, r25
    1a6e:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1a70:	5e 01       	movw	r10, r28
    1a72:	08 94       	sec
    1a74:	a1 1c       	adc	r10, r1
    1a76:	b1 1c       	adc	r11, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a78:	f4 e0       	ldi	r31, 0x04	; 4
    1a7a:	6f 2e       	mov	r6, r31
    1a7c:	71 2c       	mov	r7, r1
    1a7e:	6c 0e       	add	r6, r28
    1a80:	7d 1e       	adc	r7, r29
    1a82:	01 c0       	rjmp	.+2      	; 0x1a86 <xQueueGenericSend+0x50>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a84:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1a86:	0f b6       	in	r0, 0x3f	; 63
    1a88:	f8 94       	cli
    1a8a:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a8c:	f8 01       	movw	r30, r16
    1a8e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a90:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a92:	98 17       	cp	r25, r24
    1a94:	18 f0       	brcs	.+6      	; 0x1a9c <xQueueGenericSend+0x66>
    1a96:	f2 e0       	ldi	r31, 0x02	; 2
    1a98:	9f 16       	cp	r9, r31
    1a9a:	c9 f4       	brne	.+50     	; 0x1ace <xQueueGenericSend+0x98>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a9c:	c8 01       	movw	r24, r16
    1a9e:	b6 01       	movw	r22, r12
    1aa0:	49 2d       	mov	r20, r9
    1aa2:	0e 94 07 0a 	call	0x140e	; 0x140e <prvCopyDataToQueue>
    1aa6:	98 2f       	mov	r25, r24

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1aa8:	f8 01       	movw	r30, r16
    1aaa:	81 89       	ldd	r24, Z+17	; 0x11
    1aac:	88 23       	and	r24, r24
    1aae:	39 f0       	breq	.+14     	; 0x1abe <xQueueGenericSend+0x88>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ab0:	c8 01       	movw	r24, r16
    1ab2:	41 96       	adiw	r24, 0x11	; 17
    1ab4:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    1ab8:	88 23       	and	r24, r24
    1aba:	29 f0       	breq	.+10     	; 0x1ac6 <xQueueGenericSend+0x90>
    1abc:	02 c0       	rjmp	.+4      	; 0x1ac2 <xQueueGenericSend+0x8c>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    1abe:	99 23       	and	r25, r25
    1ac0:	11 f0       	breq	.+4      	; 0x1ac6 <xQueueGenericSend+0x90>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    1ac2:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1ac6:	0f 90       	pop	r0
    1ac8:	0f be       	out	0x3f, r0	; 63
    1aca:	81 e0       	ldi	r24, 0x01	; 1
    1acc:	4c c0       	rjmp	.+152    	; 0x1b66 <xQueueGenericSend+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1ace:	8c 81       	ldd	r24, Y+4	; 0x04
    1ad0:	9d 81       	ldd	r25, Y+5	; 0x05
    1ad2:	89 2b       	or	r24, r25
    1ad4:	19 f4       	brne	.+6      	; 0x1adc <xQueueGenericSend+0xa6>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1ad6:	0f 90       	pop	r0
    1ad8:	0f be       	out	0x3f, r0	; 63
    1ada:	44 c0       	rjmp	.+136    	; 0x1b64 <xQueueGenericSend+0x12e>
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
    1adc:	22 23       	and	r18, r18
    1ade:	19 f4       	brne	.+6      	; 0x1ae6 <xQueueGenericSend+0xb0>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1ae0:	c5 01       	movw	r24, r10
    1ae2:	0e 94 2c 11 	call	0x2258	; 0x2258 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1ae6:	0f 90       	pop	r0
    1ae8:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1aea:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1aee:	0f b6       	in	r0, 0x3f	; 63
    1af0:	f8 94       	cli
    1af2:	0f 92       	push	r0
    1af4:	f8 01       	movw	r30, r16
    1af6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1af8:	8f 3f       	cpi	r24, 0xFF	; 255
    1afa:	09 f4       	brne	.+2      	; 0x1afe <xQueueGenericSend+0xc8>
    1afc:	15 8e       	std	Z+29, r1	; 0x1d
    1afe:	f8 01       	movw	r30, r16
    1b00:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b02:	8f 3f       	cpi	r24, 0xFF	; 255
    1b04:	09 f4       	brne	.+2      	; 0x1b08 <xQueueGenericSend+0xd2>
    1b06:	16 8e       	std	Z+30, r1	; 0x1e
    1b08:	0f 90       	pop	r0
    1b0a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b0c:	c5 01       	movw	r24, r10
    1b0e:	b3 01       	movw	r22, r6
    1b10:	0e 94 37 11 	call	0x226e	; 0x226e <xTaskCheckForTimeOut>
    1b14:	88 23       	and	r24, r24
    1b16:	09 f5       	brne	.+66     	; 0x1b5a <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1b18:	0f b6       	in	r0, 0x3f	; 63
    1b1a:	f8 94       	cli
    1b1c:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1b1e:	f8 01       	movw	r30, r16
    1b20:	92 8d       	ldd	r25, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1b22:	0f 90       	pop	r0
    1b24:	0f be       	out	0x3f, r0	; 63
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1b26:	f8 01       	movw	r30, r16
    1b28:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b2a:	98 17       	cp	r25, r24
    1b2c:	81 f4       	brne	.+32     	; 0x1b4e <xQueueGenericSend+0x118>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1b2e:	6c 81       	ldd	r22, Y+4	; 0x04
    1b30:	7d 81       	ldd	r23, Y+5	; 0x05
    1b32:	c7 01       	movw	r24, r14
    1b34:	0e 94 2b 17 	call	0x2e56	; 0x2e56 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    1b38:	c8 01       	movw	r24, r16
    1b3a:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    1b3e:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    1b42:	88 23       	and	r24, r24
    1b44:	09 f0       	breq	.+2      	; 0x1b48 <xQueueGenericSend+0x112>
    1b46:	9e cf       	rjmp	.-196    	; 0x1a84 <xQueueGenericSend+0x4e>
                {
                    portYIELD_WITHIN_API();
    1b48:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    1b4c:	9b cf       	rjmp	.-202    	; 0x1a84 <xQueueGenericSend+0x4e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    1b4e:	c8 01       	movw	r24, r16
    1b50:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1b54:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    1b58:	95 cf       	rjmp	.-214    	; 0x1a84 <xQueueGenericSend+0x4e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    1b5a:	c8 01       	movw	r24, r16
    1b5c:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1b60:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
    1b64:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
    1b66:	0f 90       	pop	r0
    1b68:	0f 90       	pop	r0
    1b6a:	0f 90       	pop	r0
    1b6c:	0f 90       	pop	r0
    1b6e:	0f 90       	pop	r0
    1b70:	cf 91       	pop	r28
    1b72:	df 91       	pop	r29
    1b74:	1f 91       	pop	r17
    1b76:	0f 91       	pop	r16
    1b78:	ff 90       	pop	r15
    1b7a:	ef 90       	pop	r14
    1b7c:	df 90       	pop	r13
    1b7e:	cf 90       	pop	r12
    1b80:	bf 90       	pop	r11
    1b82:	af 90       	pop	r10
    1b84:	9f 90       	pop	r9
    1b86:	7f 90       	pop	r7
    1b88:	6f 90       	pop	r6
    1b8a:	08 95       	ret

00001b8c <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1b8c:	cf 93       	push	r28
    1b8e:	df 93       	push	r29
    1b90:	ec 01       	movw	r28, r24
    1b92:	e6 2f       	mov	r30, r22
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1b94:	00 97       	sbiw	r24, 0x00	; 0
    1b96:	09 f4       	brne	.+2      	; 0x1b9a <xQueueGenericReset+0xe>
    1b98:	4f c0       	rjmp	.+158    	; 0x1c38 <xQueueGenericReset+0xac>
    1b9a:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1b9c:	22 23       	and	r18, r18
    1b9e:	09 f4       	brne	.+2      	; 0x1ba2 <xQueueGenericReset+0x16>
    1ba0:	4b c0       	rjmp	.+150    	; 0x1c38 <xQueueGenericReset+0xac>
    1ba2:	3c 8d       	ldd	r19, Y+28	; 0x1c
    1ba4:	8f ef       	ldi	r24, 0xFF	; 255
    1ba6:	9f e7       	ldi	r25, 0x7F	; 127
    1ba8:	62 2f       	mov	r22, r18
    1baa:	70 e0       	ldi	r23, 0x00	; 0
    1bac:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <__udivmodhi4>
    1bb0:	83 2f       	mov	r24, r19
    1bb2:	90 e0       	ldi	r25, 0x00	; 0
    1bb4:	68 17       	cp	r22, r24
    1bb6:	79 07       	cpc	r23, r25
    1bb8:	08 f4       	brcc	.+2      	; 0x1bbc <xQueueGenericReset+0x30>
    1bba:	3e c0       	rjmp	.+124    	; 0x1c38 <xQueueGenericReset+0xac>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1bbc:	0f b6       	in	r0, 0x3f	; 63
    1bbe:	f8 94       	cli
    1bc0:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1bc2:	32 9f       	mul	r19, r18
    1bc4:	c0 01       	movw	r24, r0
    1bc6:	11 24       	eor	r1, r1
    1bc8:	48 81       	ld	r20, Y
    1bca:	59 81       	ldd	r21, Y+1	; 0x01
    1bcc:	84 0f       	add	r24, r20
    1bce:	95 1f       	adc	r25, r21
    1bd0:	9d 83       	std	Y+5, r25	; 0x05
    1bd2:	8c 83       	std	Y+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1bd4:	1a 8e       	std	Y+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1bd6:	5b 83       	std	Y+3, r21	; 0x03
    1bd8:	4a 83       	std	Y+2, r20	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1bda:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	21 50       	subi	r18, 0x01	; 1
    1be0:	30 40       	sbci	r19, 0x00	; 0
    1be2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1be4:	90 e0       	ldi	r25, 0x00	; 0
    1be6:	bc 01       	movw	r22, r24
    1be8:	26 9f       	mul	r18, r22
    1bea:	c0 01       	movw	r24, r0
    1bec:	27 9f       	mul	r18, r23
    1bee:	90 0d       	add	r25, r0
    1bf0:	36 9f       	mul	r19, r22
    1bf2:	90 0d       	add	r25, r0
    1bf4:	11 24       	eor	r1, r1
    1bf6:	48 0f       	add	r20, r24
    1bf8:	59 1f       	adc	r21, r25
    1bfa:	5f 83       	std	Y+7, r21	; 0x07
    1bfc:	4e 83       	std	Y+6, r20	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1bfe:	8f ef       	ldi	r24, 0xFF	; 255
    1c00:	8d 8f       	std	Y+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1c02:	8e 8f       	std	Y+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1c04:	ee 23       	and	r30, r30
    1c06:	61 f4       	brne	.+24     	; 0x1c20 <xQueueGenericReset+0x94>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c08:	88 85       	ldd	r24, Y+8	; 0x08
    1c0a:	88 23       	and	r24, r24
    1c0c:	89 f0       	breq	.+34     	; 0x1c30 <xQueueGenericReset+0xa4>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c0e:	ce 01       	movw	r24, r28
    1c10:	08 96       	adiw	r24, 0x08	; 8
    1c12:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskRemoveFromEventList>
    1c16:	88 23       	and	r24, r24
    1c18:	59 f0       	breq	.+22     	; 0x1c30 <xQueueGenericReset+0xa4>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1c1a:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    1c1e:	08 c0       	rjmp	.+16     	; 0x1c30 <xQueueGenericReset+0xa4>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1c20:	ce 01       	movw	r24, r28
    1c22:	08 96       	adiw	r24, 0x08	; 8
    1c24:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1c28:	ce 01       	movw	r24, r28
    1c2a:	41 96       	adiw	r24, 0x11	; 17
    1c2c:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1c30:	0f 90       	pop	r0
    1c32:	0f be       	out	0x3f, r0	; 63
    1c34:	81 e0       	ldi	r24, 0x01	; 1
    1c36:	01 c0       	rjmp	.+2      	; 0x1c3a <xQueueGenericReset+0xae>
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1c38:	80 e0       	ldi	r24, 0x00	; 0
    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
}
    1c3a:	df 91       	pop	r29
    1c3c:	cf 91       	pop	r28
    1c3e:	08 95       	ret

00001c40 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1c40:	0f 93       	push	r16
    1c42:	1f 93       	push	r17
    1c44:	cf 93       	push	r28
    1c46:	df 93       	push	r29
    1c48:	18 2f       	mov	r17, r24
    1c4a:	06 2f       	mov	r16, r22
        Queue_t * pxNewQueue = NULL;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1c4c:	88 23       	and	r24, r24
    1c4e:	41 f1       	breq	.+80     	; 0x1ca0 <xQueueGenericCreate+0x60>
    1c50:	8f ef       	ldi	r24, 0xFF	; 255
    1c52:	9f e7       	ldi	r25, 0x7F	; 127
    1c54:	61 2f       	mov	r22, r17
    1c56:	70 e0       	ldi	r23, 0x00	; 0
    1c58:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <__udivmodhi4>
    1c5c:	80 2f       	mov	r24, r16
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	68 17       	cp	r22, r24
    1c62:	79 07       	cpc	r23, r25
    1c64:	e8 f0       	brcs	.+58     	; 0x1ca0 <xQueueGenericCreate+0x60>
    1c66:	01 9f       	mul	r16, r17
    1c68:	c0 01       	movw	r24, r0
    1c6a:	11 24       	eor	r1, r1
    1c6c:	2f e7       	ldi	r18, 0x7F	; 127
    1c6e:	81 3e       	cpi	r24, 0xE1	; 225
    1c70:	92 07       	cpc	r25, r18
    1c72:	b0 f4       	brcc	.+44     	; 0x1ca0 <xQueueGenericCreate+0x60>
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1c74:	4f 96       	adiw	r24, 0x1f	; 31
    1c76:	0e 94 ff 06 	call	0xdfe	; 0xdfe <pvPortMalloc>
    1c7a:	fc 01       	movw	r30, r24
    1c7c:	ec 01       	movw	r28, r24

            if( pxNewQueue != NULL )
    1c7e:	00 97       	sbiw	r24, 0x00	; 0
    1c80:	89 f0       	breq	.+34     	; 0x1ca4 <xQueueGenericCreate+0x64>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    1c82:	00 23       	and	r16, r16
    1c84:	19 f4       	brne	.+6      	; 0x1c8c <xQueueGenericCreate+0x4c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1c86:	91 83       	std	Z+1, r25	; 0x01
    1c88:	80 83       	st	Z, r24
    1c8a:	03 c0       	rjmp	.+6      	; 0x1c92 <xQueueGenericCreate+0x52>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1c8c:	4f 96       	adiw	r24, 0x1f	; 31
    1c8e:	91 83       	std	Z+1, r25	; 0x01
    1c90:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    1c92:	13 8f       	std	Z+27, r17	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    1c94:	04 8f       	std	Z+28, r16	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1c96:	cf 01       	movw	r24, r30
    1c98:	61 e0       	ldi	r22, 0x01	; 1
    1c9a:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <xQueueGenericReset>
    1c9e:	02 c0       	rjmp	.+4      	; 0x1ca4 <xQueueGenericCreate+0x64>
    1ca0:	c0 e0       	ldi	r28, 0x00	; 0
    1ca2:	d0 e0       	ldi	r29, 0x00	; 0
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
    1ca4:	ce 01       	movw	r24, r28
    1ca6:	df 91       	pop	r29
    1ca8:	cf 91       	pop	r28
    1caa:	1f 91       	pop	r17
    1cac:	0f 91       	pop	r16
    1cae:	08 95       	ret

00001cb0 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    1cb0:	80 91 ec 03 	lds	r24, 0x03EC
    1cb4:	8f 5f       	subi	r24, 0xFF	; 255
    1cb6:	80 93 ec 03 	sts	0x03EC, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    1cba:	08 95       	ret

00001cbc <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    1cbc:	0f b6       	in	r0, 0x3f	; 63
    1cbe:	f8 94       	cli
    1cc0:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    1cc2:	20 91 ef 03 	lds	r18, 0x03EF
    1cc6:	30 91 f0 03 	lds	r19, 0x03F0
    }
    portTICK_TYPE_EXIT_CRITICAL();
    1cca:	0f 90       	pop	r0
    1ccc:	0f be       	out	0x3f, r0	; 63

    return xTicks;
}
    1cce:	c9 01       	movw	r24, r18
    1cd0:	08 95       	ret

00001cd2 <xTaskGetTickCountFromISR>:
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    1cd2:	20 91 ef 03 	lds	r18, 0x03EF
    1cd6:	30 91 f0 03 	lds	r19, 0x03F0
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1cda:	c9 01       	movw	r24, r18
    1cdc:	08 95       	ret

00001cde <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    1cde:	80 91 f6 03 	lds	r24, 0x03F6
}
    1ce2:	08 95       	ret

00001ce4 <pcTaskGetName>:
{
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1ce4:	00 97       	sbiw	r24, 0x00	; 0
    1ce6:	21 f4       	brne	.+8      	; 0x1cf0 <pcTaskGetName+0xc>
    1ce8:	80 91 ea 03 	lds	r24, 0x03EA
    1cec:	90 91 eb 03 	lds	r25, 0x03EB
    1cf0:	9c 01       	movw	r18, r24
    1cf2:	27 5e       	subi	r18, 0xE7	; 231
    1cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
}
    1cf6:	c9 01       	movw	r24, r18
    1cf8:	08 95       	ret

00001cfa <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1cfa:	ef 92       	push	r14
    1cfc:	ff 92       	push	r15
    1cfe:	0f 93       	push	r16
    1d00:	1f 93       	push	r17
    1d02:	cf 93       	push	r28
    1d04:	df 93       	push	r29
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1d06:	80 91 ec 03 	lds	r24, 0x03EC
    1d0a:	88 23       	and	r24, r24
    1d0c:	09 f0       	breq	.+2      	; 0x1d10 <xTaskIncrementTick+0x16>
    1d0e:	fb c0       	rjmp	.+502    	; 0x1f06 <xTaskIncrementTick+0x20c>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    1d10:	00 91 ef 03 	lds	r16, 0x03EF
    1d14:	10 91 f0 03 	lds	r17, 0x03F0
    1d18:	0f 5f       	subi	r16, 0xFF	; 255
    1d1a:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    1d1c:	10 93 f0 03 	sts	0x03F0, r17
    1d20:	00 93 ef 03 	sts	0x03EF, r16

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    1d24:	01 15       	cp	r16, r1
    1d26:	11 05       	cpc	r17, r1
    1d28:	61 f5       	brne	.+88     	; 0x1d82 <xTaskIncrementTick+0x88>
        {
            taskSWITCH_DELAYED_LISTS();
    1d2a:	20 91 3b 04 	lds	r18, 0x043B
    1d2e:	30 91 3c 04 	lds	r19, 0x043C
    1d32:	80 91 3d 04 	lds	r24, 0x043D
    1d36:	90 91 3e 04 	lds	r25, 0x043E
    1d3a:	90 93 3c 04 	sts	0x043C, r25
    1d3e:	80 93 3b 04 	sts	0x043B, r24
    1d42:	30 93 3e 04 	sts	0x043E, r19
    1d46:	20 93 3d 04 	sts	0x043D, r18
    1d4a:	80 91 f3 03 	lds	r24, 0x03F3
    1d4e:	8f 5f       	subi	r24, 0xFF	; 255
    1d50:	80 93 f3 03 	sts	0x03F3, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1d54:	e0 91 3b 04 	lds	r30, 0x043B
    1d58:	f0 91 3c 04 	lds	r31, 0x043C
    1d5c:	80 81       	ld	r24, Z
    1d5e:	88 23       	and	r24, r24
    1d60:	19 f4       	brne	.+6      	; 0x1d68 <xTaskIncrementTick+0x6e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    1d62:	8f ef       	ldi	r24, 0xFF	; 255
    1d64:	9f ef       	ldi	r25, 0xFF	; 255
    1d66:	09 c0       	rjmp	.+18     	; 0x1d7a <xTaskIncrementTick+0x80>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1d68:	e0 91 3b 04 	lds	r30, 0x043B
    1d6c:	f0 91 3c 04 	lds	r31, 0x043C
    1d70:	05 80       	ldd	r0, Z+5	; 0x05
    1d72:	f6 81       	ldd	r31, Z+6	; 0x06
    1d74:	e0 2d       	mov	r30, r0
    1d76:	80 81       	ld	r24, Z
    1d78:	91 81       	ldd	r25, Z+1	; 0x01
    1d7a:	90 93 f2 03 	sts	0x03F2, r25
    1d7e:	80 93 f1 03 	sts	0x03F1, r24

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    1d82:	80 91 f1 03 	lds	r24, 0x03F1
    1d86:	90 91 f2 03 	lds	r25, 0x03F2
    1d8a:	08 17       	cp	r16, r24
    1d8c:	19 07       	cpc	r17, r25
    1d8e:	08 f4       	brcc	.+2      	; 0x1d92 <xTaskIncrementTick+0x98>
    1d90:	a2 c0       	rjmp	.+324    	; 0x1ed6 <xTaskIncrementTick+0x1dc>
    1d92:	ff 24       	eor	r15, r15
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    1d94:	39 e0       	ldi	r19, 0x09	; 9
    1d96:	e3 2e       	mov	r14, r19
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1d98:	e0 91 3b 04 	lds	r30, 0x043B
    1d9c:	f0 91 3c 04 	lds	r31, 0x043C
    1da0:	80 81       	ld	r24, Z
    1da2:	88 23       	and	r24, r24
    1da4:	19 f4       	brne	.+6      	; 0x1dac <xTaskIncrementTick+0xb2>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1da6:	8f ef       	ldi	r24, 0xFF	; 255
    1da8:	9f ef       	ldi	r25, 0xFF	; 255
    1daa:	0e c0       	rjmp	.+28     	; 0x1dc8 <xTaskIncrementTick+0xce>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1dac:	e0 91 3b 04 	lds	r30, 0x043B
    1db0:	f0 91 3c 04 	lds	r31, 0x043C
    1db4:	05 80       	ldd	r0, Z+5	; 0x05
    1db6:	f6 81       	ldd	r31, Z+6	; 0x06
    1db8:	e0 2d       	mov	r30, r0
    1dba:	c6 81       	ldd	r28, Z+6	; 0x06
    1dbc:	d7 81       	ldd	r29, Z+7	; 0x07
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1dbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1dc0:	9b 81       	ldd	r25, Y+3	; 0x03

                    if( xConstTickCount < xItemValue )
    1dc2:	08 17       	cp	r16, r24
    1dc4:	19 07       	cpc	r17, r25
    1dc6:	28 f4       	brcc	.+10     	; 0x1dd2 <xTaskIncrementTick+0xd8>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    1dc8:	90 93 f2 03 	sts	0x03F2, r25
    1dcc:	80 93 f1 03 	sts	0x03F1, r24
    1dd0:	83 c0       	rjmp	.+262    	; 0x1ed8 <xTaskIncrementTick+0x1de>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1dd2:	aa 85       	ldd	r26, Y+10	; 0x0a
    1dd4:	bb 85       	ldd	r27, Y+11	; 0x0b
    1dd6:	4c 81       	ldd	r20, Y+4	; 0x04
    1dd8:	5d 81       	ldd	r21, Y+5	; 0x05
    1dda:	8e 81       	ldd	r24, Y+6	; 0x06
    1ddc:	9f 81       	ldd	r25, Y+7	; 0x07
    1dde:	fa 01       	movw	r30, r20
    1de0:	95 83       	std	Z+5, r25	; 0x05
    1de2:	84 83       	std	Z+4, r24	; 0x04
    1de4:	2e 81       	ldd	r18, Y+6	; 0x06
    1de6:	3f 81       	ldd	r19, Y+7	; 0x07
    1de8:	f9 01       	movw	r30, r18
    1dea:	53 83       	std	Z+3, r21	; 0x03
    1dec:	42 83       	std	Z+2, r20	; 0x02
    1dee:	be 01       	movw	r22, r28
    1df0:	6e 5f       	subi	r22, 0xFE	; 254
    1df2:	7f 4f       	sbci	r23, 0xFF	; 255
    1df4:	11 96       	adiw	r26, 0x01	; 1
    1df6:	8d 91       	ld	r24, X+
    1df8:	9c 91       	ld	r25, X
    1dfa:	12 97       	sbiw	r26, 0x02	; 2
    1dfc:	86 17       	cp	r24, r22
    1dfe:	97 07       	cpc	r25, r23
    1e00:	21 f4       	brne	.+8      	; 0x1e0a <xTaskIncrementTick+0x110>
    1e02:	12 96       	adiw	r26, 0x02	; 2
    1e04:	3c 93       	st	X, r19
    1e06:	2e 93       	st	-X, r18
    1e08:	11 97       	sbiw	r26, 0x01	; 1
    1e0a:	1b 86       	std	Y+11, r1	; 0x0b
    1e0c:	1a 86       	std	Y+10, r1	; 0x0a
    1e0e:	8c 91       	ld	r24, X
    1e10:	81 50       	subi	r24, 0x01	; 1
    1e12:	8c 93       	st	X, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1e14:	ac 89       	ldd	r26, Y+20	; 0x14
    1e16:	bd 89       	ldd	r27, Y+21	; 0x15
    1e18:	10 97       	sbiw	r26, 0x00	; 0
    1e1a:	f9 f0       	breq	.+62     	; 0x1e5a <xTaskIncrementTick+0x160>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    1e1c:	2e 85       	ldd	r18, Y+14	; 0x0e
    1e1e:	3f 85       	ldd	r19, Y+15	; 0x0f
    1e20:	88 89       	ldd	r24, Y+16	; 0x10
    1e22:	99 89       	ldd	r25, Y+17	; 0x11
    1e24:	f9 01       	movw	r30, r18
    1e26:	95 83       	std	Z+5, r25	; 0x05
    1e28:	84 83       	std	Z+4, r24	; 0x04
    1e2a:	48 89       	ldd	r20, Y+16	; 0x10
    1e2c:	59 89       	ldd	r21, Y+17	; 0x11
    1e2e:	fa 01       	movw	r30, r20
    1e30:	33 83       	std	Z+3, r19	; 0x03
    1e32:	22 83       	std	Z+2, r18	; 0x02
    1e34:	9e 01       	movw	r18, r28
    1e36:	24 5f       	subi	r18, 0xF4	; 244
    1e38:	3f 4f       	sbci	r19, 0xFF	; 255
    1e3a:	11 96       	adiw	r26, 0x01	; 1
    1e3c:	8d 91       	ld	r24, X+
    1e3e:	9c 91       	ld	r25, X
    1e40:	12 97       	sbiw	r26, 0x02	; 2
    1e42:	82 17       	cp	r24, r18
    1e44:	93 07       	cpc	r25, r19
    1e46:	21 f4       	brne	.+8      	; 0x1e50 <xTaskIncrementTick+0x156>
    1e48:	12 96       	adiw	r26, 0x02	; 2
    1e4a:	5c 93       	st	X, r21
    1e4c:	4e 93       	st	-X, r20
    1e4e:	11 97       	sbiw	r26, 0x01	; 1
    1e50:	1d 8a       	std	Y+21, r1	; 0x15
    1e52:	1c 8a       	std	Y+20, r1	; 0x14
    1e54:	8c 91       	ld	r24, X
    1e56:	81 50       	subi	r24, 0x01	; 1
    1e58:	8c 93       	st	X, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    1e5a:	9e 89       	ldd	r25, Y+22	; 0x16
    1e5c:	80 91 ed 03 	lds	r24, 0x03ED
    1e60:	89 17       	cp	r24, r25
    1e62:	10 f4       	brcc	.+4      	; 0x1e68 <xTaskIncrementTick+0x16e>
    1e64:	90 93 ed 03 	sts	0x03ED, r25
    1e68:	89 2f       	mov	r24, r25
    1e6a:	90 e0       	ldi	r25, 0x00	; 0
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	23 e0       	ldi	r18, 0x03	; 3
    1e70:	ee 0f       	add	r30, r30
    1e72:	ff 1f       	adc	r31, r31
    1e74:	2a 95       	dec	r18
    1e76:	e1 f7       	brne	.-8      	; 0x1e70 <xTaskIncrementTick+0x176>
    1e78:	e8 0f       	add	r30, r24
    1e7a:	f9 1f       	adc	r31, r25
    1e7c:	e4 50       	subi	r30, 0x04	; 4
    1e7e:	fc 4f       	sbci	r31, 0xFC	; 252
    1e80:	a1 81       	ldd	r26, Z+1	; 0x01
    1e82:	b2 81       	ldd	r27, Z+2	; 0x02
    1e84:	bd 83       	std	Y+5, r27	; 0x05
    1e86:	ac 83       	std	Y+4, r26	; 0x04
    1e88:	14 96       	adiw	r26, 0x04	; 4
    1e8a:	8d 91       	ld	r24, X+
    1e8c:	9c 91       	ld	r25, X
    1e8e:	15 97       	sbiw	r26, 0x05	; 5
    1e90:	9f 83       	std	Y+7, r25	; 0x07
    1e92:	8e 83       	std	Y+6, r24	; 0x06
    1e94:	14 96       	adiw	r26, 0x04	; 4
    1e96:	ed 91       	ld	r30, X+
    1e98:	fc 91       	ld	r31, X
    1e9a:	15 97       	sbiw	r26, 0x05	; 5
    1e9c:	73 83       	std	Z+3, r23	; 0x03
    1e9e:	62 83       	std	Z+2, r22	; 0x02
    1ea0:	15 96       	adiw	r26, 0x05	; 5
    1ea2:	7c 93       	st	X, r23
    1ea4:	6e 93       	st	-X, r22
    1ea6:	14 97       	sbiw	r26, 0x04	; 4
    1ea8:	ee 89       	ldd	r30, Y+22	; 0x16
    1eaa:	ee 9d       	mul	r30, r14
    1eac:	f0 01       	movw	r30, r0
    1eae:	11 24       	eor	r1, r1
    1eb0:	e4 50       	subi	r30, 0x04	; 4
    1eb2:	fc 4f       	sbci	r31, 0xFC	; 252
    1eb4:	fb 87       	std	Y+11, r31	; 0x0b
    1eb6:	ea 87       	std	Y+10, r30	; 0x0a
    1eb8:	80 81       	ld	r24, Z
    1eba:	8f 5f       	subi	r24, 0xFF	; 255
    1ebc:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1ebe:	e0 91 ea 03 	lds	r30, 0x03EA
    1ec2:	f0 91 eb 03 	lds	r31, 0x03EB
    1ec6:	9e 89       	ldd	r25, Y+22	; 0x16
    1ec8:	86 89       	ldd	r24, Z+22	; 0x16
    1eca:	89 17       	cp	r24, r25
    1ecc:	08 f0       	brcs	.+2      	; 0x1ed0 <xTaskIncrementTick+0x1d6>
    1ece:	64 cf       	rjmp	.-312    	; 0x1d98 <xTaskIncrementTick+0x9e>
    1ed0:	ff 24       	eor	r15, r15
    1ed2:	f3 94       	inc	r15
    1ed4:	61 cf       	rjmp	.-318    	; 0x1d98 <xTaskIncrementTick+0x9e>
    1ed6:	ff 24       	eor	r15, r15
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1ed8:	e0 91 ea 03 	lds	r30, 0x03EA
    1edc:	f0 91 eb 03 	lds	r31, 0x03EB
    1ee0:	e6 89       	ldd	r30, Z+22	; 0x16
    1ee2:	89 e0       	ldi	r24, 0x09	; 9
    1ee4:	e8 9f       	mul	r30, r24
    1ee6:	f0 01       	movw	r30, r0
    1ee8:	11 24       	eor	r1, r1
    1eea:	e4 50       	subi	r30, 0x04	; 4
    1eec:	fc 4f       	sbci	r31, 0xFC	; 252
    1eee:	80 81       	ld	r24, Z
    1ef0:	82 30       	cpi	r24, 0x02	; 2
    1ef2:	10 f0       	brcs	.+4      	; 0x1ef8 <xTaskIncrementTick+0x1fe>
    1ef4:	ff 24       	eor	r15, r15
    1ef6:	f3 94       	inc	r15
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    1ef8:	80 91 ee 03 	lds	r24, 0x03EE
    1efc:	88 23       	and	r24, r24
    1efe:	69 f0       	breq	.+26     	; 0x1f1a <xTaskIncrementTick+0x220>
    1f00:	ff 24       	eor	r15, r15
    1f02:	f3 94       	inc	r15
    1f04:	0a c0       	rjmp	.+20     	; 0x1f1a <xTaskIncrementTick+0x220>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    1f06:	80 91 f4 03 	lds	r24, 0x03F4
    1f0a:	90 91 f5 03 	lds	r25, 0x03F5
    1f0e:	01 96       	adiw	r24, 0x01	; 1
    1f10:	90 93 f5 03 	sts	0x03F5, r25
    1f14:	80 93 f4 03 	sts	0x03F4, r24
    1f18:	ff 24       	eor	r15, r15
        }
        #endif
    }

    return xSwitchRequired;
}
    1f1a:	8f 2d       	mov	r24, r15
    1f1c:	df 91       	pop	r29
    1f1e:	cf 91       	pop	r28
    1f20:	1f 91       	pop	r17
    1f22:	0f 91       	pop	r16
    1f24:	ff 90       	pop	r15
    1f26:	ef 90       	pop	r14
    1f28:	08 95       	ret

00001f2a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1f2a:	80 91 ec 03 	lds	r24, 0x03EC
    1f2e:	88 23       	and	r24, r24
    1f30:	21 f0       	breq	.+8      	; 0x1f3a <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	80 93 ee 03 	sts	0x03EE, r24
    1f38:	08 95       	ret
    }
    else
    {
        xYieldPending = pdFALSE;
    1f3a:	10 92 ee 03 	sts	0x03EE, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1f3e:	20 91 ed 03 	lds	r18, 0x03ED
    1f42:	99 e0       	ldi	r25, 0x09	; 9
    1f44:	01 c0       	rjmp	.+2      	; 0x1f48 <vTaskSwitchContext+0x1e>
    1f46:	21 50       	subi	r18, 0x01	; 1
    1f48:	29 9f       	mul	r18, r25
    1f4a:	d0 01       	movw	r26, r0
    1f4c:	11 24       	eor	r1, r1
    1f4e:	a4 50       	subi	r26, 0x04	; 4
    1f50:	bc 4f       	sbci	r27, 0xFC	; 252
    1f52:	8c 91       	ld	r24, X
    1f54:	88 23       	and	r24, r24
    1f56:	b9 f3       	breq	.-18     	; 0x1f46 <vTaskSwitchContext+0x1c>
    1f58:	11 96       	adiw	r26, 0x01	; 1
    1f5a:	ed 91       	ld	r30, X+
    1f5c:	fc 91       	ld	r31, X
    1f5e:	12 97       	sbiw	r26, 0x02	; 2
    1f60:	02 80       	ldd	r0, Z+2	; 0x02
    1f62:	f3 81       	ldd	r31, Z+3	; 0x03
    1f64:	e0 2d       	mov	r30, r0
    1f66:	12 96       	adiw	r26, 0x02	; 2
    1f68:	fc 93       	st	X, r31
    1f6a:	ee 93       	st	-X, r30
    1f6c:	11 97       	sbiw	r26, 0x01	; 1
    1f6e:	cd 01       	movw	r24, r26
    1f70:	03 96       	adiw	r24, 0x03	; 3
    1f72:	e8 17       	cp	r30, r24
    1f74:	f9 07       	cpc	r31, r25
    1f76:	31 f4       	brne	.+12     	; 0x1f84 <vTaskSwitchContext+0x5a>
    1f78:	82 81       	ldd	r24, Z+2	; 0x02
    1f7a:	93 81       	ldd	r25, Z+3	; 0x03
    1f7c:	12 96       	adiw	r26, 0x02	; 2
    1f7e:	9c 93       	st	X, r25
    1f80:	8e 93       	st	-X, r24
    1f82:	11 97       	sbiw	r26, 0x01	; 1
    1f84:	11 96       	adiw	r26, 0x01	; 1
    1f86:	ed 91       	ld	r30, X+
    1f88:	fc 91       	ld	r31, X
    1f8a:	12 97       	sbiw	r26, 0x02	; 2
    1f8c:	86 81       	ldd	r24, Z+6	; 0x06
    1f8e:	97 81       	ldd	r25, Z+7	; 0x07
    1f90:	90 93 eb 03 	sts	0x03EB, r25
    1f94:	80 93 ea 03 	sts	0x03EA, r24
    1f98:	20 93 ed 03 	sts	0x03ED, r18
    1f9c:	08 95       	ret

00001f9e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1f9e:	cf 93       	push	r28
    1fa0:	df 93       	push	r29
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1fa2:	dc 01       	movw	r26, r24
    1fa4:	15 96       	adiw	r26, 0x05	; 5
    1fa6:	ed 91       	ld	r30, X+
    1fa8:	fc 91       	ld	r31, X
    1faa:	16 97       	sbiw	r26, 0x06	; 6
    1fac:	c6 81       	ldd	r28, Z+6	; 0x06
    1fae:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    1fb0:	ac 89       	ldd	r26, Y+20	; 0x14
    1fb2:	bd 89       	ldd	r27, Y+21	; 0x15
    1fb4:	4e 85       	ldd	r20, Y+14	; 0x0e
    1fb6:	5f 85       	ldd	r21, Y+15	; 0x0f
    1fb8:	88 89       	ldd	r24, Y+16	; 0x10
    1fba:	99 89       	ldd	r25, Y+17	; 0x11
    1fbc:	fa 01       	movw	r30, r20
    1fbe:	95 83       	std	Z+5, r25	; 0x05
    1fc0:	84 83       	std	Z+4, r24	; 0x04
    1fc2:	28 89       	ldd	r18, Y+16	; 0x10
    1fc4:	39 89       	ldd	r19, Y+17	; 0x11
    1fc6:	f9 01       	movw	r30, r18
    1fc8:	53 83       	std	Z+3, r21	; 0x03
    1fca:	42 83       	std	Z+2, r20	; 0x02
    1fcc:	ae 01       	movw	r20, r28
    1fce:	44 5f       	subi	r20, 0xF4	; 244
    1fd0:	5f 4f       	sbci	r21, 0xFF	; 255
    1fd2:	11 96       	adiw	r26, 0x01	; 1
    1fd4:	8d 91       	ld	r24, X+
    1fd6:	9c 91       	ld	r25, X
    1fd8:	12 97       	sbiw	r26, 0x02	; 2
    1fda:	84 17       	cp	r24, r20
    1fdc:	95 07       	cpc	r25, r21
    1fde:	21 f4       	brne	.+8      	; 0x1fe8 <xTaskRemoveFromEventList+0x4a>
    1fe0:	12 96       	adiw	r26, 0x02	; 2
    1fe2:	3c 93       	st	X, r19
    1fe4:	2e 93       	st	-X, r18
    1fe6:	11 97       	sbiw	r26, 0x01	; 1
    1fe8:	1d 8a       	std	Y+21, r1	; 0x15
    1fea:	1c 8a       	std	Y+20, r1	; 0x14
    1fec:	8c 91       	ld	r24, X
    1fee:	81 50       	subi	r24, 0x01	; 1
    1ff0:	8c 93       	st	X, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1ff2:	80 91 ec 03 	lds	r24, 0x03EC
    1ff6:	88 23       	and	r24, r24
    1ff8:	09 f0       	breq	.+2      	; 0x1ffc <xTaskRemoveFromEventList+0x5e>
    1ffa:	55 c0       	rjmp	.+170    	; 0x20a6 <xTaskRemoveFromEventList+0x108>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    1ffc:	aa 85       	ldd	r26, Y+10	; 0x0a
    1ffe:	bb 85       	ldd	r27, Y+11	; 0x0b
    2000:	4c 81       	ldd	r20, Y+4	; 0x04
    2002:	5d 81       	ldd	r21, Y+5	; 0x05
    2004:	8e 81       	ldd	r24, Y+6	; 0x06
    2006:	9f 81       	ldd	r25, Y+7	; 0x07
    2008:	fa 01       	movw	r30, r20
    200a:	95 83       	std	Z+5, r25	; 0x05
    200c:	84 83       	std	Z+4, r24	; 0x04
    200e:	2e 81       	ldd	r18, Y+6	; 0x06
    2010:	3f 81       	ldd	r19, Y+7	; 0x07
    2012:	f9 01       	movw	r30, r18
    2014:	53 83       	std	Z+3, r21	; 0x03
    2016:	42 83       	std	Z+2, r20	; 0x02
    2018:	ae 01       	movw	r20, r28
    201a:	4e 5f       	subi	r20, 0xFE	; 254
    201c:	5f 4f       	sbci	r21, 0xFF	; 255
    201e:	11 96       	adiw	r26, 0x01	; 1
    2020:	8d 91       	ld	r24, X+
    2022:	9c 91       	ld	r25, X
    2024:	12 97       	sbiw	r26, 0x02	; 2
    2026:	84 17       	cp	r24, r20
    2028:	95 07       	cpc	r25, r21
    202a:	21 f4       	brne	.+8      	; 0x2034 <xTaskRemoveFromEventList+0x96>
    202c:	12 96       	adiw	r26, 0x02	; 2
    202e:	3c 93       	st	X, r19
    2030:	2e 93       	st	-X, r18
    2032:	11 97       	sbiw	r26, 0x01	; 1
    2034:	1b 86       	std	Y+11, r1	; 0x0b
    2036:	1a 86       	std	Y+10, r1	; 0x0a
    2038:	8c 91       	ld	r24, X
    203a:	81 50       	subi	r24, 0x01	; 1
    203c:	8c 93       	st	X, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    203e:	9e 89       	ldd	r25, Y+22	; 0x16
    2040:	80 91 ed 03 	lds	r24, 0x03ED
    2044:	89 17       	cp	r24, r25
    2046:	10 f4       	brcc	.+4      	; 0x204c <xTaskRemoveFromEventList+0xae>
    2048:	90 93 ed 03 	sts	0x03ED, r25
    204c:	89 2f       	mov	r24, r25
    204e:	90 e0       	ldi	r25, 0x00	; 0
    2050:	fc 01       	movw	r30, r24
    2052:	63 e0       	ldi	r22, 0x03	; 3
    2054:	ee 0f       	add	r30, r30
    2056:	ff 1f       	adc	r31, r31
    2058:	6a 95       	dec	r22
    205a:	e1 f7       	brne	.-8      	; 0x2054 <xTaskRemoveFromEventList+0xb6>
    205c:	e8 0f       	add	r30, r24
    205e:	f9 1f       	adc	r31, r25
    2060:	e4 50       	subi	r30, 0x04	; 4
    2062:	fc 4f       	sbci	r31, 0xFC	; 252
    2064:	a1 81       	ldd	r26, Z+1	; 0x01
    2066:	b2 81       	ldd	r27, Z+2	; 0x02
    2068:	bd 83       	std	Y+5, r27	; 0x05
    206a:	ac 83       	std	Y+4, r26	; 0x04
    206c:	14 96       	adiw	r26, 0x04	; 4
    206e:	8d 91       	ld	r24, X+
    2070:	9c 91       	ld	r25, X
    2072:	15 97       	sbiw	r26, 0x05	; 5
    2074:	9f 83       	std	Y+7, r25	; 0x07
    2076:	8e 83       	std	Y+6, r24	; 0x06
    2078:	14 96       	adiw	r26, 0x04	; 4
    207a:	ed 91       	ld	r30, X+
    207c:	fc 91       	ld	r31, X
    207e:	15 97       	sbiw	r26, 0x05	; 5
    2080:	53 83       	std	Z+3, r21	; 0x03
    2082:	42 83       	std	Z+2, r20	; 0x02
    2084:	15 96       	adiw	r26, 0x05	; 5
    2086:	5c 93       	st	X, r21
    2088:	4e 93       	st	-X, r20
    208a:	14 97       	sbiw	r26, 0x04	; 4
    208c:	ee 89       	ldd	r30, Y+22	; 0x16
    208e:	89 e0       	ldi	r24, 0x09	; 9
    2090:	e8 9f       	mul	r30, r24
    2092:	f0 01       	movw	r30, r0
    2094:	11 24       	eor	r1, r1
    2096:	e4 50       	subi	r30, 0x04	; 4
    2098:	fc 4f       	sbci	r31, 0xFC	; 252
    209a:	fb 87       	std	Y+11, r31	; 0x0b
    209c:	ea 87       	std	Y+10, r30	; 0x0a
    209e:	80 81       	ld	r24, Z
    20a0:	8f 5f       	subi	r24, 0xFF	; 255
    20a2:	80 83       	st	Z, r24
    20a4:	1f c0       	rjmp	.+62     	; 0x20e4 <xTaskRemoveFromEventList+0x146>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    20a6:	a0 91 40 04 	lds	r26, 0x0440
    20aa:	b0 91 41 04 	lds	r27, 0x0441
    20ae:	bf 87       	std	Y+15, r27	; 0x0f
    20b0:	ae 87       	std	Y+14, r26	; 0x0e
    20b2:	14 96       	adiw	r26, 0x04	; 4
    20b4:	8d 91       	ld	r24, X+
    20b6:	9c 91       	ld	r25, X
    20b8:	15 97       	sbiw	r26, 0x05	; 5
    20ba:	99 8b       	std	Y+17, r25	; 0x11
    20bc:	88 8b       	std	Y+16, r24	; 0x10
    20be:	14 96       	adiw	r26, 0x04	; 4
    20c0:	ed 91       	ld	r30, X+
    20c2:	fc 91       	ld	r31, X
    20c4:	15 97       	sbiw	r26, 0x05	; 5
    20c6:	53 83       	std	Z+3, r21	; 0x03
    20c8:	42 83       	std	Z+2, r20	; 0x02
    20ca:	15 96       	adiw	r26, 0x05	; 5
    20cc:	5c 93       	st	X, r21
    20ce:	4e 93       	st	-X, r20
    20d0:	14 97       	sbiw	r26, 0x04	; 4
    20d2:	8f e3       	ldi	r24, 0x3F	; 63
    20d4:	94 e0       	ldi	r25, 0x04	; 4
    20d6:	9d 8b       	std	Y+21, r25	; 0x15
    20d8:	8c 8b       	std	Y+20, r24	; 0x14
    20da:	80 91 3f 04 	lds	r24, 0x043F
    20de:	8f 5f       	subi	r24, 0xFF	; 255
    20e0:	80 93 3f 04 	sts	0x043F, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    20e4:	e0 91 ea 03 	lds	r30, 0x03EA
    20e8:	f0 91 eb 03 	lds	r31, 0x03EB
    20ec:	9e 89       	ldd	r25, Y+22	; 0x16
    20ee:	86 89       	ldd	r24, Z+22	; 0x16
    20f0:	89 17       	cp	r24, r25
    20f2:	10 f0       	brcs	.+4      	; 0x20f8 <xTaskRemoveFromEventList+0x15a>
    20f4:	80 e0       	ldi	r24, 0x00	; 0
    20f6:	03 c0       	rjmp	.+6      	; 0x20fe <xTaskRemoveFromEventList+0x160>
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    20f8:	81 e0       	ldi	r24, 0x01	; 1
    20fa:	80 93 ee 03 	sts	0x03EE, r24
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    20fe:	df 91       	pop	r29
    2100:	cf 91       	pop	r28
    2102:	08 95       	ret

00002104 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    2104:	cf 93       	push	r28
    2106:	df 93       	push	r29
    2108:	dc 01       	movw	r26, r24
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    210a:	70 68       	ori	r23, 0x80	; 128
    210c:	11 96       	adiw	r26, 0x01	; 1
    210e:	7c 93       	st	X, r23
    2110:	6e 93       	st	-X, r22

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2112:	16 96       	adiw	r26, 0x06	; 6
    2114:	2d 91       	ld	r18, X+
    2116:	3c 91       	ld	r19, X
    2118:	17 97       	sbiw	r26, 0x07	; 7
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    211a:	18 96       	adiw	r26, 0x08	; 8
    211c:	cd 91       	ld	r28, X+
    211e:	dc 91       	ld	r29, X
    2120:	19 97       	sbiw	r26, 0x09	; 9
    2122:	12 96       	adiw	r26, 0x02	; 2
    2124:	6d 91       	ld	r22, X+
    2126:	7c 91       	ld	r23, X
    2128:	13 97       	sbiw	r26, 0x03	; 3
    212a:	14 96       	adiw	r26, 0x04	; 4
    212c:	8d 91       	ld	r24, X+
    212e:	9c 91       	ld	r25, X
    2130:	15 97       	sbiw	r26, 0x05	; 5
    2132:	fb 01       	movw	r30, r22
    2134:	95 83       	std	Z+5, r25	; 0x05
    2136:	84 83       	std	Z+4, r24	; 0x04
    2138:	14 96       	adiw	r26, 0x04	; 4
    213a:	4d 91       	ld	r20, X+
    213c:	5c 91       	ld	r21, X
    213e:	15 97       	sbiw	r26, 0x05	; 5
    2140:	fa 01       	movw	r30, r20
    2142:	73 83       	std	Z+3, r23	; 0x03
    2144:	62 83       	std	Z+2, r22	; 0x02
    2146:	89 81       	ldd	r24, Y+1	; 0x01
    2148:	9a 81       	ldd	r25, Y+2	; 0x02
    214a:	8a 17       	cp	r24, r26
    214c:	9b 07       	cpc	r25, r27
    214e:	11 f4       	brne	.+4      	; 0x2154 <vTaskRemoveFromUnorderedEventList+0x50>
    2150:	5a 83       	std	Y+2, r21	; 0x02
    2152:	49 83       	std	Y+1, r20	; 0x01
    2154:	19 96       	adiw	r26, 0x09	; 9
    2156:	1c 92       	st	X, r1
    2158:	1e 92       	st	-X, r1
    215a:	18 97       	sbiw	r26, 0x08	; 8
    215c:	88 81       	ld	r24, Y
    215e:	81 50       	subi	r24, 0x01	; 1
    2160:	88 83       	st	Y, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    2162:	e9 01       	movw	r28, r18
    2164:	aa 85       	ldd	r26, Y+10	; 0x0a
    2166:	bb 85       	ldd	r27, Y+11	; 0x0b
    2168:	4c 81       	ldd	r20, Y+4	; 0x04
    216a:	5d 81       	ldd	r21, Y+5	; 0x05
    216c:	8e 81       	ldd	r24, Y+6	; 0x06
    216e:	9f 81       	ldd	r25, Y+7	; 0x07
    2170:	fa 01       	movw	r30, r20
    2172:	95 83       	std	Z+5, r25	; 0x05
    2174:	84 83       	std	Z+4, r24	; 0x04
    2176:	0e 80       	ldd	r0, Y+6	; 0x06
    2178:	df 81       	ldd	r29, Y+7	; 0x07
    217a:	c0 2d       	mov	r28, r0
    217c:	5b 83       	std	Y+3, r21	; 0x03
    217e:	4a 83       	std	Y+2, r20	; 0x02
    2180:	a9 01       	movw	r20, r18
    2182:	4e 5f       	subi	r20, 0xFE	; 254
    2184:	5f 4f       	sbci	r21, 0xFF	; 255
    2186:	11 96       	adiw	r26, 0x01	; 1
    2188:	8d 91       	ld	r24, X+
    218a:	9c 91       	ld	r25, X
    218c:	12 97       	sbiw	r26, 0x02	; 2
    218e:	84 17       	cp	r24, r20
    2190:	95 07       	cpc	r25, r21
    2192:	21 f4       	brne	.+8      	; 0x219c <vTaskRemoveFromUnorderedEventList+0x98>
    2194:	12 96       	adiw	r26, 0x02	; 2
    2196:	dc 93       	st	X, r29
    2198:	ce 93       	st	-X, r28
    219a:	11 97       	sbiw	r26, 0x01	; 1
    219c:	e9 01       	movw	r28, r18
    219e:	1b 86       	std	Y+11, r1	; 0x0b
    21a0:	1a 86       	std	Y+10, r1	; 0x0a
    21a2:	8c 91       	ld	r24, X
    21a4:	81 50       	subi	r24, 0x01	; 1
    21a6:	8c 93       	st	X, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    21a8:	9e 89       	ldd	r25, Y+22	; 0x16
    21aa:	80 91 ed 03 	lds	r24, 0x03ED
    21ae:	89 17       	cp	r24, r25
    21b0:	10 f4       	brcc	.+4      	; 0x21b6 <vTaskRemoveFromUnorderedEventList+0xb2>
    21b2:	90 93 ed 03 	sts	0x03ED, r25
    21b6:	89 2f       	mov	r24, r25
    21b8:	90 e0       	ldi	r25, 0x00	; 0
    21ba:	fc 01       	movw	r30, r24
    21bc:	73 e0       	ldi	r23, 0x03	; 3
    21be:	ee 0f       	add	r30, r30
    21c0:	ff 1f       	adc	r31, r31
    21c2:	7a 95       	dec	r23
    21c4:	e1 f7       	brne	.-8      	; 0x21be <vTaskRemoveFromUnorderedEventList+0xba>
    21c6:	e8 0f       	add	r30, r24
    21c8:	f9 1f       	adc	r31, r25
    21ca:	e4 50       	subi	r30, 0x04	; 4
    21cc:	fc 4f       	sbci	r31, 0xFC	; 252
    21ce:	a1 81       	ldd	r26, Z+1	; 0x01
    21d0:	b2 81       	ldd	r27, Z+2	; 0x02
    21d2:	f9 01       	movw	r30, r18
    21d4:	b5 83       	std	Z+5, r27	; 0x05
    21d6:	a4 83       	std	Z+4, r26	; 0x04
    21d8:	14 96       	adiw	r26, 0x04	; 4
    21da:	8d 91       	ld	r24, X+
    21dc:	9c 91       	ld	r25, X
    21de:	15 97       	sbiw	r26, 0x05	; 5
    21e0:	97 83       	std	Z+7, r25	; 0x07
    21e2:	86 83       	std	Z+6, r24	; 0x06
    21e4:	14 96       	adiw	r26, 0x04	; 4
    21e6:	ed 91       	ld	r30, X+
    21e8:	fc 91       	ld	r31, X
    21ea:	15 97       	sbiw	r26, 0x05	; 5
    21ec:	53 83       	std	Z+3, r21	; 0x03
    21ee:	42 83       	std	Z+2, r20	; 0x02
    21f0:	15 96       	adiw	r26, 0x05	; 5
    21f2:	5c 93       	st	X, r21
    21f4:	4e 93       	st	-X, r20
    21f6:	14 97       	sbiw	r26, 0x04	; 4
    21f8:	d9 01       	movw	r26, r18
    21fa:	56 96       	adiw	r26, 0x16	; 22
    21fc:	ec 91       	ld	r30, X
    21fe:	56 97       	sbiw	r26, 0x16	; 22
    2200:	89 e0       	ldi	r24, 0x09	; 9
    2202:	e8 9f       	mul	r30, r24
    2204:	f0 01       	movw	r30, r0
    2206:	11 24       	eor	r1, r1
    2208:	e4 50       	subi	r30, 0x04	; 4
    220a:	fc 4f       	sbci	r31, 0xFC	; 252
    220c:	1b 96       	adiw	r26, 0x0b	; 11
    220e:	fc 93       	st	X, r31
    2210:	ee 93       	st	-X, r30
    2212:	1a 97       	sbiw	r26, 0x0a	; 10
    2214:	80 81       	ld	r24, Z
    2216:	8f 5f       	subi	r24, 0xFF	; 255
    2218:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    221a:	e0 91 ea 03 	lds	r30, 0x03EA
    221e:	f0 91 eb 03 	lds	r31, 0x03EB
    2222:	56 96       	adiw	r26, 0x16	; 22
    2224:	9c 91       	ld	r25, X
    2226:	86 89       	ldd	r24, Z+22	; 0x16
    2228:	89 17       	cp	r24, r25
    222a:	18 f4       	brcc	.+6      	; 0x2232 <vTaskRemoveFromUnorderedEventList+0x12e>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    222c:	81 e0       	ldi	r24, 0x01	; 1
    222e:	80 93 ee 03 	sts	0x03EE, r24
    }
}
    2232:	df 91       	pop	r29
    2234:	cf 91       	pop	r28
    2236:	08 95       	ret

00002238 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2238:	fc 01       	movw	r30, r24
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    223a:	0f b6       	in	r0, 0x3f	; 63
    223c:	f8 94       	cli
    223e:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    2240:	80 91 f3 03 	lds	r24, 0x03F3
    2244:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    2246:	80 91 ef 03 	lds	r24, 0x03EF
    224a:	90 91 f0 03 	lds	r25, 0x03F0
    224e:	92 83       	std	Z+2, r25	; 0x02
    2250:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2252:	0f 90       	pop	r0
    2254:	0f be       	out	0x3f, r0	; 63
}
    2256:	08 95       	ret

00002258 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2258:	fc 01       	movw	r30, r24
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    225a:	80 91 f3 03 	lds	r24, 0x03F3
    225e:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    2260:	80 91 ef 03 	lds	r24, 0x03EF
    2264:	90 91 f0 03 	lds	r25, 0x03F0
    2268:	92 83       	std	Z+2, r25	; 0x02
    226a:	81 83       	std	Z+1, r24	; 0x01
}
    226c:	08 95       	ret

0000226e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    226e:	dc 01       	movw	r26, r24
    2270:	fb 01       	movw	r30, r22
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    2272:	0f b6       	in	r0, 0x3f	; 63
    2274:	f8 94       	cli
    2276:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    2278:	40 91 ef 03 	lds	r20, 0x03EF
    227c:	50 91 f0 03 	lds	r21, 0x03F0
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2280:	11 96       	adiw	r26, 0x01	; 1
    2282:	2d 91       	ld	r18, X+
    2284:	3c 91       	ld	r19, X
    2286:	12 97       	sbiw	r26, 0x02	; 2
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2288:	90 91 f3 03 	lds	r25, 0x03F3
    228c:	8c 91       	ld	r24, X
    228e:	98 17       	cp	r25, r24
    2290:	19 f0       	breq	.+6      	; 0x2298 <xTaskCheckForTimeOut+0x2a>
    2292:	42 17       	cp	r20, r18
    2294:	53 07       	cpc	r21, r19
    2296:	d0 f4       	brcc	.+52     	; 0x22cc <xTaskCheckForTimeOut+0x5e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2298:	ca 01       	movw	r24, r20
    229a:	82 1b       	sub	r24, r18
    229c:	93 0b       	sbc	r25, r19
    229e:	9c 01       	movw	r18, r24
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    22a0:	80 81       	ld	r24, Z
    22a2:	91 81       	ldd	r25, Z+1	; 0x01
    22a4:	28 17       	cp	r18, r24
    22a6:	39 07       	cpc	r19, r25
    22a8:	88 f4       	brcc	.+34     	; 0x22cc <xTaskCheckForTimeOut+0x5e>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    22aa:	82 1b       	sub	r24, r18
    22ac:	93 0b       	sbc	r25, r19
    22ae:	91 83       	std	Z+1, r25	; 0x01
    22b0:	80 83       	st	Z, r24
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    22b2:	80 91 f3 03 	lds	r24, 0x03F3
    22b6:	8c 93       	st	X, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    22b8:	80 91 ef 03 	lds	r24, 0x03EF
    22bc:	90 91 f0 03 	lds	r25, 0x03F0
    22c0:	12 96       	adiw	r26, 0x02	; 2
    22c2:	9c 93       	st	X, r25
    22c4:	8e 93       	st	-X, r24
    22c6:	11 97       	sbiw	r26, 0x01	; 1
    22c8:	80 e0       	ldi	r24, 0x00	; 0
    22ca:	03 c0       	rjmp	.+6      	; 0x22d2 <xTaskCheckForTimeOut+0x64>
            vTaskInternalSetTimeOutState( pxTimeOut );
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    22cc:	11 82       	std	Z+1, r1	; 0x01
    22ce:	10 82       	st	Z, r1
    22d0:	81 e0       	ldi	r24, 0x01	; 1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    22d2:	0f 90       	pop	r0
    22d4:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    22d6:	08 95       	ret

000022d8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    22d8:	81 e0       	ldi	r24, 0x01	; 1
    22da:	80 93 ee 03 	sts	0x03EE, r24
}
    22de:	08 95       	ret

000022e0 <xTaskGetCurrentTaskHandle>:
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    22e0:	20 91 ea 03 	lds	r18, 0x03EA
    22e4:	30 91 eb 03 	lds	r19, 0x03EB

        return xReturn;
    }
    22e8:	c9 01       	movw	r24, r18
    22ea:	08 95       	ret

000022ec <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    22ec:	e0 91 ea 03 	lds	r30, 0x03EA
    22f0:	f0 91 eb 03 	lds	r31, 0x03EB
    22f4:	84 85       	ldd	r24, Z+12	; 0x0c
    22f6:	95 85       	ldd	r25, Z+13	; 0x0d

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    22f8:	a0 91 ea 03 	lds	r26, 0x03EA
    22fc:	b0 91 eb 03 	lds	r27, 0x03EB
    2300:	e0 91 ea 03 	lds	r30, 0x03EA
    2304:	f0 91 eb 03 	lds	r31, 0x03EB
    2308:	46 89       	ldd	r20, Z+22	; 0x16
    230a:	25 e0       	ldi	r18, 0x05	; 5
    230c:	30 e0       	ldi	r19, 0x00	; 0
    230e:	24 1b       	sub	r18, r20
    2310:	31 09       	sbc	r19, r1
    2312:	1d 96       	adiw	r26, 0x0d	; 13
    2314:	3c 93       	st	X, r19
    2316:	2e 93       	st	-X, r18
    2318:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
}
    231a:	08 95       	ret

0000231c <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    231c:	cf 92       	push	r12
    231e:	df 92       	push	r13
    2320:	ef 92       	push	r14
    2322:	ff 92       	push	r15
    2324:	0f 93       	push	r16
    2326:	cf 93       	push	r28
    2328:	df 93       	push	r29
    232a:	ec 01       	movw	r28, r24

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
    232c:	e1 14       	cp	r14, r1
    232e:	f1 04       	cpc	r15, r1
    2330:	89 f0       	breq	.+34     	; 0x2354 <xTaskGenericNotifyFromISR+0x38>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    2332:	e6 2f       	mov	r30, r22
    2334:	f0 e0       	ldi	r31, 0x00	; 0
    2336:	ee 0f       	add	r30, r30
    2338:	ff 1f       	adc	r31, r31
    233a:	ee 0f       	add	r30, r30
    233c:	ff 1f       	adc	r31, r31
    233e:	e8 0f       	add	r30, r24
    2340:	f9 1f       	adc	r31, r25
    2342:	81 a1       	ldd	r24, Z+33	; 0x21
    2344:	92 a1       	ldd	r25, Z+34	; 0x22
    2346:	a3 a1       	ldd	r26, Z+35	; 0x23
    2348:	b4 a1       	ldd	r27, Z+36	; 0x24
    234a:	f7 01       	movw	r30, r14
    234c:	80 83       	st	Z, r24
    234e:	91 83       	std	Z+1, r25	; 0x01
    2350:	a2 83       	std	Z+2, r26	; 0x02
    2352:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    2354:	a6 2f       	mov	r26, r22
    2356:	b0 e0       	ldi	r27, 0x00	; 0
    2358:	fe 01       	movw	r30, r28
    235a:	ea 0f       	add	r30, r26
    235c:	fb 1f       	adc	r31, r27
    235e:	65 a1       	ldd	r22, Z+37	; 0x25
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    2360:	82 e0       	ldi	r24, 0x02	; 2
    2362:	85 a3       	std	Z+37, r24	; 0x25

            switch( eAction )
    2364:	02 30       	cpi	r16, 0x02	; 2
    2366:	d1 f0       	breq	.+52     	; 0x239c <xTaskGenericNotifyFromISR+0x80>
    2368:	03 30       	cpi	r16, 0x03	; 3
    236a:	18 f4       	brcc	.+6      	; 0x2372 <xTaskGenericNotifyFromISR+0x56>
    236c:	01 30       	cpi	r16, 0x01	; 1
    236e:	c9 f5       	brne	.+114    	; 0x23e2 <xTaskGenericNotifyFromISR+0xc6>
    2370:	05 c0       	rjmp	.+10     	; 0x237c <xTaskGenericNotifyFromISR+0x60>
    2372:	03 30       	cpi	r16, 0x03	; 3
    2374:	51 f1       	breq	.+84     	; 0x23ca <xTaskGenericNotifyFromISR+0xae>
    2376:	04 30       	cpi	r16, 0x04	; 4
    2378:	a1 f5       	brne	.+104    	; 0x23e2 <xTaskGenericNotifyFromISR+0xc6>
    237a:	23 c0       	rjmp	.+70     	; 0x23c2 <xTaskGenericNotifyFromISR+0xa6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    237c:	fd 01       	movw	r30, r26
    237e:	ee 0f       	add	r30, r30
    2380:	ff 1f       	adc	r31, r31
    2382:	ee 0f       	add	r30, r30
    2384:	ff 1f       	adc	r31, r31
    2386:	ec 0f       	add	r30, r28
    2388:	fd 1f       	adc	r31, r29
    238a:	81 a1       	ldd	r24, Z+33	; 0x21
    238c:	92 a1       	ldd	r25, Z+34	; 0x22
    238e:	a3 a1       	ldd	r26, Z+35	; 0x23
    2390:	b4 a1       	ldd	r27, Z+36	; 0x24
    2392:	82 2b       	or	r24, r18
    2394:	93 2b       	or	r25, r19
    2396:	a4 2b       	or	r26, r20
    2398:	b5 2b       	or	r27, r21
    239a:	0e c0       	rjmp	.+28     	; 0x23b8 <xTaskGenericNotifyFromISR+0x9c>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    239c:	fd 01       	movw	r30, r26
    239e:	ee 0f       	add	r30, r30
    23a0:	ff 1f       	adc	r31, r31
    23a2:	ee 0f       	add	r30, r30
    23a4:	ff 1f       	adc	r31, r31
    23a6:	ec 0f       	add	r30, r28
    23a8:	fd 1f       	adc	r31, r29
    23aa:	81 a1       	ldd	r24, Z+33	; 0x21
    23ac:	92 a1       	ldd	r25, Z+34	; 0x22
    23ae:	a3 a1       	ldd	r26, Z+35	; 0x23
    23b0:	b4 a1       	ldd	r27, Z+36	; 0x24
    23b2:	01 96       	adiw	r24, 0x01	; 1
    23b4:	a1 1d       	adc	r26, r1
    23b6:	b1 1d       	adc	r27, r1
    23b8:	81 a3       	std	Z+33, r24	; 0x21
    23ba:	92 a3       	std	Z+34, r25	; 0x22
    23bc:	a3 a3       	std	Z+35, r26	; 0x23
    23be:	b4 a3       	std	Z+36, r27	; 0x24
    23c0:	10 c0       	rjmp	.+32     	; 0x23e2 <xTaskGenericNotifyFromISR+0xc6>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    23c2:	62 30       	cpi	r22, 0x02	; 2
    23c4:	11 f4       	brne	.+4      	; 0x23ca <xTaskGenericNotifyFromISR+0xae>
    23c6:	80 e0       	ldi	r24, 0x00	; 0
    23c8:	9d c0       	rjmp	.+314    	; 0x2504 <xTaskGenericNotifyFromISR+0x1e8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    23ca:	aa 0f       	add	r26, r26
    23cc:	bb 1f       	adc	r27, r27
    23ce:	aa 0f       	add	r26, r26
    23d0:	bb 1f       	adc	r27, r27
    23d2:	ac 0f       	add	r26, r28
    23d4:	bd 1f       	adc	r27, r29
    23d6:	91 96       	adiw	r26, 0x21	; 33
    23d8:	2d 93       	st	X+, r18
    23da:	3d 93       	st	X+, r19
    23dc:	4d 93       	st	X+, r20
    23de:	5c 93       	st	X, r21
    23e0:	94 97       	sbiw	r26, 0x24	; 36

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    23e2:	61 30       	cpi	r22, 0x01	; 1
    23e4:	09 f0       	breq	.+2      	; 0x23e8 <xTaskGenericNotifyFromISR+0xcc>
    23e6:	8d c0       	rjmp	.+282    	; 0x2502 <xTaskGenericNotifyFromISR+0x1e6>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    23e8:	80 91 ec 03 	lds	r24, 0x03EC
    23ec:	88 23       	and	r24, r24
    23ee:	09 f0       	breq	.+2      	; 0x23f2 <xTaskGenericNotifyFromISR+0xd6>
    23f0:	55 c0       	rjmp	.+170    	; 0x249c <xTaskGenericNotifyFromISR+0x180>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    23f2:	aa 85       	ldd	r26, Y+10	; 0x0a
    23f4:	bb 85       	ldd	r27, Y+11	; 0x0b
    23f6:	4c 81       	ldd	r20, Y+4	; 0x04
    23f8:	5d 81       	ldd	r21, Y+5	; 0x05
    23fa:	8e 81       	ldd	r24, Y+6	; 0x06
    23fc:	9f 81       	ldd	r25, Y+7	; 0x07
    23fe:	fa 01       	movw	r30, r20
    2400:	95 83       	std	Z+5, r25	; 0x05
    2402:	84 83       	std	Z+4, r24	; 0x04
    2404:	2e 81       	ldd	r18, Y+6	; 0x06
    2406:	3f 81       	ldd	r19, Y+7	; 0x07
    2408:	f9 01       	movw	r30, r18
    240a:	53 83       	std	Z+3, r21	; 0x03
    240c:	42 83       	std	Z+2, r20	; 0x02
    240e:	ae 01       	movw	r20, r28
    2410:	4e 5f       	subi	r20, 0xFE	; 254
    2412:	5f 4f       	sbci	r21, 0xFF	; 255
    2414:	11 96       	adiw	r26, 0x01	; 1
    2416:	8d 91       	ld	r24, X+
    2418:	9c 91       	ld	r25, X
    241a:	12 97       	sbiw	r26, 0x02	; 2
    241c:	84 17       	cp	r24, r20
    241e:	95 07       	cpc	r25, r21
    2420:	21 f4       	brne	.+8      	; 0x242a <xTaskGenericNotifyFromISR+0x10e>
    2422:	12 96       	adiw	r26, 0x02	; 2
    2424:	3c 93       	st	X, r19
    2426:	2e 93       	st	-X, r18
    2428:	11 97       	sbiw	r26, 0x01	; 1
    242a:	1b 86       	std	Y+11, r1	; 0x0b
    242c:	1a 86       	std	Y+10, r1	; 0x0a
    242e:	8c 91       	ld	r24, X
    2430:	81 50       	subi	r24, 0x01	; 1
    2432:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    2434:	9e 89       	ldd	r25, Y+22	; 0x16
    2436:	80 91 ed 03 	lds	r24, 0x03ED
    243a:	89 17       	cp	r24, r25
    243c:	10 f4       	brcc	.+4      	; 0x2442 <xTaskGenericNotifyFromISR+0x126>
    243e:	90 93 ed 03 	sts	0x03ED, r25
    2442:	89 2f       	mov	r24, r25
    2444:	90 e0       	ldi	r25, 0x00	; 0
    2446:	fc 01       	movw	r30, r24
    2448:	a3 e0       	ldi	r26, 0x03	; 3
    244a:	ee 0f       	add	r30, r30
    244c:	ff 1f       	adc	r31, r31
    244e:	aa 95       	dec	r26
    2450:	e1 f7       	brne	.-8      	; 0x244a <xTaskGenericNotifyFromISR+0x12e>
    2452:	e8 0f       	add	r30, r24
    2454:	f9 1f       	adc	r31, r25
    2456:	e4 50       	subi	r30, 0x04	; 4
    2458:	fc 4f       	sbci	r31, 0xFC	; 252
    245a:	a1 81       	ldd	r26, Z+1	; 0x01
    245c:	b2 81       	ldd	r27, Z+2	; 0x02
    245e:	bd 83       	std	Y+5, r27	; 0x05
    2460:	ac 83       	std	Y+4, r26	; 0x04
    2462:	14 96       	adiw	r26, 0x04	; 4
    2464:	8d 91       	ld	r24, X+
    2466:	9c 91       	ld	r25, X
    2468:	15 97       	sbiw	r26, 0x05	; 5
    246a:	9f 83       	std	Y+7, r25	; 0x07
    246c:	8e 83       	std	Y+6, r24	; 0x06
    246e:	14 96       	adiw	r26, 0x04	; 4
    2470:	ed 91       	ld	r30, X+
    2472:	fc 91       	ld	r31, X
    2474:	15 97       	sbiw	r26, 0x05	; 5
    2476:	53 83       	std	Z+3, r21	; 0x03
    2478:	42 83       	std	Z+2, r20	; 0x02
    247a:	15 96       	adiw	r26, 0x05	; 5
    247c:	5c 93       	st	X, r21
    247e:	4e 93       	st	-X, r20
    2480:	14 97       	sbiw	r26, 0x04	; 4
    2482:	ee 89       	ldd	r30, Y+22	; 0x16
    2484:	89 e0       	ldi	r24, 0x09	; 9
    2486:	e8 9f       	mul	r30, r24
    2488:	f0 01       	movw	r30, r0
    248a:	11 24       	eor	r1, r1
    248c:	e4 50       	subi	r30, 0x04	; 4
    248e:	fc 4f       	sbci	r31, 0xFC	; 252
    2490:	fb 87       	std	Y+11, r31	; 0x0b
    2492:	ea 87       	std	Y+10, r30	; 0x0a
    2494:	80 81       	ld	r24, Z
    2496:	8f 5f       	subi	r24, 0xFF	; 255
    2498:	80 83       	st	Z, r24
    249a:	21 c0       	rjmp	.+66     	; 0x24de <xTaskGenericNotifyFromISR+0x1c2>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    249c:	a0 91 40 04 	lds	r26, 0x0440
    24a0:	b0 91 41 04 	lds	r27, 0x0441
    24a4:	bf 87       	std	Y+15, r27	; 0x0f
    24a6:	ae 87       	std	Y+14, r26	; 0x0e
    24a8:	14 96       	adiw	r26, 0x04	; 4
    24aa:	8d 91       	ld	r24, X+
    24ac:	9c 91       	ld	r25, X
    24ae:	15 97       	sbiw	r26, 0x05	; 5
    24b0:	99 8b       	std	Y+17, r25	; 0x11
    24b2:	88 8b       	std	Y+16, r24	; 0x10
    24b4:	ce 01       	movw	r24, r28
    24b6:	0c 96       	adiw	r24, 0x0c	; 12
    24b8:	14 96       	adiw	r26, 0x04	; 4
    24ba:	ed 91       	ld	r30, X+
    24bc:	fc 91       	ld	r31, X
    24be:	15 97       	sbiw	r26, 0x05	; 5
    24c0:	93 83       	std	Z+3, r25	; 0x03
    24c2:	82 83       	std	Z+2, r24	; 0x02
    24c4:	15 96       	adiw	r26, 0x05	; 5
    24c6:	9c 93       	st	X, r25
    24c8:	8e 93       	st	-X, r24
    24ca:	14 97       	sbiw	r26, 0x04	; 4
    24cc:	8f e3       	ldi	r24, 0x3F	; 63
    24ce:	94 e0       	ldi	r25, 0x04	; 4
    24d0:	9d 8b       	std	Y+21, r25	; 0x15
    24d2:	8c 8b       	std	Y+20, r24	; 0x14
    24d4:	80 91 3f 04 	lds	r24, 0x043F
    24d8:	8f 5f       	subi	r24, 0xFF	; 255
    24da:	80 93 3f 04 	sts	0x043F, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    24de:	e0 91 ea 03 	lds	r30, 0x03EA
    24e2:	f0 91 eb 03 	lds	r31, 0x03EB
    24e6:	9e 89       	ldd	r25, Y+22	; 0x16
    24e8:	86 89       	ldd	r24, Z+22	; 0x16
    24ea:	89 17       	cp	r24, r25
    24ec:	50 f4       	brcc	.+20     	; 0x2502 <xTaskGenericNotifyFromISR+0x1e6>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    24ee:	c1 14       	cp	r12, r1
    24f0:	d1 04       	cpc	r13, r1
    24f2:	19 f0       	breq	.+6      	; 0x24fa <xTaskGenericNotifyFromISR+0x1de>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    24f4:	81 e0       	ldi	r24, 0x01	; 1
    24f6:	f6 01       	movw	r30, r12
    24f8:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    24fa:	81 e0       	ldi	r24, 0x01	; 1
    24fc:	80 93 ee 03 	sts	0x03EE, r24
    2500:	01 c0       	rjmp	.+2      	; 0x2504 <xTaskGenericNotifyFromISR+0x1e8>
    2502:	81 e0       	ldi	r24, 0x01	; 1
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }
    2504:	df 91       	pop	r29
    2506:	cf 91       	pop	r28
    2508:	0f 91       	pop	r16
    250a:	ff 90       	pop	r15
    250c:	ef 90       	pop	r14
    250e:	df 90       	pop	r13
    2510:	cf 90       	pop	r12
    2512:	08 95       	ret

00002514 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    2514:	cf 93       	push	r28
    2516:	df 93       	push	r29
    2518:	ec 01       	movw	r28, r24
    251a:	e6 2f       	mov	r30, r22
    251c:	ba 01       	movw	r22, r20

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    251e:	f0 e0       	ldi	r31, 0x00	; 0
    2520:	dc 01       	movw	r26, r24
    2522:	ae 0f       	add	r26, r30
    2524:	bf 1f       	adc	r27, r31
    2526:	95 96       	adiw	r26, 0x25	; 37
    2528:	2c 91       	ld	r18, X
    252a:	95 97       	sbiw	r26, 0x25	; 37
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    252c:	82 e0       	ldi	r24, 0x02	; 2
    252e:	95 96       	adiw	r26, 0x25	; 37
    2530:	8c 93       	st	X, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    2532:	ee 0f       	add	r30, r30
    2534:	ff 1f       	adc	r31, r31
    2536:	ee 0f       	add	r30, r30
    2538:	ff 1f       	adc	r31, r31
    253a:	ec 0f       	add	r30, r28
    253c:	fd 1f       	adc	r31, r29
    253e:	81 a1       	ldd	r24, Z+33	; 0x21
    2540:	92 a1       	ldd	r25, Z+34	; 0x22
    2542:	a3 a1       	ldd	r26, Z+35	; 0x23
    2544:	b4 a1       	ldd	r27, Z+36	; 0x24
    2546:	01 96       	adiw	r24, 0x01	; 1
    2548:	a1 1d       	adc	r26, r1
    254a:	b1 1d       	adc	r27, r1
    254c:	81 a3       	std	Z+33, r24	; 0x21
    254e:	92 a3       	std	Z+34, r25	; 0x22
    2550:	a3 a3       	std	Z+35, r26	; 0x23
    2552:	b4 a3       	std	Z+36, r27	; 0x24

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2554:	21 30       	cpi	r18, 0x01	; 1
    2556:	09 f0       	breq	.+2      	; 0x255a <vTaskGenericNotifyGiveFromISR+0x46>
    2558:	8c c0       	rjmp	.+280    	; 0x2672 <vTaskGenericNotifyGiveFromISR+0x15e>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    255a:	80 91 ec 03 	lds	r24, 0x03EC
    255e:	88 23       	and	r24, r24
    2560:	09 f0       	breq	.+2      	; 0x2564 <vTaskGenericNotifyGiveFromISR+0x50>
    2562:	55 c0       	rjmp	.+170    	; 0x260e <vTaskGenericNotifyGiveFromISR+0xfa>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    2564:	aa 85       	ldd	r26, Y+10	; 0x0a
    2566:	bb 85       	ldd	r27, Y+11	; 0x0b
    2568:	4c 81       	ldd	r20, Y+4	; 0x04
    256a:	5d 81       	ldd	r21, Y+5	; 0x05
    256c:	8e 81       	ldd	r24, Y+6	; 0x06
    256e:	9f 81       	ldd	r25, Y+7	; 0x07
    2570:	fa 01       	movw	r30, r20
    2572:	95 83       	std	Z+5, r25	; 0x05
    2574:	84 83       	std	Z+4, r24	; 0x04
    2576:	2e 81       	ldd	r18, Y+6	; 0x06
    2578:	3f 81       	ldd	r19, Y+7	; 0x07
    257a:	f9 01       	movw	r30, r18
    257c:	53 83       	std	Z+3, r21	; 0x03
    257e:	42 83       	std	Z+2, r20	; 0x02
    2580:	ae 01       	movw	r20, r28
    2582:	4e 5f       	subi	r20, 0xFE	; 254
    2584:	5f 4f       	sbci	r21, 0xFF	; 255
    2586:	11 96       	adiw	r26, 0x01	; 1
    2588:	8d 91       	ld	r24, X+
    258a:	9c 91       	ld	r25, X
    258c:	12 97       	sbiw	r26, 0x02	; 2
    258e:	84 17       	cp	r24, r20
    2590:	95 07       	cpc	r25, r21
    2592:	21 f4       	brne	.+8      	; 0x259c <vTaskGenericNotifyGiveFromISR+0x88>
    2594:	12 96       	adiw	r26, 0x02	; 2
    2596:	3c 93       	st	X, r19
    2598:	2e 93       	st	-X, r18
    259a:	11 97       	sbiw	r26, 0x01	; 1
    259c:	1b 86       	std	Y+11, r1	; 0x0b
    259e:	1a 86       	std	Y+10, r1	; 0x0a
    25a0:	8c 91       	ld	r24, X
    25a2:	81 50       	subi	r24, 0x01	; 1
    25a4:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    25a6:	9e 89       	ldd	r25, Y+22	; 0x16
    25a8:	80 91 ed 03 	lds	r24, 0x03ED
    25ac:	89 17       	cp	r24, r25
    25ae:	10 f4       	brcc	.+4      	; 0x25b4 <vTaskGenericNotifyGiveFromISR+0xa0>
    25b0:	90 93 ed 03 	sts	0x03ED, r25
    25b4:	89 2f       	mov	r24, r25
    25b6:	90 e0       	ldi	r25, 0x00	; 0
    25b8:	fc 01       	movw	r30, r24
    25ba:	a3 e0       	ldi	r26, 0x03	; 3
    25bc:	ee 0f       	add	r30, r30
    25be:	ff 1f       	adc	r31, r31
    25c0:	aa 95       	dec	r26
    25c2:	e1 f7       	brne	.-8      	; 0x25bc <vTaskGenericNotifyGiveFromISR+0xa8>
    25c4:	e8 0f       	add	r30, r24
    25c6:	f9 1f       	adc	r31, r25
    25c8:	e4 50       	subi	r30, 0x04	; 4
    25ca:	fc 4f       	sbci	r31, 0xFC	; 252
    25cc:	a1 81       	ldd	r26, Z+1	; 0x01
    25ce:	b2 81       	ldd	r27, Z+2	; 0x02
    25d0:	bd 83       	std	Y+5, r27	; 0x05
    25d2:	ac 83       	std	Y+4, r26	; 0x04
    25d4:	14 96       	adiw	r26, 0x04	; 4
    25d6:	8d 91       	ld	r24, X+
    25d8:	9c 91       	ld	r25, X
    25da:	15 97       	sbiw	r26, 0x05	; 5
    25dc:	9f 83       	std	Y+7, r25	; 0x07
    25de:	8e 83       	std	Y+6, r24	; 0x06
    25e0:	14 96       	adiw	r26, 0x04	; 4
    25e2:	ed 91       	ld	r30, X+
    25e4:	fc 91       	ld	r31, X
    25e6:	15 97       	sbiw	r26, 0x05	; 5
    25e8:	53 83       	std	Z+3, r21	; 0x03
    25ea:	42 83       	std	Z+2, r20	; 0x02
    25ec:	15 96       	adiw	r26, 0x05	; 5
    25ee:	5c 93       	st	X, r21
    25f0:	4e 93       	st	-X, r20
    25f2:	14 97       	sbiw	r26, 0x04	; 4
    25f4:	ee 89       	ldd	r30, Y+22	; 0x16
    25f6:	89 e0       	ldi	r24, 0x09	; 9
    25f8:	e8 9f       	mul	r30, r24
    25fa:	f0 01       	movw	r30, r0
    25fc:	11 24       	eor	r1, r1
    25fe:	e4 50       	subi	r30, 0x04	; 4
    2600:	fc 4f       	sbci	r31, 0xFC	; 252
    2602:	fb 87       	std	Y+11, r31	; 0x0b
    2604:	ea 87       	std	Y+10, r30	; 0x0a
    2606:	80 81       	ld	r24, Z
    2608:	8f 5f       	subi	r24, 0xFF	; 255
    260a:	80 83       	st	Z, r24
    260c:	21 c0       	rjmp	.+66     	; 0x2650 <vTaskGenericNotifyGiveFromISR+0x13c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    260e:	a0 91 40 04 	lds	r26, 0x0440
    2612:	b0 91 41 04 	lds	r27, 0x0441
    2616:	bf 87       	std	Y+15, r27	; 0x0f
    2618:	ae 87       	std	Y+14, r26	; 0x0e
    261a:	14 96       	adiw	r26, 0x04	; 4
    261c:	8d 91       	ld	r24, X+
    261e:	9c 91       	ld	r25, X
    2620:	15 97       	sbiw	r26, 0x05	; 5
    2622:	99 8b       	std	Y+17, r25	; 0x11
    2624:	88 8b       	std	Y+16, r24	; 0x10
    2626:	ce 01       	movw	r24, r28
    2628:	0c 96       	adiw	r24, 0x0c	; 12
    262a:	14 96       	adiw	r26, 0x04	; 4
    262c:	ed 91       	ld	r30, X+
    262e:	fc 91       	ld	r31, X
    2630:	15 97       	sbiw	r26, 0x05	; 5
    2632:	93 83       	std	Z+3, r25	; 0x03
    2634:	82 83       	std	Z+2, r24	; 0x02
    2636:	15 96       	adiw	r26, 0x05	; 5
    2638:	9c 93       	st	X, r25
    263a:	8e 93       	st	-X, r24
    263c:	14 97       	sbiw	r26, 0x04	; 4
    263e:	8f e3       	ldi	r24, 0x3F	; 63
    2640:	94 e0       	ldi	r25, 0x04	; 4
    2642:	9d 8b       	std	Y+21, r25	; 0x15
    2644:	8c 8b       	std	Y+20, r24	; 0x14
    2646:	80 91 3f 04 	lds	r24, 0x043F
    264a:	8f 5f       	subi	r24, 0xFF	; 255
    264c:	80 93 3f 04 	sts	0x043F, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2650:	e0 91 ea 03 	lds	r30, 0x03EA
    2654:	f0 91 eb 03 	lds	r31, 0x03EB
    2658:	9e 89       	ldd	r25, Y+22	; 0x16
    265a:	86 89       	ldd	r24, Z+22	; 0x16
    265c:	89 17       	cp	r24, r25
    265e:	48 f4       	brcc	.+18     	; 0x2672 <vTaskGenericNotifyGiveFromISR+0x15e>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    2660:	61 15       	cp	r22, r1
    2662:	71 05       	cpc	r23, r1
    2664:	19 f0       	breq	.+6      	; 0x266c <vTaskGenericNotifyGiveFromISR+0x158>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    2666:	81 e0       	ldi	r24, 0x01	; 1
    2668:	fb 01       	movw	r30, r22
    266a:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    266c:	81 e0       	ldi	r24, 0x01	; 1
    266e:	80 93 ee 03 	sts	0x03EE, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    2672:	df 91       	pop	r29
    2674:	cf 91       	pop	r28
    2676:	08 95       	ret

00002678 <xTaskGenericNotifyStateClear>:

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    2678:	00 97       	sbiw	r24, 0x00	; 0
    267a:	21 f4       	brne	.+8      	; 0x2684 <xTaskGenericNotifyStateClear+0xc>
    267c:	80 91 ea 03 	lds	r24, 0x03EA
    2680:	90 91 eb 03 	lds	r25, 0x03EB

        taskENTER_CRITICAL();
    2684:	0f b6       	in	r0, 0x3f	; 63
    2686:	f8 94       	cli
    2688:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    268a:	fc 01       	movw	r30, r24
    268c:	e6 0f       	add	r30, r22
    268e:	f1 1d       	adc	r31, r1
    2690:	85 a1       	ldd	r24, Z+37	; 0x25
    2692:	82 30       	cpi	r24, 0x02	; 2
    2694:	11 f0       	breq	.+4      	; 0x269a <xTaskGenericNotifyStateClear+0x22>
    2696:	80 e0       	ldi	r24, 0x00	; 0
    2698:	02 c0       	rjmp	.+4      	; 0x269e <xTaskGenericNotifyStateClear+0x26>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    269a:	15 a2       	std	Z+37, r1	; 0x25
    269c:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();
    269e:	0f 90       	pop	r0
    26a0:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    26a2:	08 95       	ret

000026a4 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    26a4:	ef 92       	push	r14
    26a6:	ff 92       	push	r15
    26a8:	0f 93       	push	r16
    26aa:	1f 93       	push	r17
    26ac:	79 01       	movw	r14, r18
    26ae:	8a 01       	movw	r16, r20
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    26b0:	00 97       	sbiw	r24, 0x00	; 0
    26b2:	21 f4       	brne	.+8      	; 0x26bc <ulTaskGenericNotifyValueClear+0x18>
    26b4:	80 91 ea 03 	lds	r24, 0x03EA
    26b8:	90 91 eb 03 	lds	r25, 0x03EB

        taskENTER_CRITICAL();
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    26c2:	e6 2f       	mov	r30, r22
    26c4:	f0 e0       	ldi	r31, 0x00	; 0
    26c6:	ee 0f       	add	r30, r30
    26c8:	ff 1f       	adc	r31, r31
    26ca:	ee 0f       	add	r30, r30
    26cc:	ff 1f       	adc	r31, r31
    26ce:	e8 0f       	add	r30, r24
    26d0:	f9 1f       	adc	r31, r25
    26d2:	21 a1       	ldd	r18, Z+33	; 0x21
    26d4:	32 a1       	ldd	r19, Z+34	; 0x22
    26d6:	43 a1       	ldd	r20, Z+35	; 0x23
    26d8:	54 a1       	ldd	r21, Z+36	; 0x24
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    26da:	81 a1       	ldd	r24, Z+33	; 0x21
    26dc:	92 a1       	ldd	r25, Z+34	; 0x22
    26de:	a3 a1       	ldd	r26, Z+35	; 0x23
    26e0:	b4 a1       	ldd	r27, Z+36	; 0x24
    26e2:	e0 94       	com	r14
    26e4:	f0 94       	com	r15
    26e6:	00 95       	com	r16
    26e8:	10 95       	com	r17
    26ea:	8e 21       	and	r24, r14
    26ec:	9f 21       	and	r25, r15
    26ee:	a0 23       	and	r26, r16
    26f0:	b1 23       	and	r27, r17
    26f2:	81 a3       	std	Z+33, r24	; 0x21
    26f4:	92 a3       	std	Z+34, r25	; 0x22
    26f6:	a3 a3       	std	Z+35, r26	; 0x23
    26f8:	b4 a3       	std	Z+36, r27	; 0x24
        }
        taskEXIT_CRITICAL();
    26fa:	0f 90       	pop	r0
    26fc:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    26fe:	b9 01       	movw	r22, r18
    2700:	ca 01       	movw	r24, r20
    2702:	1f 91       	pop	r17
    2704:	0f 91       	pop	r16
    2706:	ff 90       	pop	r15
    2708:	ef 90       	pop	r14
    270a:	08 95       	ret

0000270c <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    270c:	ef 92       	push	r14
    270e:	ff 92       	push	r15
    2710:	0f 93       	push	r16
    2712:	cf 93       	push	r28
    2714:	df 93       	push	r29
    2716:	ec 01       	movw	r28, r24

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
    2718:	0f b6       	in	r0, 0x3f	; 63
    271a:	f8 94       	cli
    271c:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    271e:	e1 14       	cp	r14, r1
    2720:	f1 04       	cpc	r15, r1
    2722:	89 f0       	breq	.+34     	; 0x2746 <xTaskGenericNotify+0x3a>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    2724:	e6 2f       	mov	r30, r22
    2726:	f0 e0       	ldi	r31, 0x00	; 0
    2728:	ee 0f       	add	r30, r30
    272a:	ff 1f       	adc	r31, r31
    272c:	ee 0f       	add	r30, r30
    272e:	ff 1f       	adc	r31, r31
    2730:	ec 0f       	add	r30, r28
    2732:	fd 1f       	adc	r31, r29
    2734:	81 a1       	ldd	r24, Z+33	; 0x21
    2736:	92 a1       	ldd	r25, Z+34	; 0x22
    2738:	a3 a1       	ldd	r26, Z+35	; 0x23
    273a:	b4 a1       	ldd	r27, Z+36	; 0x24
    273c:	f7 01       	movw	r30, r14
    273e:	80 83       	st	Z, r24
    2740:	91 83       	std	Z+1, r25	; 0x01
    2742:	a2 83       	std	Z+2, r26	; 0x02
    2744:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    2746:	a6 2f       	mov	r26, r22
    2748:	b0 e0       	ldi	r27, 0x00	; 0
    274a:	fe 01       	movw	r30, r28
    274c:	ea 0f       	add	r30, r26
    274e:	fb 1f       	adc	r31, r27
    2750:	65 a1       	ldd	r22, Z+37	; 0x25

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    2752:	82 e0       	ldi	r24, 0x02	; 2
    2754:	85 a3       	std	Z+37, r24	; 0x25

            switch( eAction )
    2756:	02 30       	cpi	r16, 0x02	; 2
    2758:	d1 f0       	breq	.+52     	; 0x278e <xTaskGenericNotify+0x82>
    275a:	03 30       	cpi	r16, 0x03	; 3
    275c:	18 f4       	brcc	.+6      	; 0x2764 <xTaskGenericNotify+0x58>
    275e:	01 30       	cpi	r16, 0x01	; 1
    2760:	c9 f5       	brne	.+114    	; 0x27d4 <xTaskGenericNotify+0xc8>
    2762:	05 c0       	rjmp	.+10     	; 0x276e <xTaskGenericNotify+0x62>
    2764:	03 30       	cpi	r16, 0x03	; 3
    2766:	51 f1       	breq	.+84     	; 0x27bc <xTaskGenericNotify+0xb0>
    2768:	04 30       	cpi	r16, 0x04	; 4
    276a:	a1 f5       	brne	.+104    	; 0x27d4 <xTaskGenericNotify+0xc8>
    276c:	23 c0       	rjmp	.+70     	; 0x27b4 <xTaskGenericNotify+0xa8>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    276e:	fd 01       	movw	r30, r26
    2770:	ee 0f       	add	r30, r30
    2772:	ff 1f       	adc	r31, r31
    2774:	ee 0f       	add	r30, r30
    2776:	ff 1f       	adc	r31, r31
    2778:	ec 0f       	add	r30, r28
    277a:	fd 1f       	adc	r31, r29
    277c:	81 a1       	ldd	r24, Z+33	; 0x21
    277e:	92 a1       	ldd	r25, Z+34	; 0x22
    2780:	a3 a1       	ldd	r26, Z+35	; 0x23
    2782:	b4 a1       	ldd	r27, Z+36	; 0x24
    2784:	82 2b       	or	r24, r18
    2786:	93 2b       	or	r25, r19
    2788:	a4 2b       	or	r26, r20
    278a:	b5 2b       	or	r27, r21
    278c:	0e c0       	rjmp	.+28     	; 0x27aa <xTaskGenericNotify+0x9e>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    278e:	fd 01       	movw	r30, r26
    2790:	ee 0f       	add	r30, r30
    2792:	ff 1f       	adc	r31, r31
    2794:	ee 0f       	add	r30, r30
    2796:	ff 1f       	adc	r31, r31
    2798:	ec 0f       	add	r30, r28
    279a:	fd 1f       	adc	r31, r29
    279c:	81 a1       	ldd	r24, Z+33	; 0x21
    279e:	92 a1       	ldd	r25, Z+34	; 0x22
    27a0:	a3 a1       	ldd	r26, Z+35	; 0x23
    27a2:	b4 a1       	ldd	r27, Z+36	; 0x24
    27a4:	01 96       	adiw	r24, 0x01	; 1
    27a6:	a1 1d       	adc	r26, r1
    27a8:	b1 1d       	adc	r27, r1
    27aa:	81 a3       	std	Z+33, r24	; 0x21
    27ac:	92 a3       	std	Z+34, r25	; 0x22
    27ae:	a3 a3       	std	Z+35, r26	; 0x23
    27b0:	b4 a3       	std	Z+36, r27	; 0x24
    27b2:	10 c0       	rjmp	.+32     	; 0x27d4 <xTaskGenericNotify+0xc8>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    27b4:	62 30       	cpi	r22, 0x02	; 2
    27b6:	11 f4       	brne	.+4      	; 0x27bc <xTaskGenericNotify+0xb0>
    27b8:	80 e0       	ldi	r24, 0x00	; 0
    27ba:	6e c0       	rjmp	.+220    	; 0x2898 <xTaskGenericNotify+0x18c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    27bc:	aa 0f       	add	r26, r26
    27be:	bb 1f       	adc	r27, r27
    27c0:	aa 0f       	add	r26, r26
    27c2:	bb 1f       	adc	r27, r27
    27c4:	ac 0f       	add	r26, r28
    27c6:	bd 1f       	adc	r27, r29
    27c8:	91 96       	adiw	r26, 0x21	; 33
    27ca:	2d 93       	st	X+, r18
    27cc:	3d 93       	st	X+, r19
    27ce:	4d 93       	st	X+, r20
    27d0:	5c 93       	st	X, r21
    27d2:	94 97       	sbiw	r26, 0x24	; 36

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    27d4:	61 30       	cpi	r22, 0x01	; 1
    27d6:	09 f0       	breq	.+2      	; 0x27da <xTaskGenericNotify+0xce>
    27d8:	5e c0       	rjmp	.+188    	; 0x2896 <xTaskGenericNotify+0x18a>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    27da:	aa 85       	ldd	r26, Y+10	; 0x0a
    27dc:	bb 85       	ldd	r27, Y+11	; 0x0b
    27de:	4c 81       	ldd	r20, Y+4	; 0x04
    27e0:	5d 81       	ldd	r21, Y+5	; 0x05
    27e2:	8e 81       	ldd	r24, Y+6	; 0x06
    27e4:	9f 81       	ldd	r25, Y+7	; 0x07
    27e6:	fa 01       	movw	r30, r20
    27e8:	95 83       	std	Z+5, r25	; 0x05
    27ea:	84 83       	std	Z+4, r24	; 0x04
    27ec:	2e 81       	ldd	r18, Y+6	; 0x06
    27ee:	3f 81       	ldd	r19, Y+7	; 0x07
    27f0:	f9 01       	movw	r30, r18
    27f2:	53 83       	std	Z+3, r21	; 0x03
    27f4:	42 83       	std	Z+2, r20	; 0x02
    27f6:	ae 01       	movw	r20, r28
    27f8:	4e 5f       	subi	r20, 0xFE	; 254
    27fa:	5f 4f       	sbci	r21, 0xFF	; 255
    27fc:	11 96       	adiw	r26, 0x01	; 1
    27fe:	8d 91       	ld	r24, X+
    2800:	9c 91       	ld	r25, X
    2802:	12 97       	sbiw	r26, 0x02	; 2
    2804:	84 17       	cp	r24, r20
    2806:	95 07       	cpc	r25, r21
    2808:	21 f4       	brne	.+8      	; 0x2812 <xTaskGenericNotify+0x106>
    280a:	12 96       	adiw	r26, 0x02	; 2
    280c:	3c 93       	st	X, r19
    280e:	2e 93       	st	-X, r18
    2810:	11 97       	sbiw	r26, 0x01	; 1
    2812:	1b 86       	std	Y+11, r1	; 0x0b
    2814:	1a 86       	std	Y+10, r1	; 0x0a
    2816:	8c 91       	ld	r24, X
    2818:	81 50       	subi	r24, 0x01	; 1
    281a:	8c 93       	st	X, r24
                prvAddTaskToReadyList( pxTCB );
    281c:	9e 89       	ldd	r25, Y+22	; 0x16
    281e:	80 91 ed 03 	lds	r24, 0x03ED
    2822:	89 17       	cp	r24, r25
    2824:	10 f4       	brcc	.+4      	; 0x282a <xTaskGenericNotify+0x11e>
    2826:	90 93 ed 03 	sts	0x03ED, r25
    282a:	89 2f       	mov	r24, r25
    282c:	90 e0       	ldi	r25, 0x00	; 0
    282e:	fc 01       	movw	r30, r24
    2830:	33 e0       	ldi	r19, 0x03	; 3
    2832:	ee 0f       	add	r30, r30
    2834:	ff 1f       	adc	r31, r31
    2836:	3a 95       	dec	r19
    2838:	e1 f7       	brne	.-8      	; 0x2832 <xTaskGenericNotify+0x126>
    283a:	e8 0f       	add	r30, r24
    283c:	f9 1f       	adc	r31, r25
    283e:	e4 50       	subi	r30, 0x04	; 4
    2840:	fc 4f       	sbci	r31, 0xFC	; 252
    2842:	a1 81       	ldd	r26, Z+1	; 0x01
    2844:	b2 81       	ldd	r27, Z+2	; 0x02
    2846:	bd 83       	std	Y+5, r27	; 0x05
    2848:	ac 83       	std	Y+4, r26	; 0x04
    284a:	14 96       	adiw	r26, 0x04	; 4
    284c:	8d 91       	ld	r24, X+
    284e:	9c 91       	ld	r25, X
    2850:	15 97       	sbiw	r26, 0x05	; 5
    2852:	9f 83       	std	Y+7, r25	; 0x07
    2854:	8e 83       	std	Y+6, r24	; 0x06
    2856:	14 96       	adiw	r26, 0x04	; 4
    2858:	ed 91       	ld	r30, X+
    285a:	fc 91       	ld	r31, X
    285c:	15 97       	sbiw	r26, 0x05	; 5
    285e:	53 83       	std	Z+3, r21	; 0x03
    2860:	42 83       	std	Z+2, r20	; 0x02
    2862:	15 96       	adiw	r26, 0x05	; 5
    2864:	5c 93       	st	X, r21
    2866:	4e 93       	st	-X, r20
    2868:	14 97       	sbiw	r26, 0x04	; 4
    286a:	ee 89       	ldd	r30, Y+22	; 0x16
    286c:	89 e0       	ldi	r24, 0x09	; 9
    286e:	e8 9f       	mul	r30, r24
    2870:	f0 01       	movw	r30, r0
    2872:	11 24       	eor	r1, r1
    2874:	e4 50       	subi	r30, 0x04	; 4
    2876:	fc 4f       	sbci	r31, 0xFC	; 252
    2878:	fb 87       	std	Y+11, r31	; 0x0b
    287a:	ea 87       	std	Y+10, r30	; 0x0a
    287c:	80 81       	ld	r24, Z
    287e:	8f 5f       	subi	r24, 0xFF	; 255
    2880:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2882:	e0 91 ea 03 	lds	r30, 0x03EA
    2886:	f0 91 eb 03 	lds	r31, 0x03EB
    288a:	9e 89       	ldd	r25, Y+22	; 0x16
    288c:	86 89       	ldd	r24, Z+22	; 0x16
    288e:	89 17       	cp	r24, r25
    2890:	10 f4       	brcc	.+4      	; 0x2896 <xTaskGenericNotify+0x18a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    2892:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    2896:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2898:	0f 90       	pop	r0
    289a:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    289c:	df 91       	pop	r29
    289e:	cf 91       	pop	r28
    28a0:	0f 91       	pop	r16
    28a2:	ff 90       	pop	r15
    28a4:	ef 90       	pop	r14
    28a6:	08 95       	ret

000028a8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    28a8:	1f 93       	push	r17
    28aa:	cf 93       	push	r28
    28ac:	df 93       	push	r29
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    28ae:	0f b6       	in	r0, 0x3f	; 63
    28b0:	f8 94       	cli
    28b2:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    28b4:	80 91 ec 03 	lds	r24, 0x03EC
    28b8:	81 50       	subi	r24, 0x01	; 1
    28ba:	80 93 ec 03 	sts	0x03EC, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    28be:	80 91 ec 03 	lds	r24, 0x03EC
    28c2:	88 23       	and	r24, r24
    28c4:	09 f0       	breq	.+2      	; 0x28c8 <xTaskResumeAll+0x20>
    28c6:	c7 c0       	rjmp	.+398    	; 0x2a56 <xTaskResumeAll+0x1ae>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    28c8:	80 91 f6 03 	lds	r24, 0x03F6
    28cc:	88 23       	and	r24, r24
    28ce:	09 f4       	brne	.+2      	; 0x28d2 <xTaskResumeAll+0x2a>
    28d0:	c2 c0       	rjmp	.+388    	; 0x2a56 <xTaskResumeAll+0x1ae>
    28d2:	c0 e0       	ldi	r28, 0x00	; 0
    28d4:	d0 e0       	ldi	r29, 0x00	; 0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    28d6:	79 e0       	ldi	r23, 0x09	; 9

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    28d8:	61 e0       	ldi	r22, 0x01	; 1
    28da:	84 c0       	rjmp	.+264    	; 0x29e4 <xTaskResumeAll+0x13c>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    28dc:	e0 91 44 04 	lds	r30, 0x0444
    28e0:	f0 91 45 04 	lds	r31, 0x0445
    28e4:	c6 81       	ldd	r28, Z+6	; 0x06
    28e6:	d7 81       	ldd	r29, Z+7	; 0x07
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    28e8:	ac 89       	ldd	r26, Y+20	; 0x14
    28ea:	bd 89       	ldd	r27, Y+21	; 0x15
    28ec:	2e 85       	ldd	r18, Y+14	; 0x0e
    28ee:	3f 85       	ldd	r19, Y+15	; 0x0f
    28f0:	88 89       	ldd	r24, Y+16	; 0x10
    28f2:	99 89       	ldd	r25, Y+17	; 0x11
    28f4:	f9 01       	movw	r30, r18
    28f6:	95 83       	std	Z+5, r25	; 0x05
    28f8:	84 83       	std	Z+4, r24	; 0x04
    28fa:	48 89       	ldd	r20, Y+16	; 0x10
    28fc:	59 89       	ldd	r21, Y+17	; 0x11
    28fe:	fa 01       	movw	r30, r20
    2900:	33 83       	std	Z+3, r19	; 0x03
    2902:	22 83       	std	Z+2, r18	; 0x02
    2904:	9e 01       	movw	r18, r28
    2906:	24 5f       	subi	r18, 0xF4	; 244
    2908:	3f 4f       	sbci	r19, 0xFF	; 255
    290a:	11 96       	adiw	r26, 0x01	; 1
    290c:	8d 91       	ld	r24, X+
    290e:	9c 91       	ld	r25, X
    2910:	12 97       	sbiw	r26, 0x02	; 2
    2912:	82 17       	cp	r24, r18
    2914:	93 07       	cpc	r25, r19
    2916:	21 f4       	brne	.+8      	; 0x2920 <xTaskResumeAll+0x78>
    2918:	12 96       	adiw	r26, 0x02	; 2
    291a:	5c 93       	st	X, r21
    291c:	4e 93       	st	-X, r20
    291e:	11 97       	sbiw	r26, 0x01	; 1
    2920:	1d 8a       	std	Y+21, r1	; 0x15
    2922:	1c 8a       	std	Y+20, r1	; 0x14
    2924:	8c 91       	ld	r24, X
    2926:	81 50       	subi	r24, 0x01	; 1
    2928:	8c 93       	st	X, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    292a:	aa 85       	ldd	r26, Y+10	; 0x0a
    292c:	bb 85       	ldd	r27, Y+11	; 0x0b
    292e:	4c 81       	ldd	r20, Y+4	; 0x04
    2930:	5d 81       	ldd	r21, Y+5	; 0x05
    2932:	8e 81       	ldd	r24, Y+6	; 0x06
    2934:	9f 81       	ldd	r25, Y+7	; 0x07
    2936:	fa 01       	movw	r30, r20
    2938:	95 83       	std	Z+5, r25	; 0x05
    293a:	84 83       	std	Z+4, r24	; 0x04
    293c:	2e 81       	ldd	r18, Y+6	; 0x06
    293e:	3f 81       	ldd	r19, Y+7	; 0x07
    2940:	f9 01       	movw	r30, r18
    2942:	53 83       	std	Z+3, r21	; 0x03
    2944:	42 83       	std	Z+2, r20	; 0x02
    2946:	ae 01       	movw	r20, r28
    2948:	4e 5f       	subi	r20, 0xFE	; 254
    294a:	5f 4f       	sbci	r21, 0xFF	; 255
    294c:	11 96       	adiw	r26, 0x01	; 1
    294e:	8d 91       	ld	r24, X+
    2950:	9c 91       	ld	r25, X
    2952:	12 97       	sbiw	r26, 0x02	; 2
    2954:	84 17       	cp	r24, r20
    2956:	95 07       	cpc	r25, r21
    2958:	21 f4       	brne	.+8      	; 0x2962 <xTaskResumeAll+0xba>
    295a:	12 96       	adiw	r26, 0x02	; 2
    295c:	3c 93       	st	X, r19
    295e:	2e 93       	st	-X, r18
    2960:	11 97       	sbiw	r26, 0x01	; 1
    2962:	1b 86       	std	Y+11, r1	; 0x0b
    2964:	1a 86       	std	Y+10, r1	; 0x0a
    2966:	8c 91       	ld	r24, X
    2968:	81 50       	subi	r24, 0x01	; 1
    296a:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    296c:	9e 89       	ldd	r25, Y+22	; 0x16
    296e:	80 91 ed 03 	lds	r24, 0x03ED
    2972:	89 17       	cp	r24, r25
    2974:	10 f4       	brcc	.+4      	; 0x297a <xTaskResumeAll+0xd2>
    2976:	90 93 ed 03 	sts	0x03ED, r25
    297a:	89 2f       	mov	r24, r25
    297c:	90 e0       	ldi	r25, 0x00	; 0
    297e:	fc 01       	movw	r30, r24
    2980:	23 e0       	ldi	r18, 0x03	; 3
    2982:	ee 0f       	add	r30, r30
    2984:	ff 1f       	adc	r31, r31
    2986:	2a 95       	dec	r18
    2988:	e1 f7       	brne	.-8      	; 0x2982 <xTaskResumeAll+0xda>
    298a:	e8 0f       	add	r30, r24
    298c:	f9 1f       	adc	r31, r25
    298e:	e4 50       	subi	r30, 0x04	; 4
    2990:	fc 4f       	sbci	r31, 0xFC	; 252
    2992:	a1 81       	ldd	r26, Z+1	; 0x01
    2994:	b2 81       	ldd	r27, Z+2	; 0x02
    2996:	bd 83       	std	Y+5, r27	; 0x05
    2998:	ac 83       	std	Y+4, r26	; 0x04
    299a:	14 96       	adiw	r26, 0x04	; 4
    299c:	8d 91       	ld	r24, X+
    299e:	9c 91       	ld	r25, X
    29a0:	15 97       	sbiw	r26, 0x05	; 5
    29a2:	9f 83       	std	Y+7, r25	; 0x07
    29a4:	8e 83       	std	Y+6, r24	; 0x06
    29a6:	14 96       	adiw	r26, 0x04	; 4
    29a8:	ed 91       	ld	r30, X+
    29aa:	fc 91       	ld	r31, X
    29ac:	15 97       	sbiw	r26, 0x05	; 5
    29ae:	53 83       	std	Z+3, r21	; 0x03
    29b0:	42 83       	std	Z+2, r20	; 0x02
    29b2:	15 96       	adiw	r26, 0x05	; 5
    29b4:	5c 93       	st	X, r21
    29b6:	4e 93       	st	-X, r20
    29b8:	14 97       	sbiw	r26, 0x04	; 4
    29ba:	ee 89       	ldd	r30, Y+22	; 0x16
    29bc:	e7 9f       	mul	r30, r23
    29be:	f0 01       	movw	r30, r0
    29c0:	11 24       	eor	r1, r1
    29c2:	e4 50       	subi	r30, 0x04	; 4
    29c4:	fc 4f       	sbci	r31, 0xFC	; 252
    29c6:	fb 87       	std	Y+11, r31	; 0x0b
    29c8:	ea 87       	std	Y+10, r30	; 0x0a
    29ca:	80 81       	ld	r24, Z
    29cc:	8f 5f       	subi	r24, 0xFF	; 255
    29ce:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    29d0:	e0 91 ea 03 	lds	r30, 0x03EA
    29d4:	f0 91 eb 03 	lds	r31, 0x03EB
    29d8:	9e 89       	ldd	r25, Y+22	; 0x16
    29da:	86 89       	ldd	r24, Z+22	; 0x16
    29dc:	98 17       	cp	r25, r24
    29de:	10 f0       	brcs	.+4      	; 0x29e4 <xTaskResumeAll+0x13c>
                    {
                        xYieldPending = pdTRUE;
    29e0:	60 93 ee 03 	sts	0x03EE, r22
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    29e4:	80 91 3f 04 	lds	r24, 0x043F
    29e8:	88 23       	and	r24, r24
    29ea:	09 f0       	breq	.+2      	; 0x29ee <xTaskResumeAll+0x146>
    29ec:	77 cf       	rjmp	.-274    	; 0x28dc <xTaskResumeAll+0x34>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    29ee:	cd 2b       	or	r28, r29
    29f0:	b9 f0       	breq	.+46     	; 0x2a20 <xTaskResumeAll+0x178>
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    29f2:	e0 91 3b 04 	lds	r30, 0x043B
    29f6:	f0 91 3c 04 	lds	r31, 0x043C
    29fa:	80 81       	ld	r24, Z
    29fc:	88 23       	and	r24, r24
    29fe:	19 f4       	brne	.+6      	; 0x2a06 <xTaskResumeAll+0x15e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    2a00:	8f ef       	ldi	r24, 0xFF	; 255
    2a02:	9f ef       	ldi	r25, 0xFF	; 255
    2a04:	09 c0       	rjmp	.+18     	; 0x2a18 <xTaskResumeAll+0x170>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    2a06:	e0 91 3b 04 	lds	r30, 0x043B
    2a0a:	f0 91 3c 04 	lds	r31, 0x043C
    2a0e:	05 80       	ldd	r0, Z+5	; 0x05
    2a10:	f6 81       	ldd	r31, Z+6	; 0x06
    2a12:	e0 2d       	mov	r30, r0
    2a14:	80 81       	ld	r24, Z
    2a16:	91 81       	ldd	r25, Z+1	; 0x01
    2a18:	90 93 f2 03 	sts	0x03F2, r25
    2a1c:	80 93 f1 03 	sts	0x03F1, r24
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    2a20:	c0 91 f4 03 	lds	r28, 0x03F4
    2a24:	d0 91 f5 03 	lds	r29, 0x03F5

                    if( xPendedCounts > ( TickType_t ) 0U )
    2a28:	20 97       	sbiw	r28, 0x00	; 0
    2a2a:	69 f0       	breq	.+26     	; 0x2a46 <xTaskResumeAll+0x19e>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    2a2c:	11 e0       	ldi	r17, 0x01	; 1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    2a2e:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <xTaskIncrementTick>
    2a32:	88 23       	and	r24, r24
    2a34:	11 f0       	breq	.+4      	; 0x2a3a <xTaskResumeAll+0x192>
                            {
                                xYieldPending = pdTRUE;
    2a36:	10 93 ee 03 	sts	0x03EE, r17
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    2a3a:	21 97       	sbiw	r28, 0x01	; 1
                        } while( xPendedCounts > ( TickType_t ) 0U );
    2a3c:	c1 f7       	brne	.-16     	; 0x2a2e <xTaskResumeAll+0x186>

                        xPendedTicks = 0;
    2a3e:	10 92 f5 03 	sts	0x03F5, r1
    2a42:	10 92 f4 03 	sts	0x03F4, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    2a46:	80 91 ee 03 	lds	r24, 0x03EE
    2a4a:	88 23       	and	r24, r24
    2a4c:	21 f0       	breq	.+8      	; 0x2a56 <xTaskResumeAll+0x1ae>
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    2a4e:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    2a52:	81 e0       	ldi	r24, 0x01	; 1
    2a54:	01 c0       	rjmp	.+2      	; 0x2a58 <xTaskResumeAll+0x1b0>
    2a56:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    2a58:	0f 90       	pop	r0
    2a5a:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
}
    2a5c:	df 91       	pop	r29
    2a5e:	cf 91       	pop	r28
    2a60:	1f 91       	pop	r17
    2a62:	08 95       	ret

00002a64 <xTaskCatchUpTicks>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2a64:	20 91 ec 03 	lds	r18, 0x03EC
    2a68:	2f 5f       	subi	r18, 0xFF	; 255
    2a6a:	20 93 ec 03 	sts	0x03EC, r18
    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    2a6e:	0f b6       	in	r0, 0x3f	; 63
    2a70:	f8 94       	cli
    2a72:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    2a74:	20 91 f4 03 	lds	r18, 0x03F4
    2a78:	30 91 f5 03 	lds	r19, 0x03F5
    2a7c:	28 0f       	add	r18, r24
    2a7e:	39 1f       	adc	r19, r25
    2a80:	30 93 f5 03 	sts	0x03F5, r19
    2a84:	20 93 f4 03 	sts	0x03F4, r18
    }
    taskEXIT_CRITICAL();
    2a88:	0f 90       	pop	r0
    2a8a:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    2a8c:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>

    return xYieldOccurred;
}
    2a90:	08 95       	ret

00002a92 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    2a92:	0f 93       	push	r16
    2a94:	1f 93       	push	r17
    2a96:	cf 93       	push	r28
    2a98:	df 93       	push	r29
    2a9a:	ec 01       	movw	r28, r24
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    2a9c:	00 91 ef 03 	lds	r16, 0x03EF
    2aa0:	10 91 f0 03 	lds	r17, 0x03F0
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2aa4:	80 91 ea 03 	lds	r24, 0x03EA
    2aa8:	90 91 eb 03 	lds	r25, 0x03EB
    2aac:	02 96       	adiw	r24, 0x02	; 2
    2aae:	0e 94 49 08 	call	0x1092	; 0x1092 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    2ab2:	c0 0f       	add	r28, r16
    2ab4:	d1 1f       	adc	r29, r17

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    2ab6:	e0 91 ea 03 	lds	r30, 0x03EA
    2aba:	f0 91 eb 03 	lds	r31, 0x03EB
    2abe:	d3 83       	std	Z+3, r29	; 0x03
    2ac0:	c2 83       	std	Z+2, r28	; 0x02

        if( xTimeToWake < xConstTickCount )
    2ac2:	c0 17       	cp	r28, r16
    2ac4:	d1 07       	cpc	r29, r17
    2ac6:	68 f4       	brcc	.+26     	; 0x2ae2 <prvAddCurrentTaskToDelayedList+0x50>
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    2ac8:	80 91 3d 04 	lds	r24, 0x043D
    2acc:	90 91 3e 04 	lds	r25, 0x043E
    2ad0:	60 91 ea 03 	lds	r22, 0x03EA
    2ad4:	70 91 eb 03 	lds	r23, 0x03EB
    2ad8:	6e 5f       	subi	r22, 0xFE	; 254
    2ada:	7f 4f       	sbci	r23, 0xFF	; 255
    2adc:	0e 94 17 08 	call	0x102e	; 0x102e <vListInsert>
    2ae0:	17 c0       	rjmp	.+46     	; 0x2b10 <prvAddCurrentTaskToDelayedList+0x7e>
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    2ae2:	80 91 3b 04 	lds	r24, 0x043B
    2ae6:	90 91 3c 04 	lds	r25, 0x043C
    2aea:	60 91 ea 03 	lds	r22, 0x03EA
    2aee:	70 91 eb 03 	lds	r23, 0x03EB
    2af2:	6e 5f       	subi	r22, 0xFE	; 254
    2af4:	7f 4f       	sbci	r23, 0xFF	; 255
    2af6:	0e 94 17 08 	call	0x102e	; 0x102e <vListInsert>

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
    2afa:	80 91 f1 03 	lds	r24, 0x03F1
    2afe:	90 91 f2 03 	lds	r25, 0x03F2
    2b02:	c8 17       	cp	r28, r24
    2b04:	d9 07       	cpc	r29, r25
    2b06:	20 f4       	brcc	.+8      	; 0x2b10 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                xNextTaskUnblockTime = xTimeToWake;
    2b08:	d0 93 f2 03 	sts	0x03F2, r29
    2b0c:	c0 93 f1 03 	sts	0x03F1, r28

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    2b10:	df 91       	pop	r29
    2b12:	cf 91       	pop	r28
    2b14:	1f 91       	pop	r17
    2b16:	0f 91       	pop	r16
    2b18:	08 95       	ret

00002b1a <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    2b1a:	8f 92       	push	r8
    2b1c:	9f 92       	push	r9
    2b1e:	af 92       	push	r10
    2b20:	bf 92       	push	r11
    2b22:	cf 92       	push	r12
    2b24:	df 92       	push	r13
    2b26:	ef 92       	push	r14
    2b28:	ff 92       	push	r15
    2b2a:	0f 93       	push	r16
    2b2c:	1f 93       	push	r17
    2b2e:	cf 93       	push	r28
    2b30:	df 93       	push	r29
    2b32:	48 01       	movw	r8, r16
    2b34:	59 01       	movw	r10, r18
    2b36:	e7 01       	movw	r28, r14
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    2b38:	0f b6       	in	r0, 0x3f	; 63
    2b3a:	f8 94       	cli
    2b3c:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    2b3e:	e0 91 ea 03 	lds	r30, 0x03EA
    2b42:	f0 91 eb 03 	lds	r31, 0x03EB
    2b46:	e8 2e       	mov	r14, r24
    2b48:	ff 24       	eor	r15, r15
    2b4a:	ee 0d       	add	r30, r14
    2b4c:	ff 1d       	adc	r31, r15
    2b4e:	85 a1       	ldd	r24, Z+37	; 0x25
    2b50:	82 30       	cpi	r24, 0x02	; 2
    2b52:	61 f1       	breq	.+88     	; 0x2bac <xTaskGenericNotifyWait+0x92>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    2b54:	e0 91 ea 03 	lds	r30, 0x03EA
    2b58:	f0 91 eb 03 	lds	r31, 0x03EB
    2b5c:	c7 01       	movw	r24, r14
    2b5e:	88 0f       	add	r24, r24
    2b60:	99 1f       	adc	r25, r25
    2b62:	88 0f       	add	r24, r24
    2b64:	99 1f       	adc	r25, r25
    2b66:	e8 0f       	add	r30, r24
    2b68:	f9 1f       	adc	r31, r25
    2b6a:	81 a1       	ldd	r24, Z+33	; 0x21
    2b6c:	92 a1       	ldd	r25, Z+34	; 0x22
    2b6e:	a3 a1       	ldd	r26, Z+35	; 0x23
    2b70:	b4 a1       	ldd	r27, Z+36	; 0x24
    2b72:	40 95       	com	r20
    2b74:	50 95       	com	r21
    2b76:	60 95       	com	r22
    2b78:	70 95       	com	r23
    2b7a:	84 23       	and	r24, r20
    2b7c:	95 23       	and	r25, r21
    2b7e:	a6 23       	and	r26, r22
    2b80:	b7 23       	and	r27, r23
    2b82:	81 a3       	std	Z+33, r24	; 0x21
    2b84:	92 a3       	std	Z+34, r25	; 0x22
    2b86:	a3 a3       	std	Z+35, r26	; 0x23
    2b88:	b4 a3       	std	Z+36, r27	; 0x24

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    2b8a:	e0 91 ea 03 	lds	r30, 0x03EA
    2b8e:	f0 91 eb 03 	lds	r31, 0x03EB
    2b92:	ee 0d       	add	r30, r14
    2b94:	ff 1d       	adc	r31, r15
    2b96:	81 e0       	ldi	r24, 0x01	; 1
    2b98:	85 a3       	std	Z+37, r24	; 0x25

                if( xTicksToWait > ( TickType_t ) 0 )
    2b9a:	c1 14       	cp	r12, r1
    2b9c:	d1 04       	cpc	r13, r1
    2b9e:	31 f0       	breq	.+12     	; 0x2bac <xTaskGenericNotifyWait+0x92>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2ba0:	c6 01       	movw	r24, r12
    2ba2:	61 e0       	ldi	r22, 0x01	; 1
    2ba4:	0e 94 49 15 	call	0x2a92	; 0x2a92 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    2ba8:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2bac:	0f 90       	pop	r0
    2bae:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    2bb0:	0f b6       	in	r0, 0x3f	; 63
    2bb2:	f8 94       	cli
    2bb4:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    2bb6:	20 97       	sbiw	r28, 0x00	; 0
    2bb8:	99 f0       	breq	.+38     	; 0x2be0 <xTaskGenericNotifyWait+0xc6>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    2bba:	e0 91 ea 03 	lds	r30, 0x03EA
    2bbe:	f0 91 eb 03 	lds	r31, 0x03EB
    2bc2:	c7 01       	movw	r24, r14
    2bc4:	88 0f       	add	r24, r24
    2bc6:	99 1f       	adc	r25, r25
    2bc8:	88 0f       	add	r24, r24
    2bca:	99 1f       	adc	r25, r25
    2bcc:	e8 0f       	add	r30, r24
    2bce:	f9 1f       	adc	r31, r25
    2bd0:	81 a1       	ldd	r24, Z+33	; 0x21
    2bd2:	92 a1       	ldd	r25, Z+34	; 0x22
    2bd4:	a3 a1       	ldd	r26, Z+35	; 0x23
    2bd6:	b4 a1       	ldd	r27, Z+36	; 0x24
    2bd8:	88 83       	st	Y, r24
    2bda:	99 83       	std	Y+1, r25	; 0x01
    2bdc:	aa 83       	std	Y+2, r26	; 0x02
    2bde:	bb 83       	std	Y+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    2be0:	e0 91 ea 03 	lds	r30, 0x03EA
    2be4:	f0 91 eb 03 	lds	r31, 0x03EB
    2be8:	ee 0d       	add	r30, r14
    2bea:	ff 1d       	adc	r31, r15
    2bec:	85 a1       	ldd	r24, Z+37	; 0x25
    2bee:	82 30       	cpi	r24, 0x02	; 2
    2bf0:	11 f0       	breq	.+4      	; 0x2bf6 <xTaskGenericNotifyWait+0xdc>
    2bf2:	80 e0       	ldi	r24, 0x00	; 0
    2bf4:	1c c0       	rjmp	.+56     	; 0x2c2e <xTaskGenericNotifyWait+0x114>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    2bf6:	e0 91 ea 03 	lds	r30, 0x03EA
    2bfa:	f0 91 eb 03 	lds	r31, 0x03EB
    2bfe:	c7 01       	movw	r24, r14
    2c00:	88 0f       	add	r24, r24
    2c02:	99 1f       	adc	r25, r25
    2c04:	88 0f       	add	r24, r24
    2c06:	99 1f       	adc	r25, r25
    2c08:	e8 0f       	add	r30, r24
    2c0a:	f9 1f       	adc	r31, r25
    2c0c:	81 a1       	ldd	r24, Z+33	; 0x21
    2c0e:	92 a1       	ldd	r25, Z+34	; 0x22
    2c10:	a3 a1       	ldd	r26, Z+35	; 0x23
    2c12:	b4 a1       	ldd	r27, Z+36	; 0x24
    2c14:	80 94       	com	r8
    2c16:	90 94       	com	r9
    2c18:	a0 94       	com	r10
    2c1a:	b0 94       	com	r11
    2c1c:	88 21       	and	r24, r8
    2c1e:	99 21       	and	r25, r9
    2c20:	aa 21       	and	r26, r10
    2c22:	bb 21       	and	r27, r11
    2c24:	81 a3       	std	Z+33, r24	; 0x21
    2c26:	92 a3       	std	Z+34, r25	; 0x22
    2c28:	a3 a3       	std	Z+35, r26	; 0x23
    2c2a:	b4 a3       	std	Z+36, r27	; 0x24
    2c2c:	81 e0       	ldi	r24, 0x01	; 1
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    2c2e:	e0 91 ea 03 	lds	r30, 0x03EA
    2c32:	f0 91 eb 03 	lds	r31, 0x03EB
    2c36:	ee 0d       	add	r30, r14
    2c38:	ff 1d       	adc	r31, r15
    2c3a:	15 a2       	std	Z+37, r1	; 0x25
        }
        taskEXIT_CRITICAL();
    2c3c:	0f 90       	pop	r0
    2c3e:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    2c40:	df 91       	pop	r29
    2c42:	cf 91       	pop	r28
    2c44:	1f 91       	pop	r17
    2c46:	0f 91       	pop	r16
    2c48:	ff 90       	pop	r15
    2c4a:	ef 90       	pop	r14
    2c4c:	df 90       	pop	r13
    2c4e:	cf 90       	pop	r12
    2c50:	bf 90       	pop	r11
    2c52:	af 90       	pop	r10
    2c54:	9f 90       	pop	r9
    2c56:	8f 90       	pop	r8
    2c58:	08 95       	ret

00002c5a <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    2c5a:	1f 93       	push	r17
    2c5c:	cf 93       	push	r28
    2c5e:	df 93       	push	r29
    2c60:	16 2f       	mov	r17, r22
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    2c62:	0f b6       	in	r0, 0x3f	; 63
    2c64:	f8 94       	cli
    2c66:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    2c68:	e0 91 ea 03 	lds	r30, 0x03EA
    2c6c:	f0 91 eb 03 	lds	r31, 0x03EB
    2c70:	c8 2f       	mov	r28, r24
    2c72:	d0 e0       	ldi	r29, 0x00	; 0
    2c74:	ce 01       	movw	r24, r28
    2c76:	88 0f       	add	r24, r24
    2c78:	99 1f       	adc	r25, r25
    2c7a:	88 0f       	add	r24, r24
    2c7c:	99 1f       	adc	r25, r25
    2c7e:	e8 0f       	add	r30, r24
    2c80:	f9 1f       	adc	r31, r25
    2c82:	81 a1       	ldd	r24, Z+33	; 0x21
    2c84:	92 a1       	ldd	r25, Z+34	; 0x22
    2c86:	a3 a1       	ldd	r26, Z+35	; 0x23
    2c88:	b4 a1       	ldd	r27, Z+36	; 0x24
    2c8a:	00 97       	sbiw	r24, 0x00	; 0
    2c8c:	a1 05       	cpc	r26, r1
    2c8e:	b1 05       	cpc	r27, r1
    2c90:	89 f4       	brne	.+34     	; 0x2cb4 <ulTaskGenericNotifyTake+0x5a>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    2c92:	e0 91 ea 03 	lds	r30, 0x03EA
    2c96:	f0 91 eb 03 	lds	r31, 0x03EB
    2c9a:	ec 0f       	add	r30, r28
    2c9c:	fd 1f       	adc	r31, r29
    2c9e:	81 e0       	ldi	r24, 0x01	; 1
    2ca0:	85 a3       	std	Z+37, r24	; 0x25

                if( xTicksToWait > ( TickType_t ) 0 )
    2ca2:	41 15       	cp	r20, r1
    2ca4:	51 05       	cpc	r21, r1
    2ca6:	31 f0       	breq	.+12     	; 0x2cb4 <ulTaskGenericNotifyTake+0x5a>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2ca8:	ca 01       	movw	r24, r20
    2caa:	61 e0       	ldi	r22, 0x01	; 1
    2cac:	0e 94 49 15 	call	0x2a92	; 0x2a92 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    2cb0:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2cb4:	0f 90       	pop	r0
    2cb6:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    2cb8:	0f b6       	in	r0, 0x3f	; 63
    2cba:	f8 94       	cli
    2cbc:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    2cbe:	e0 91 ea 03 	lds	r30, 0x03EA
    2cc2:	f0 91 eb 03 	lds	r31, 0x03EB
    2cc6:	ce 01       	movw	r24, r28
    2cc8:	88 0f       	add	r24, r24
    2cca:	99 1f       	adc	r25, r25
    2ccc:	88 0f       	add	r24, r24
    2cce:	99 1f       	adc	r25, r25
    2cd0:	e8 0f       	add	r30, r24
    2cd2:	f9 1f       	adc	r31, r25
    2cd4:	21 a1       	ldd	r18, Z+33	; 0x21
    2cd6:	32 a1       	ldd	r19, Z+34	; 0x22
    2cd8:	43 a1       	ldd	r20, Z+35	; 0x23
    2cda:	54 a1       	ldd	r21, Z+36	; 0x24

            if( ulReturn != 0UL )
    2cdc:	21 15       	cp	r18, r1
    2cde:	31 05       	cpc	r19, r1
    2ce0:	41 05       	cpc	r20, r1
    2ce2:	51 05       	cpc	r21, r1
    2ce4:	f9 f0       	breq	.+62     	; 0x2d24 <ulTaskGenericNotifyTake+0xca>
            {
                if( xClearCountOnExit != pdFALSE )
    2ce6:	11 23       	and	r17, r17
    2ce8:	59 f0       	breq	.+22     	; 0x2d00 <ulTaskGenericNotifyTake+0xa6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    2cea:	e0 91 ea 03 	lds	r30, 0x03EA
    2cee:	f0 91 eb 03 	lds	r31, 0x03EB
    2cf2:	e8 0f       	add	r30, r24
    2cf4:	f9 1f       	adc	r31, r25
    2cf6:	11 a2       	std	Z+33, r1	; 0x21
    2cf8:	12 a2       	std	Z+34, r1	; 0x22
    2cfa:	13 a2       	std	Z+35, r1	; 0x23
    2cfc:	14 a2       	std	Z+36, r1	; 0x24
    2cfe:	12 c0       	rjmp	.+36     	; 0x2d24 <ulTaskGenericNotifyTake+0xca>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    2d00:	e0 91 ea 03 	lds	r30, 0x03EA
    2d04:	f0 91 eb 03 	lds	r31, 0x03EB
    2d08:	21 50       	subi	r18, 0x01	; 1
    2d0a:	30 40       	sbci	r19, 0x00	; 0
    2d0c:	40 40       	sbci	r20, 0x00	; 0
    2d0e:	50 40       	sbci	r21, 0x00	; 0
    2d10:	e8 0f       	add	r30, r24
    2d12:	f9 1f       	adc	r31, r25
    2d14:	21 a3       	std	Z+33, r18	; 0x21
    2d16:	32 a3       	std	Z+34, r19	; 0x22
    2d18:	43 a3       	std	Z+35, r20	; 0x23
    2d1a:	54 a3       	std	Z+36, r21	; 0x24
    2d1c:	2f 5f       	subi	r18, 0xFF	; 255
    2d1e:	3f 4f       	sbci	r19, 0xFF	; 255
    2d20:	4f 4f       	sbci	r20, 0xFF	; 255
    2d22:	5f 4f       	sbci	r21, 0xFF	; 255
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    2d24:	e0 91 ea 03 	lds	r30, 0x03EA
    2d28:	f0 91 eb 03 	lds	r31, 0x03EB
    2d2c:	ec 0f       	add	r30, r28
    2d2e:	fd 1f       	adc	r31, r29
    2d30:	15 a2       	std	Z+37, r1	; 0x25
        }
        taskEXIT_CRITICAL();
    2d32:	0f 90       	pop	r0
    2d34:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    2d36:	b9 01       	movw	r22, r18
    2d38:	ca 01       	movw	r24, r20
    2d3a:	df 91       	pop	r29
    2d3c:	cf 91       	pop	r28
    2d3e:	1f 91       	pop	r17
    2d40:	08 95       	ret

00002d42 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    2d42:	0f 93       	push	r16
    2d44:	1f 93       	push	r17
    2d46:	8c 01       	movw	r16, r24
    2d48:	ca 01       	movw	r24, r20
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2d4a:	e0 91 ea 03 	lds	r30, 0x03EA
    2d4e:	f0 91 eb 03 	lds	r31, 0x03EB
    2d52:	70 68       	ori	r23, 0x80	; 128
    2d54:	75 87       	std	Z+13, r23	; 0x0d
    2d56:	64 87       	std	Z+12, r22	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2d58:	f8 01       	movw	r30, r16
    2d5a:	a1 81       	ldd	r26, Z+1	; 0x01
    2d5c:	b2 81       	ldd	r27, Z+2	; 0x02
    2d5e:	e0 91 ea 03 	lds	r30, 0x03EA
    2d62:	f0 91 eb 03 	lds	r31, 0x03EB
    2d66:	b7 87       	std	Z+15, r27	; 0x0f
    2d68:	a6 87       	std	Z+14, r26	; 0x0e
    2d6a:	e0 91 ea 03 	lds	r30, 0x03EA
    2d6e:	f0 91 eb 03 	lds	r31, 0x03EB
    2d72:	14 96       	adiw	r26, 0x04	; 4
    2d74:	2d 91       	ld	r18, X+
    2d76:	3c 91       	ld	r19, X
    2d78:	15 97       	sbiw	r26, 0x05	; 5
    2d7a:	31 8b       	std	Z+17, r19	; 0x11
    2d7c:	20 8b       	std	Z+16, r18	; 0x10
    2d7e:	20 91 ea 03 	lds	r18, 0x03EA
    2d82:	30 91 eb 03 	lds	r19, 0x03EB
    2d86:	14 96       	adiw	r26, 0x04	; 4
    2d88:	ed 91       	ld	r30, X+
    2d8a:	fc 91       	ld	r31, X
    2d8c:	15 97       	sbiw	r26, 0x05	; 5
    2d8e:	24 5f       	subi	r18, 0xF4	; 244
    2d90:	3f 4f       	sbci	r19, 0xFF	; 255
    2d92:	33 83       	std	Z+3, r19	; 0x03
    2d94:	22 83       	std	Z+2, r18	; 0x02
    2d96:	20 91 ea 03 	lds	r18, 0x03EA
    2d9a:	30 91 eb 03 	lds	r19, 0x03EB
    2d9e:	24 5f       	subi	r18, 0xF4	; 244
    2da0:	3f 4f       	sbci	r19, 0xFF	; 255
    2da2:	15 96       	adiw	r26, 0x05	; 5
    2da4:	3c 93       	st	X, r19
    2da6:	2e 93       	st	-X, r18
    2da8:	14 97       	sbiw	r26, 0x04	; 4
    2daa:	e0 91 ea 03 	lds	r30, 0x03EA
    2dae:	f0 91 eb 03 	lds	r31, 0x03EB
    2db2:	15 8b       	std	Z+21, r17	; 0x15
    2db4:	04 8b       	std	Z+20, r16	; 0x14
    2db6:	f8 01       	movw	r30, r16
    2db8:	20 81       	ld	r18, Z
    2dba:	2f 5f       	subi	r18, 0xFF	; 255
    2dbc:	20 83       	st	Z, r18

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2dbe:	61 e0       	ldi	r22, 0x01	; 1
    2dc0:	0e 94 49 15 	call	0x2a92	; 0x2a92 <prvAddCurrentTaskToDelayedList>
}
    2dc4:	1f 91       	pop	r17
    2dc6:	0f 91       	pop	r16
    2dc8:	08 95       	ret

00002dca <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    2dca:	9c 01       	movw	r18, r24
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    2dcc:	00 97       	sbiw	r24, 0x00	; 0
    2dce:	69 f0       	breq	.+26     	; 0x2dea <vTaskDelay+0x20>
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2dd0:	80 91 ec 03 	lds	r24, 0x03EC
    2dd4:	8f 5f       	subi	r24, 0xFF	; 255
    2dd6:	80 93 ec 03 	sts	0x03EC, r24
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2dda:	c9 01       	movw	r24, r18
    2ddc:	60 e0       	ldi	r22, 0x00	; 0
    2dde:	0e 94 49 15 	call	0x2a92	; 0x2a92 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    2de2:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    2de6:	88 23       	and	r24, r24
    2de8:	11 f4       	brne	.+4      	; 0x2dee <vTaskDelay+0x24>
        {
            portYIELD_WITHIN_API();
    2dea:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    2dee:	08 95       	ret

00002df0 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    2df0:	1f 93       	push	r17
    2df2:	fc 01       	movw	r30, r24
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2df4:	80 91 ec 03 	lds	r24, 0x03EC
    2df8:	8f 5f       	subi	r24, 0xFF	; 255
    2dfa:	80 93 ec 03 	sts	0x03EC, r24

        vTaskSuspendAll();
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    2dfe:	80 91 ef 03 	lds	r24, 0x03EF
    2e02:	90 91 f0 03 	lds	r25, 0x03F0

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2e06:	20 81       	ld	r18, Z
    2e08:	31 81       	ldd	r19, Z+1	; 0x01
    2e0a:	62 0f       	add	r22, r18
    2e0c:	73 1f       	adc	r23, r19

            if( xConstTickCount < *pxPreviousWakeTime )
    2e0e:	82 17       	cp	r24, r18
    2e10:	93 07       	cpc	r25, r19
    2e12:	28 f4       	brcc	.+10     	; 0x2e1e <xTaskDelayUntil+0x2e>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2e14:	62 17       	cp	r22, r18
    2e16:	73 07       	cpc	r23, r19
    2e18:	28 f0       	brcs	.+10     	; 0x2e24 <xTaskDelayUntil+0x34>
    2e1a:	10 e0       	ldi	r17, 0x00	; 0
    2e1c:	08 c0       	rjmp	.+16     	; 0x2e2e <xTaskDelayUntil+0x3e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2e1e:	62 17       	cp	r22, r18
    2e20:	73 07       	cpc	r23, r19
    2e22:	20 f0       	brcs	.+8      	; 0x2e2c <xTaskDelayUntil+0x3c>
    2e24:	10 e0       	ldi	r17, 0x00	; 0
    2e26:	86 17       	cp	r24, r22
    2e28:	97 07       	cpc	r25, r23
    2e2a:	08 f4       	brcc	.+2      	; 0x2e2e <xTaskDelayUntil+0x3e>
    2e2c:	11 e0       	ldi	r17, 0x01	; 1
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    2e2e:	71 83       	std	Z+1, r23	; 0x01
    2e30:	60 83       	st	Z, r22

            if( xShouldDelay != pdFALSE )
    2e32:	11 23       	and	r17, r17
    2e34:	39 f0       	breq	.+14     	; 0x2e44 <xTaskDelayUntil+0x54>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2e36:	9b 01       	movw	r18, r22
    2e38:	28 1b       	sub	r18, r24
    2e3a:	39 0b       	sbc	r19, r25
    2e3c:	c9 01       	movw	r24, r18
    2e3e:	60 e0       	ldi	r22, 0x00	; 0
    2e40:	0e 94 49 15 	call	0x2a92	; 0x2a92 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    2e44:	0e 94 54 14 	call	0x28a8	; 0x28a8 <xTaskResumeAll>

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    2e48:	88 23       	and	r24, r24
    2e4a:	11 f4       	brne	.+4      	; 0x2e50 <xTaskDelayUntil+0x60>
        {
            portYIELD_WITHIN_API();
    2e4c:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    }
    2e50:	81 2f       	mov	r24, r17
    2e52:	1f 91       	pop	r17
    2e54:	08 95       	ret

00002e56 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    2e56:	0f 93       	push	r16
    2e58:	1f 93       	push	r17
    2e5a:	8b 01       	movw	r16, r22
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2e5c:	60 91 ea 03 	lds	r22, 0x03EA
    2e60:	70 91 eb 03 	lds	r23, 0x03EB
    2e64:	64 5f       	subi	r22, 0xF4	; 244
    2e66:	7f 4f       	sbci	r23, 0xFF	; 255
    2e68:	0e 94 17 08 	call	0x102e	; 0x102e <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2e6c:	c8 01       	movw	r24, r16
    2e6e:	61 e0       	ldi	r22, 0x01	; 1
    2e70:	0e 94 49 15 	call	0x2a92	; 0x2a92 <prvAddCurrentTaskToDelayedList>
}
    2e74:	1f 91       	pop	r17
    2e76:	0f 91       	pop	r16
    2e78:	08 95       	ret

00002e7a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    2e7a:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    2e7c:	10 92 f7 03 	sts	0x03F7, r1
    vPortEndScheduler();
    2e80:	0e 94 f1 08 	call	0x11e2	; 0x11e2 <vPortEndScheduler>
}
    2e84:	08 95       	ret

00002e86 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2e86:	0f 93       	push	r16
    2e88:	1f 93       	push	r17
    2e8a:	21 c0       	rjmp	.+66     	; 0x2ece <prvIdleTask+0x48>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    2e8c:	0f b6       	in	r0, 0x3f	; 63
    2e8e:	f8 94       	cli
    2e90:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2e92:	e0 91 4d 04 	lds	r30, 0x044D
    2e96:	f0 91 4e 04 	lds	r31, 0x044E
    2e9a:	06 81       	ldd	r16, Z+6	; 0x06
    2e9c:	17 81       	ldd	r17, Z+7	; 0x07
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2e9e:	c8 01       	movw	r24, r16
    2ea0:	02 96       	adiw	r24, 0x02	; 2
    2ea2:	0e 94 49 08 	call	0x1092	; 0x1092 <uxListRemove>
                --uxCurrentNumberOfTasks;
    2ea6:	80 91 f6 03 	lds	r24, 0x03F6
    2eaa:	81 50       	subi	r24, 0x01	; 1
    2eac:	80 93 f6 03 	sts	0x03F6, r24
                --uxDeletedTasksWaitingCleanUp;
    2eb0:	80 91 fa 03 	lds	r24, 0x03FA
    2eb4:	81 50       	subi	r24, 0x01	; 1
    2eb6:	80 93 fa 03 	sts	0x03FA, r24
            }
            taskEXIT_CRITICAL();
    2eba:	0f 90       	pop	r0
    2ebc:	0f be       	out	0x3f, r0	; 63

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    2ebe:	f8 01       	movw	r30, r16
    2ec0:	87 89       	ldd	r24, Z+23	; 0x17
    2ec2:	90 8d       	ldd	r25, Z+24	; 0x18
    2ec4:	0e 94 cf 06 	call	0xd9e	; 0xd9e <vPortFree>
            vPortFree( pxTCB );
    2ec8:	c8 01       	movw	r24, r16
    2eca:	0e 94 cf 06 	call	0xd9e	; 0xd9e <vPortFree>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    2ece:	80 91 fa 03 	lds	r24, 0x03FA
    2ed2:	88 23       	and	r24, r24
    2ed4:	e1 f3       	breq	.-8      	; 0x2ece <prvIdleTask+0x48>
    2ed6:	da cf       	rjmp	.-76     	; 0x2e8c <prvIdleTask+0x6>

00002ed8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    2ed8:	0f 93       	push	r16
    2eda:	1f 93       	push	r17
    2edc:	cf 93       	push	r28
    2ede:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    2ee0:	0f b6       	in	r0, 0x3f	; 63
    2ee2:	f8 94       	cli
    2ee4:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2ee6:	00 97       	sbiw	r24, 0x00	; 0
    2ee8:	11 f0       	breq	.+4      	; 0x2eee <vTaskDelete+0x16>
    2eea:	ec 01       	movw	r28, r24
    2eec:	04 c0       	rjmp	.+8      	; 0x2ef6 <vTaskDelete+0x1e>
    2eee:	c0 91 ea 03 	lds	r28, 0x03EA
    2ef2:	d0 91 eb 03 	lds	r29, 0x03EB

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2ef6:	8e 01       	movw	r16, r28
    2ef8:	0e 5f       	subi	r16, 0xFE	; 254
    2efa:	1f 4f       	sbci	r17, 0xFF	; 255
    2efc:	c8 01       	movw	r24, r16
    2efe:	0e 94 49 08 	call	0x1092	; 0x1092 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2f02:	8c 89       	ldd	r24, Y+20	; 0x14
    2f04:	9d 89       	ldd	r25, Y+21	; 0x15
    2f06:	89 2b       	or	r24, r25
    2f08:	21 f0       	breq	.+8      	; 0x2f12 <vTaskDelete+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2f0a:	ce 01       	movw	r24, r28
    2f0c:	0c 96       	adiw	r24, 0x0c	; 12
    2f0e:	0e 94 49 08 	call	0x1092	; 0x1092 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    2f12:	80 91 fb 03 	lds	r24, 0x03FB
    2f16:	8f 5f       	subi	r24, 0xFF	; 255
    2f18:	80 93 fb 03 	sts	0x03FB, r24

            if( pxTCB == pxCurrentTCB )
    2f1c:	80 91 ea 03 	lds	r24, 0x03EA
    2f20:	90 91 eb 03 	lds	r25, 0x03EB
    2f24:	c8 17       	cp	r28, r24
    2f26:	d9 07       	cpc	r29, r25
    2f28:	59 f4       	brne	.+22     	; 0x2f40 <vTaskDelete+0x68>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2f2a:	88 e4       	ldi	r24, 0x48	; 72
    2f2c:	94 e0       	ldi	r25, 0x04	; 4
    2f2e:	b8 01       	movw	r22, r16
    2f30:	0e 94 f8 07 	call	0xff0	; 0xff0 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    2f34:	80 91 fa 03 	lds	r24, 0x03FA
    2f38:	8f 5f       	subi	r24, 0xFF	; 255
    2f3a:	80 93 fa 03 	sts	0x03FA, r24
    2f3e:	1c c0       	rjmp	.+56     	; 0x2f78 <vTaskDelete+0xa0>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    2f40:	80 91 f6 03 	lds	r24, 0x03F6
    2f44:	81 50       	subi	r24, 0x01	; 1
    2f46:	80 93 f6 03 	sts	0x03F6, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2f4a:	e0 91 3b 04 	lds	r30, 0x043B
    2f4e:	f0 91 3c 04 	lds	r31, 0x043C
    2f52:	80 81       	ld	r24, Z
    2f54:	88 23       	and	r24, r24
    2f56:	19 f4       	brne	.+6      	; 0x2f5e <vTaskDelete+0x86>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    2f58:	8f ef       	ldi	r24, 0xFF	; 255
    2f5a:	9f ef       	ldi	r25, 0xFF	; 255
    2f5c:	09 c0       	rjmp	.+18     	; 0x2f70 <vTaskDelete+0x98>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    2f5e:	e0 91 3b 04 	lds	r30, 0x043B
    2f62:	f0 91 3c 04 	lds	r31, 0x043C
    2f66:	05 80       	ldd	r0, Z+5	; 0x05
    2f68:	f6 81       	ldd	r31, Z+6	; 0x06
    2f6a:	e0 2d       	mov	r30, r0
    2f6c:	80 81       	ld	r24, Z
    2f6e:	91 81       	ldd	r25, Z+1	; 0x01
    2f70:	90 93 f2 03 	sts	0x03F2, r25
    2f74:	80 93 f1 03 	sts	0x03F1, r24
                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
            }
        }
        taskEXIT_CRITICAL();
    2f78:	0f 90       	pop	r0
    2f7a:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    2f7c:	80 91 ea 03 	lds	r24, 0x03EA
    2f80:	90 91 eb 03 	lds	r25, 0x03EB
    2f84:	c8 17       	cp	r28, r24
    2f86:	d9 07       	cpc	r29, r25
    2f88:	39 f0       	breq	.+14     	; 0x2f98 <vTaskDelete+0xc0>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    2f8a:	8f 89       	ldd	r24, Y+23	; 0x17
    2f8c:	98 8d       	ldd	r25, Y+24	; 0x18
    2f8e:	0e 94 cf 06 	call	0xd9e	; 0xd9e <vPortFree>
            vPortFree( pxTCB );
    2f92:	ce 01       	movw	r24, r28
    2f94:	0e 94 cf 06 	call	0xd9e	; 0xd9e <vPortFree>
            prvDeleteTCB( pxTCB );
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    2f98:	80 91 f7 03 	lds	r24, 0x03F7
    2f9c:	88 23       	and	r24, r24
    2f9e:	49 f0       	breq	.+18     	; 0x2fb2 <vTaskDelete+0xda>
        {
            if( pxTCB == pxCurrentTCB )
    2fa0:	80 91 ea 03 	lds	r24, 0x03EA
    2fa4:	90 91 eb 03 	lds	r25, 0x03EB
    2fa8:	c8 17       	cp	r28, r24
    2faa:	d9 07       	cpc	r29, r25
    2fac:	11 f4       	brne	.+4      	; 0x2fb2 <vTaskDelete+0xda>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    2fae:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    2fb2:	df 91       	pop	r29
    2fb4:	cf 91       	pop	r28
    2fb6:	1f 91       	pop	r17
    2fb8:	0f 91       	pop	r16
    2fba:	08 95       	ret

00002fbc <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    2fbc:	4f 92       	push	r4
    2fbe:	5f 92       	push	r5
    2fc0:	6f 92       	push	r6
    2fc2:	7f 92       	push	r7
    2fc4:	8f 92       	push	r8
    2fc6:	9f 92       	push	r9
    2fc8:	af 92       	push	r10
    2fca:	bf 92       	push	r11
    2fcc:	cf 92       	push	r12
    2fce:	df 92       	push	r13
    2fd0:	ef 92       	push	r14
    2fd2:	ff 92       	push	r15
    2fd4:	0f 93       	push	r16
    2fd6:	1f 93       	push	r17
    2fd8:	cf 93       	push	r28
    2fda:	df 93       	push	r29
    2fdc:	2c 01       	movw	r4, r24
    2fde:	4b 01       	movw	r8, r22
    2fe0:	5a 01       	movw	r10, r20
    2fe2:	39 01       	movw	r6, r18
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2fe4:	ca 01       	movw	r24, r20
    2fe6:	0e 94 ff 06 	call	0xdfe	; 0xdfe <pvPortMalloc>
    2fea:	ec 01       	movw	r28, r24

            if( pxStack != NULL )
    2fec:	00 97       	sbiw	r24, 0x00	; 0
    2fee:	b1 f0       	breq	.+44     	; 0x301c <xTaskCreate+0x60>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2ff0:	86 e2       	ldi	r24, 0x26	; 38
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	0e 94 ff 06 	call	0xdfe	; 0xdfe <pvPortMalloc>
    2ff8:	6c 01       	movw	r12, r24

                if( pxNewTCB != NULL )
    2ffa:	00 97       	sbiw	r24, 0x00	; 0
    2ffc:	61 f0       	breq	.+24     	; 0x3016 <xTaskCreate+0x5a>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    2ffe:	86 e2       	ldi	r24, 0x26	; 38
    3000:	d6 01       	movw	r26, r12
    3002:	1d 92       	st	X+, r1
    3004:	8a 95       	dec	r24
    3006:	e9 f7       	brne	.-6      	; 0x3002 <xTaskCreate+0x46>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    3008:	f6 01       	movw	r30, r12
    300a:	d0 8f       	std	Z+24, r29	; 0x18
    300c:	c7 8b       	std	Z+23, r28	; 0x17
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    300e:	81 14       	cp	r8, r1
    3010:	91 04       	cpc	r9, r1
    3012:	31 f4       	brne	.+12     	; 0x3020 <xTaskCreate+0x64>
    3014:	17 c0       	rjmp	.+46     	; 0x3044 <xTaskCreate+0x88>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    3016:	ce 01       	movw	r24, r28
    3018:	0e 94 cf 06 	call	0xd9e	; 0xd9e <vPortFree>
    301c:	8f ef       	ldi	r24, 0xFF	; 255
    301e:	e7 c0       	rjmp	.+462    	; 0x31ee <xTaskCreate+0x232>
    3020:	f4 01       	movw	r30, r8
    3022:	d6 01       	movw	r26, r12
    3024:	90 e0       	ldi	r25, 0x00	; 0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3026:	80 81       	ld	r24, Z
    3028:	59 96       	adiw	r26, 0x19	; 25
    302a:	8c 93       	st	X, r24
    302c:	59 97       	sbiw	r26, 0x19	; 25

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    302e:	80 81       	ld	r24, Z
    3030:	88 23       	and	r24, r24
    3032:	29 f0       	breq	.+10     	; 0x303e <xTaskCreate+0x82>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3034:	9f 5f       	subi	r25, 0xFF	; 255
    3036:	31 96       	adiw	r30, 0x01	; 1
    3038:	11 96       	adiw	r26, 0x01	; 1
    303a:	98 30       	cpi	r25, 0x08	; 8
    303c:	a1 f7       	brne	.-24     	; 0x3026 <xTaskCreate+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    303e:	d6 01       	movw	r26, r12
    3040:	90 96       	adiw	r26, 0x20	; 32
    3042:	1c 92       	st	X, r1
    3044:	05 30       	cpi	r16, 0x05	; 5
    3046:	08 f0       	brcs	.+2      	; 0x304a <xTaskCreate+0x8e>
    3048:	04 e0       	ldi	r16, 0x04	; 4
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    304a:	f6 01       	movw	r30, r12
    304c:	06 8b       	std	Z+22, r16	; 0x16
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    304e:	52 e0       	ldi	r21, 0x02	; 2
    3050:	85 2e       	mov	r8, r21
    3052:	91 2c       	mov	r9, r1
    3054:	8c 0c       	add	r8, r12
    3056:	9d 1c       	adc	r9, r13
    3058:	c4 01       	movw	r24, r8
    305a:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    305e:	c6 01       	movw	r24, r12
    3060:	0c 96       	adiw	r24, 0x0c	; 12
    3062:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3066:	d6 01       	movw	r26, r12
    3068:	19 96       	adiw	r26, 0x09	; 9
    306a:	dc 92       	st	X, r13
    306c:	ce 92       	st	-X, r12
    306e:	18 97       	sbiw	r26, 0x08	; 8

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3070:	85 e0       	ldi	r24, 0x05	; 5
    3072:	90 e0       	ldi	r25, 0x00	; 0
    3074:	80 1b       	sub	r24, r16
    3076:	91 09       	sbc	r25, r1
    3078:	1d 96       	adiw	r26, 0x0d	; 13
    307a:	9c 93       	st	X, r25
    307c:	8e 93       	st	-X, r24
    307e:	1c 97       	sbiw	r26, 0x0c	; 12
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3080:	53 96       	adiw	r26, 0x13	; 19
    3082:	dc 92       	st	X, r13
    3084:	ce 92       	st	-X, r12
    3086:	52 97       	sbiw	r26, 0x12	; 18
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3088:	08 94       	sec
    308a:	a1 08       	sbc	r10, r1
    308c:	b1 08       	sbc	r11, r1
    308e:	ce 01       	movw	r24, r28
    3090:	8a 0d       	add	r24, r10
    3092:	9b 1d       	adc	r25, r11
    3094:	b2 01       	movw	r22, r4
    3096:	a3 01       	movw	r20, r6
    3098:	0e 94 74 08 	call	0x10e8	; 0x10e8 <pxPortInitialiseStack>
    309c:	f6 01       	movw	r30, r12
    309e:	91 83       	std	Z+1, r25	; 0x01
    30a0:	80 83       	st	Z, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    30a2:	e1 14       	cp	r14, r1
    30a4:	f1 04       	cpc	r15, r1
    30a6:	19 f0       	breq	.+6      	; 0x30ae <xTaskCreate+0xf2>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    30a8:	d7 01       	movw	r26, r14
    30aa:	cd 92       	st	X+, r12
    30ac:	dc 92       	st	X, r13

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    30ae:	0f b6       	in	r0, 0x3f	; 63
    30b0:	f8 94       	cli
    30b2:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    30b4:	80 91 f6 03 	lds	r24, 0x03F6
    30b8:	8f 5f       	subi	r24, 0xFF	; 255
    30ba:	80 93 f6 03 	sts	0x03F6, r24

        if( pxCurrentTCB == NULL )
    30be:	80 91 ea 03 	lds	r24, 0x03EA
    30c2:	90 91 eb 03 	lds	r25, 0x03EB
    30c6:	89 2b       	or	r24, r25
    30c8:	79 f5       	brne	.+94     	; 0x3128 <xTaskCreate+0x16c>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    30ca:	d0 92 eb 03 	sts	0x03EB, r13
    30ce:	c0 92 ea 03 	sts	0x03EA, r12

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    30d2:	80 91 f6 03 	lds	r24, 0x03F6
    30d6:	81 30       	cpi	r24, 0x01	; 1
    30d8:	c1 f5       	brne	.+112    	; 0x314a <xTaskCreate+0x18e>
    30da:	cc ef       	ldi	r28, 0xFC	; 252
    30dc:	d3 e0       	ldi	r29, 0x03	; 3
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    30de:	ce 01       	movw	r24, r28
    30e0:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vListInitialise>
    30e4:	29 96       	adiw	r28, 0x09	; 9

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    30e6:	b4 e0       	ldi	r27, 0x04	; 4
    30e8:	c9 32       	cpi	r28, 0x29	; 41
    30ea:	db 07       	cpc	r29, r27
    30ec:	c1 f7       	brne	.-16     	; 0x30de <xTaskCreate+0x122>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    30ee:	49 e2       	ldi	r20, 0x29	; 41
    30f0:	e4 2e       	mov	r14, r20
    30f2:	44 e0       	ldi	r20, 0x04	; 4
    30f4:	f4 2e       	mov	r15, r20
    30f6:	c7 01       	movw	r24, r14
    30f8:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    30fc:	02 e3       	ldi	r16, 0x32	; 50
    30fe:	14 e0       	ldi	r17, 0x04	; 4
    3100:	c8 01       	movw	r24, r16
    3102:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    3106:	8f e3       	ldi	r24, 0x3F	; 63
    3108:	94 e0       	ldi	r25, 0x04	; 4
    310a:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    310e:	88 e4       	ldi	r24, 0x48	; 72
    3110:	94 e0       	ldi	r25, 0x04	; 4
    3112:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    3116:	f0 92 3c 04 	sts	0x043C, r15
    311a:	e0 92 3b 04 	sts	0x043B, r14
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    311e:	10 93 3e 04 	sts	0x043E, r17
    3122:	00 93 3d 04 	sts	0x043D, r16
    3126:	11 c0       	rjmp	.+34     	; 0x314a <xTaskCreate+0x18e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    3128:	80 91 f7 03 	lds	r24, 0x03F7
    312c:	88 23       	and	r24, r24
    312e:	69 f4       	brne	.+26     	; 0x314a <xTaskCreate+0x18e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3130:	e0 91 ea 03 	lds	r30, 0x03EA
    3134:	f0 91 eb 03 	lds	r31, 0x03EB
    3138:	96 89       	ldd	r25, Z+22	; 0x16
    313a:	f6 01       	movw	r30, r12
    313c:	86 89       	ldd	r24, Z+22	; 0x16
    313e:	89 17       	cp	r24, r25
    3140:	20 f0       	brcs	.+8      	; 0x314a <xTaskCreate+0x18e>
                {
                    pxCurrentTCB = pxNewTCB;
    3142:	d0 92 eb 03 	sts	0x03EB, r13
    3146:	c0 92 ea 03 	sts	0x03EA, r12
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    314a:	80 91 fb 03 	lds	r24, 0x03FB
    314e:	8f 5f       	subi	r24, 0xFF	; 255
    3150:	80 93 fb 03 	sts	0x03FB, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    3154:	d6 01       	movw	r26, r12
    3156:	56 96       	adiw	r26, 0x16	; 22
    3158:	9c 91       	ld	r25, X
    315a:	80 91 ed 03 	lds	r24, 0x03ED
    315e:	89 17       	cp	r24, r25
    3160:	10 f4       	brcc	.+4      	; 0x3166 <xTaskCreate+0x1aa>
    3162:	90 93 ed 03 	sts	0x03ED, r25
    3166:	89 2f       	mov	r24, r25
    3168:	90 e0       	ldi	r25, 0x00	; 0
    316a:	fc 01       	movw	r30, r24
    316c:	33 e0       	ldi	r19, 0x03	; 3
    316e:	ee 0f       	add	r30, r30
    3170:	ff 1f       	adc	r31, r31
    3172:	3a 95       	dec	r19
    3174:	e1 f7       	brne	.-8      	; 0x316e <xTaskCreate+0x1b2>
    3176:	e8 0f       	add	r30, r24
    3178:	f9 1f       	adc	r31, r25
    317a:	e4 50       	subi	r30, 0x04	; 4
    317c:	fc 4f       	sbci	r31, 0xFC	; 252
    317e:	a1 81       	ldd	r26, Z+1	; 0x01
    3180:	b2 81       	ldd	r27, Z+2	; 0x02
    3182:	f6 01       	movw	r30, r12
    3184:	b5 83       	std	Z+5, r27	; 0x05
    3186:	a4 83       	std	Z+4, r26	; 0x04
    3188:	14 96       	adiw	r26, 0x04	; 4
    318a:	8d 91       	ld	r24, X+
    318c:	9c 91       	ld	r25, X
    318e:	15 97       	sbiw	r26, 0x05	; 5
    3190:	97 83       	std	Z+7, r25	; 0x07
    3192:	86 83       	std	Z+6, r24	; 0x06
    3194:	14 96       	adiw	r26, 0x04	; 4
    3196:	ed 91       	ld	r30, X+
    3198:	fc 91       	ld	r31, X
    319a:	15 97       	sbiw	r26, 0x05	; 5
    319c:	93 82       	std	Z+3, r9	; 0x03
    319e:	82 82       	std	Z+2, r8	; 0x02
    31a0:	15 96       	adiw	r26, 0x05	; 5
    31a2:	9c 92       	st	X, r9
    31a4:	8e 92       	st	-X, r8
    31a6:	14 97       	sbiw	r26, 0x04	; 4
    31a8:	d6 01       	movw	r26, r12
    31aa:	56 96       	adiw	r26, 0x16	; 22
    31ac:	ec 91       	ld	r30, X
    31ae:	56 97       	sbiw	r26, 0x16	; 22
    31b0:	89 e0       	ldi	r24, 0x09	; 9
    31b2:	e8 9f       	mul	r30, r24
    31b4:	f0 01       	movw	r30, r0
    31b6:	11 24       	eor	r1, r1
    31b8:	e4 50       	subi	r30, 0x04	; 4
    31ba:	fc 4f       	sbci	r31, 0xFC	; 252
    31bc:	1b 96       	adiw	r26, 0x0b	; 11
    31be:	fc 93       	st	X, r31
    31c0:	ee 93       	st	-X, r30
    31c2:	1a 97       	sbiw	r26, 0x0a	; 10
    31c4:	80 81       	ld	r24, Z
    31c6:	8f 5f       	subi	r24, 0xFF	; 255
    31c8:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    31ca:	0f 90       	pop	r0
    31cc:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    31ce:	80 91 f7 03 	lds	r24, 0x03F7
    31d2:	88 23       	and	r24, r24
    31d4:	59 f0       	breq	.+22     	; 0x31ec <xTaskCreate+0x230>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    31d6:	e0 91 ea 03 	lds	r30, 0x03EA
    31da:	f0 91 eb 03 	lds	r31, 0x03EB
    31de:	96 89       	ldd	r25, Z+22	; 0x16
    31e0:	f6 01       	movw	r30, r12
    31e2:	86 89       	ldd	r24, Z+22	; 0x16
    31e4:	98 17       	cp	r25, r24
    31e6:	10 f4       	brcc	.+4      	; 0x31ec <xTaskCreate+0x230>
        {
            taskYIELD_IF_USING_PREEMPTION();
    31e8:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    31ec:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    31ee:	df 91       	pop	r29
    31f0:	cf 91       	pop	r28
    31f2:	1f 91       	pop	r17
    31f4:	0f 91       	pop	r16
    31f6:	ff 90       	pop	r15
    31f8:	ef 90       	pop	r14
    31fa:	df 90       	pop	r13
    31fc:	cf 90       	pop	r12
    31fe:	bf 90       	pop	r11
    3200:	af 90       	pop	r10
    3202:	9f 90       	pop	r9
    3204:	8f 90       	pop	r8
    3206:	7f 90       	pop	r7
    3208:	6f 90       	pop	r6
    320a:	5f 90       	pop	r5
    320c:	4f 90       	pop	r4
    320e:	08 95       	ret

00003210 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3210:	ef 92       	push	r14
    3212:	ff 92       	push	r15
    3214:	0f 93       	push	r16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    3216:	83 e4       	ldi	r24, 0x43	; 67
    3218:	97 e1       	ldi	r25, 0x17	; 23
    321a:	60 e6       	ldi	r22, 0x60	; 96
    321c:	70 e0       	ldi	r23, 0x00	; 0
    321e:	45 e5       	ldi	r20, 0x55	; 85
    3220:	50 e0       	ldi	r21, 0x00	; 0
    3222:	20 e0       	ldi	r18, 0x00	; 0
    3224:	30 e0       	ldi	r19, 0x00	; 0
    3226:	00 e0       	ldi	r16, 0x00	; 0
    3228:	e8 ef       	ldi	r30, 0xF8	; 248
    322a:	ee 2e       	mov	r14, r30
    322c:	e3 e0       	ldi	r30, 0x03	; 3
    322e:	fe 2e       	mov	r15, r30
    3230:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <xTaskCreate>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    3234:	81 30       	cpi	r24, 0x01	; 1
    3236:	81 f4       	brne	.+32     	; 0x3258 <vTaskStartScheduler+0x48>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3238:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    323a:	8f ef       	ldi	r24, 0xFF	; 255
    323c:	9f ef       	ldi	r25, 0xFF	; 255
    323e:	90 93 f2 03 	sts	0x03F2, r25
    3242:	80 93 f1 03 	sts	0x03F1, r24
        xSchedulerRunning = pdTRUE;
    3246:	81 e0       	ldi	r24, 0x01	; 1
    3248:	80 93 f7 03 	sts	0x03F7, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    324c:	10 92 f0 03 	sts	0x03F0, r1
    3250:	10 92 ef 03 	sts	0x03EF, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    3254:	0e 94 bc 08 	call	0x1178	; 0x1178 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3258:	80 91 7d 01 	lds	r24, 0x017D
}
    325c:	0f 91       	pop	r16
    325e:	ff 90       	pop	r15
    3260:	ef 90       	pop	r14
    3262:	08 95       	ret

00003264 <vGasTaskCode>:
}

void vGasTaskCode (void * pvParameters){
    configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

    CLR_BIT(DDRA, PIN1);
    3264:	d1 98       	cbi	0x1a, 1	; 26
	SET_BIT(DDRA, PIN2);
    3266:	d2 9a       	sbi	0x1a, 2	; 26

	for( ;; )
    {
    	if (GET_BIT(PINA, PIN1) == 1){
    3268:	c9 9b       	sbis	0x19, 1	; 25
    326a:	02 c0       	rjmp	.+4      	; 0x3270 <vGasTaskCode+0xc>
    		SET_BIT(PORTA , PIN2);
    326c:	da 9a       	sbi	0x1b, 2	; 27
    326e:	01 c0       	rjmp	.+2      	; 0x3272 <vGasTaskCode+0xe>
    	}
    	else{
    		CLR_BIT(PORTA , PIN2);
    3270:	da 98       	cbi	0x1b, 2	; 27
    	}
    vTaskDelay(250);
    3272:	8a ef       	ldi	r24, 0xFA	; 250
    3274:	90 e0       	ldi	r25, 0x00	; 0
    3276:	0e 94 e5 16 	call	0x2dca	; 0x2dca <vTaskDelay>
    327a:	f6 cf       	rjmp	.-20     	; 0x3268 <vGasTaskCode+0x4>

0000327c <vLDRTaskCode>:

void vLDRTaskCode (void * pvParameters){

    configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

    CLR_BIT(DDRA, PIN4); // ADC
    327c:	d4 98       	cbi	0x1a, 4	; 26

	SET_BIT(DDRD , PIN3);
    327e:	8b 9a       	sbi	0x11, 3	; 17
	SET_BIT(DDRD , PIN4);
    3280:	8c 9a       	sbi	0x11, 4	; 17
	SET_BIT(DDRD , PIN5);
    3282:	8d 9a       	sbi	0x11, 5	; 17

    for( ;; )
    {
    	// LDR condition
    	LED_Digital_value = ADC_read(4);
    3284:	84 e0       	ldi	r24, 0x04	; 4
    3286:	90 e0       	ldi	r25, 0x00	; 0
    3288:	0e 94 0c 06 	call	0xc18	; 0xc18 <ADC_read>
    328c:	9c 01       	movw	r18, r24
    328e:	44 27       	eor	r20, r20
    3290:	37 fd       	sbrc	r19, 7
    3292:	40 95       	com	r20
    3294:	54 2f       	mov	r21, r20
    3296:	20 93 54 04 	sts	0x0454, r18
    329a:	30 93 55 04 	sts	0x0455, r19
    329e:	40 93 56 04 	sts	0x0456, r20
    32a2:	50 93 57 04 	sts	0x0457, r21
    	if (LED_Digital_value > 1000){
    32a6:	29 3e       	cpi	r18, 0xE9	; 233
    32a8:	83 e0       	ldi	r24, 0x03	; 3
    32aa:	38 07       	cpc	r19, r24
    32ac:	80 e0       	ldi	r24, 0x00	; 0
    32ae:	48 07       	cpc	r20, r24
    32b0:	80 e0       	ldi	r24, 0x00	; 0
    32b2:	58 07       	cpc	r21, r24
    32b4:	20 f0       	brcs	.+8      	; 0x32be <vLDRTaskCode+0x42>
    		CLR_BIT(PORTD, PIN3);
    32b6:	93 98       	cbi	0x12, 3	; 18
    		CLR_BIT(PORTD, PIN4);
    32b8:	94 98       	cbi	0x12, 4	; 18
   			CLR_BIT(PORTD, PIN5);
    32ba:	95 98       	cbi	0x12, 5	; 18
    32bc:	15 c0       	rjmp	.+42     	; 0x32e8 <vLDRTaskCode+0x6c>
    	}else if (LED_Digital_value > 800){
    32be:	21 32       	cpi	r18, 0x21	; 33
    32c0:	83 e0       	ldi	r24, 0x03	; 3
    32c2:	38 07       	cpc	r19, r24
    32c4:	80 e0       	ldi	r24, 0x00	; 0
    32c6:	48 07       	cpc	r20, r24
    32c8:	80 e0       	ldi	r24, 0x00	; 0
    32ca:	58 07       	cpc	r21, r24
    32cc:	18 f0       	brcs	.+6      	; 0x32d4 <vLDRTaskCode+0x58>
    		CLR_BIT(PORTD, PIN3);
    32ce:	93 98       	cbi	0x12, 3	; 18
   			CLR_BIT(PORTD, PIN4);
    32d0:	94 98       	cbi	0x12, 4	; 18
    32d2:	09 c0       	rjmp	.+18     	; 0x32e6 <vLDRTaskCode+0x6a>
   			SET_BIT(PORTD, PIN5);
    	}else if (LED_Digital_value > 300){
    32d4:	2d 52       	subi	r18, 0x2D	; 45
    32d6:	31 40       	sbci	r19, 0x01	; 1
    32d8:	40 40       	sbci	r20, 0x00	; 0
    32da:	50 40       	sbci	r21, 0x00	; 0
    32dc:	10 f0       	brcs	.+4      	; 0x32e2 <vLDRTaskCode+0x66>
    		CLR_BIT(PORTD, PIN3);
    32de:	93 98       	cbi	0x12, 3	; 18
    32e0:	01 c0       	rjmp	.+2      	; 0x32e4 <vLDRTaskCode+0x68>
    		SET_BIT(PORTD, PIN4);
    		SET_BIT(PORTD, PIN5);
   		}else{
    		SET_BIT(PORTD, PIN3);
    32e2:	93 9a       	sbi	0x12, 3	; 18
    		SET_BIT(PORTD, PIN4);
    32e4:	94 9a       	sbi	0x12, 4	; 18
    		SET_BIT(PORTD, PIN5);
    32e6:	95 9a       	sbi	0x12, 5	; 18
   		}
    vTaskDelay(250);
    32e8:	8a ef       	ldi	r24, 0xFA	; 250
    32ea:	90 e0       	ldi	r25, 0x00	; 0
    32ec:	0e 94 e5 16 	call	0x2dca	; 0x2dca <vTaskDelay>
    32f0:	c9 cf       	rjmp	.-110    	; 0x3284 <vLDRTaskCode+0x8>

000032f2 <vTempTaskCode>:

void vTempTaskCode(void * pvParameters){

    configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

    SET_BIT(DDRB,PIN0); // BUZZER 1
    32f2:	b8 9a       	sbi	0x17, 0	; 23
    SET_BIT(DDRA,PIN5); // Air conditioner
    32f4:	d5 9a       	sbi	0x1a, 5	; 26

    for( ;; )
    {
    	analog_value = ADC_read(0) * step_size;
    32f6:	80 e0       	ldi	r24, 0x00	; 0
    32f8:	90 e0       	ldi	r25, 0x00	; 0
    32fa:	0e 94 0c 06 	call	0xc18	; 0xc18 <ADC_read>
    32fe:	aa 27       	eor	r26, r26
    3300:	97 fd       	sbrc	r25, 7
    3302:	a0 95       	com	r26
    3304:	ba 2f       	mov	r27, r26
    3306:	bc 01       	movw	r22, r24
    3308:	cd 01       	movw	r24, r26
    330a:	0e 94 49 03 	call	0x692	; 0x692 <__floatsisf>
    330e:	20 e0       	ldi	r18, 0x00	; 0
    3310:	30 e4       	ldi	r19, 0x40	; 64
    3312:	4c e9       	ldi	r20, 0x9C	; 156
    3314:	50 e4       	ldi	r21, 0x40	; 64
    3316:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    331a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    331e:	60 93 59 04 	sts	0x0459, r22
    3322:	70 93 5a 04 	sts	0x045A, r23
    3326:	80 93 5b 04 	sts	0x045B, r24
    332a:	90 93 5c 04 	sts	0x045C, r25
    	Current_Temp = analog_value /10;
    332e:	2a e0       	ldi	r18, 0x0A	; 10
    3330:	30 e0       	ldi	r19, 0x00	; 0
    3332:	40 e0       	ldi	r20, 0x00	; 0
    3334:	50 e0       	ldi	r21, 0x00	; 0
    3336:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__udivmodsi4>
    333a:	20 93 58 04 	sts	0x0458, r18
    	if (Current_Temp > 29 && Current_Temp < 50){
    333e:	82 2f       	mov	r24, r18
    3340:	8e 51       	subi	r24, 0x1E	; 30
    3342:	84 31       	cpi	r24, 0x14	; 20
    3344:	18 f4       	brcc	.+6      	; 0x334c <vTempTaskCode+0x5a>
    		SET_BIT(PORTA,PIN5); // Start air conditioner
    3346:	dd 9a       	sbi	0x1b, 5	; 27
    		CLR_BIT(PORTB, PIN0); // Stop BUZZER
    3348:	c0 98       	cbi	0x18, 0	; 24
    334a:	06 c0       	rjmp	.+12     	; 0x3358 <vTempTaskCode+0x66>
    	}
    	else if (Current_Temp >= 50) {
    334c:	22 33       	cpi	r18, 0x32	; 50
    334e:	18 f0       	brcs	.+6      	; 0x3356 <vTempTaskCode+0x64>
    		CLR_BIT(PORTA,PIN5); // Stop air conditioner
    3350:	dd 98       	cbi	0x1b, 5	; 27
        	SET_BIT(PORTB , PIN0); // Start BUZZER
    3352:	c0 9a       	sbi	0x18, 0	; 24
    3354:	01 c0       	rjmp	.+2      	; 0x3358 <vTempTaskCode+0x66>
    	}
    	else{
    		CLR_BIT(PORTA,PIN5); // Stop air conditioner
    3356:	dd 98       	cbi	0x1b, 5	; 27
    	}
    	vTaskDelay(250);
    3358:	8a ef       	ldi	r24, 0xFA	; 250
    335a:	90 e0       	ldi	r25, 0x00	; 0
    335c:	0e 94 e5 16 	call	0x2dca	; 0x2dca <vTaskDelay>
    3360:	ca cf       	rjmp	.-108    	; 0x32f6 <vTempTaskCode+0x4>

00003362 <main>:

BaseType_t xLDRTask,xTempTask,xGasTask;

TaskHandle_t LDR_Handle = NULL, Temp_Handle = NULL, Gas_Handle = NULL, BUZ1_Handle = NULL ;

void main(){
    3362:	ef 92       	push	r14
    3364:	ff 92       	push	r15
    3366:	0f 93       	push	r16
	// Initializations :
	SPI_voidInit(Slave);
    3368:	81 e0       	ldi	r24, 0x01	; 1
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <SPI_voidInit>
	ADC_init();
    3370:	0e 94 09 06 	call	0xc12	; 0xc12 <ADC_init>
    3374:	06 c0       	rjmp	.+12     	; 0x3382 <main+0x20>

	//APP
	while(Data == 0){
		Data = SPI_u8transcieve(1);
    3376:	81 e0       	ldi	r24, 0x01	; 1
    3378:	90 e0       	ldi	r25, 0x00	; 0
    337a:	0e 94 04 06 	call	0xc08	; 0xc08 <SPI_u8transcieve>
    337e:	80 93 5d 04 	sts	0x045D, r24
	// Initializations :
	SPI_voidInit(Slave);
	ADC_init();

	//APP
	while(Data == 0){
    3382:	80 91 5d 04 	lds	r24, 0x045D
    3386:	88 23       	and	r24, r24
    3388:	b1 f3       	breq	.-20     	; 0x3376 <main+0x14>
		Data = SPI_u8transcieve(1);
	}
	if(Data != 0 ){
		BUZ_Enable = 0 ;
    338a:	10 92 51 04 	sts	0x0451, r1
	}

	xTempTask = xTaskCreate(vTempTaskCode ,"Temperature",configMINIMAL_STACK_SIZE,NULL,1,&Temp_Handle);
    338e:	89 e7       	ldi	r24, 0x79	; 121
    3390:	99 e1       	ldi	r25, 0x19	; 25
    3392:	65 e6       	ldi	r22, 0x65	; 101
    3394:	70 e0       	ldi	r23, 0x00	; 0
    3396:	45 e5       	ldi	r20, 0x55	; 85
    3398:	50 e0       	ldi	r21, 0x00	; 0
    339a:	20 e0       	ldi	r18, 0x00	; 0
    339c:	30 e0       	ldi	r19, 0x00	; 0
    339e:	01 e0       	ldi	r16, 0x01	; 1
    33a0:	f0 e6       	ldi	r31, 0x60	; 96
    33a2:	ef 2e       	mov	r14, r31
    33a4:	f4 e0       	ldi	r31, 0x04	; 4
    33a6:	ff 2e       	mov	r15, r31
    33a8:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <xTaskCreate>
    33ac:	80 93 67 04 	sts	0x0467, r24
	xLDRTask = xTaskCreate(vLDRTaskCode ,"LDR",configMINIMAL_STACK_SIZE,NULL,1,&LDR_Handle);
    33b0:	8e e3       	ldi	r24, 0x3E	; 62
    33b2:	99 e1       	ldi	r25, 0x19	; 25
    33b4:	61 e7       	ldi	r22, 0x71	; 113
    33b6:	70 e0       	ldi	r23, 0x00	; 0
    33b8:	45 e5       	ldi	r20, 0x55	; 85
    33ba:	50 e0       	ldi	r21, 0x00	; 0
    33bc:	20 e0       	ldi	r18, 0x00	; 0
    33be:	30 e0       	ldi	r19, 0x00	; 0
    33c0:	ee e5       	ldi	r30, 0x5E	; 94
    33c2:	ee 2e       	mov	r14, r30
    33c4:	e4 e0       	ldi	r30, 0x04	; 4
    33c6:	fe 2e       	mov	r15, r30
    33c8:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <xTaskCreate>
    33cc:	80 93 66 04 	sts	0x0466, r24
	vTaskStartScheduler();
    33d0:	0e 94 08 19 	call	0x3210	; 0x3210 <vTaskStartScheduler>
    33d4:	ff cf       	rjmp	.-2      	; 0x33d4 <main+0x72>

000033d6 <__udivmodhi4>:
    33d6:	aa 1b       	sub	r26, r26
    33d8:	bb 1b       	sub	r27, r27
    33da:	51 e1       	ldi	r21, 0x11	; 17
    33dc:	07 c0       	rjmp	.+14     	; 0x33ec <__udivmodhi4_ep>

000033de <__udivmodhi4_loop>:
    33de:	aa 1f       	adc	r26, r26
    33e0:	bb 1f       	adc	r27, r27
    33e2:	a6 17       	cp	r26, r22
    33e4:	b7 07       	cpc	r27, r23
    33e6:	10 f0       	brcs	.+4      	; 0x33ec <__udivmodhi4_ep>
    33e8:	a6 1b       	sub	r26, r22
    33ea:	b7 0b       	sbc	r27, r23

000033ec <__udivmodhi4_ep>:
    33ec:	88 1f       	adc	r24, r24
    33ee:	99 1f       	adc	r25, r25
    33f0:	5a 95       	dec	r21
    33f2:	a9 f7       	brne	.-22     	; 0x33de <__udivmodhi4_loop>
    33f4:	80 95       	com	r24
    33f6:	90 95       	com	r25
    33f8:	bc 01       	movw	r22, r24
    33fa:	cd 01       	movw	r24, r26
    33fc:	08 95       	ret

000033fe <__udivmodsi4>:
    33fe:	a1 e2       	ldi	r26, 0x21	; 33
    3400:	1a 2e       	mov	r1, r26
    3402:	aa 1b       	sub	r26, r26
    3404:	bb 1b       	sub	r27, r27
    3406:	fd 01       	movw	r30, r26
    3408:	0d c0       	rjmp	.+26     	; 0x3424 <__udivmodsi4_ep>

0000340a <__udivmodsi4_loop>:
    340a:	aa 1f       	adc	r26, r26
    340c:	bb 1f       	adc	r27, r27
    340e:	ee 1f       	adc	r30, r30
    3410:	ff 1f       	adc	r31, r31
    3412:	a2 17       	cp	r26, r18
    3414:	b3 07       	cpc	r27, r19
    3416:	e4 07       	cpc	r30, r20
    3418:	f5 07       	cpc	r31, r21
    341a:	20 f0       	brcs	.+8      	; 0x3424 <__udivmodsi4_ep>
    341c:	a2 1b       	sub	r26, r18
    341e:	b3 0b       	sbc	r27, r19
    3420:	e4 0b       	sbc	r30, r20
    3422:	f5 0b       	sbc	r31, r21

00003424 <__udivmodsi4_ep>:
    3424:	66 1f       	adc	r22, r22
    3426:	77 1f       	adc	r23, r23
    3428:	88 1f       	adc	r24, r24
    342a:	99 1f       	adc	r25, r25
    342c:	1a 94       	dec	r1
    342e:	69 f7       	brne	.-38     	; 0x340a <__udivmodsi4_loop>
    3430:	60 95       	com	r22
    3432:	70 95       	com	r23
    3434:	80 95       	com	r24
    3436:	90 95       	com	r25
    3438:	9b 01       	movw	r18, r22
    343a:	ac 01       	movw	r20, r24
    343c:	bd 01       	movw	r22, r26
    343e:	cf 01       	movw	r24, r30
    3440:	08 95       	ret

00003442 <__prologue_saves__>:
    3442:	2f 92       	push	r2
    3444:	3f 92       	push	r3
    3446:	4f 92       	push	r4
    3448:	5f 92       	push	r5
    344a:	6f 92       	push	r6
    344c:	7f 92       	push	r7
    344e:	8f 92       	push	r8
    3450:	9f 92       	push	r9
    3452:	af 92       	push	r10
    3454:	bf 92       	push	r11
    3456:	cf 92       	push	r12
    3458:	df 92       	push	r13
    345a:	ef 92       	push	r14
    345c:	ff 92       	push	r15
    345e:	0f 93       	push	r16
    3460:	1f 93       	push	r17
    3462:	cf 93       	push	r28
    3464:	df 93       	push	r29
    3466:	cd b7       	in	r28, 0x3d	; 61
    3468:	de b7       	in	r29, 0x3e	; 62
    346a:	ca 1b       	sub	r28, r26
    346c:	db 0b       	sbc	r29, r27
    346e:	0f b6       	in	r0, 0x3f	; 63
    3470:	f8 94       	cli
    3472:	de bf       	out	0x3e, r29	; 62
    3474:	0f be       	out	0x3f, r0	; 63
    3476:	cd bf       	out	0x3d, r28	; 61
    3478:	09 94       	ijmp

0000347a <__epilogue_restores__>:
    347a:	2a 88       	ldd	r2, Y+18	; 0x12
    347c:	39 88       	ldd	r3, Y+17	; 0x11
    347e:	48 88       	ldd	r4, Y+16	; 0x10
    3480:	5f 84       	ldd	r5, Y+15	; 0x0f
    3482:	6e 84       	ldd	r6, Y+14	; 0x0e
    3484:	7d 84       	ldd	r7, Y+13	; 0x0d
    3486:	8c 84       	ldd	r8, Y+12	; 0x0c
    3488:	9b 84       	ldd	r9, Y+11	; 0x0b
    348a:	aa 84       	ldd	r10, Y+10	; 0x0a
    348c:	b9 84       	ldd	r11, Y+9	; 0x09
    348e:	c8 84       	ldd	r12, Y+8	; 0x08
    3490:	df 80       	ldd	r13, Y+7	; 0x07
    3492:	ee 80       	ldd	r14, Y+6	; 0x06
    3494:	fd 80       	ldd	r15, Y+5	; 0x05
    3496:	0c 81       	ldd	r16, Y+4	; 0x04
    3498:	1b 81       	ldd	r17, Y+3	; 0x03
    349a:	aa 81       	ldd	r26, Y+2	; 0x02
    349c:	b9 81       	ldd	r27, Y+1	; 0x01
    349e:	ce 0f       	add	r28, r30
    34a0:	d1 1d       	adc	r29, r1
    34a2:	0f b6       	in	r0, 0x3f	; 63
    34a4:	f8 94       	cli
    34a6:	de bf       	out	0x3e, r29	; 62
    34a8:	0f be       	out	0x3f, r0	; 63
    34aa:	cd bf       	out	0x3d, r28	; 61
    34ac:	ed 01       	movw	r28, r26
    34ae:	08 95       	ret

000034b0 <memcpy>:
    34b0:	fb 01       	movw	r30, r22
    34b2:	dc 01       	movw	r26, r24
    34b4:	02 c0       	rjmp	.+4      	; 0x34ba <memcpy+0xa>
    34b6:	01 90       	ld	r0, Z+
    34b8:	0d 92       	st	X+, r0
    34ba:	41 50       	subi	r20, 0x01	; 1
    34bc:	50 40       	sbci	r21, 0x00	; 0
    34be:	d8 f7       	brcc	.-10     	; 0x34b6 <memcpy+0x6>
    34c0:	08 95       	ret

000034c2 <memset>:
    34c2:	dc 01       	movw	r26, r24
    34c4:	01 c0       	rjmp	.+2      	; 0x34c8 <memset+0x6>
    34c6:	6d 93       	st	X+, r22
    34c8:	41 50       	subi	r20, 0x01	; 1
    34ca:	50 40       	sbci	r21, 0x00	; 0
    34cc:	e0 f7       	brcc	.-8      	; 0x34c6 <memset+0x4>
    34ce:	08 95       	ret

000034d0 <_exit>:
    34d0:	f8 94       	cli

000034d2 <__stop_program>:
    34d2:	ff cf       	rjmp	.-2      	; 0x34d2 <__stop_program>
